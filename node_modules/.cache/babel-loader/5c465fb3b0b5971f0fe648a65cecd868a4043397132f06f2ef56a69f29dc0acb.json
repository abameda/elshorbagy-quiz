{"ast":null,"code":"const quizData={'Chapter 1: Introduction':[{question:\"What is the main distinction between computer architecture and computer organization?\",options:[\"Architecture deals with hardware, organization deals with software\",\"Architecture refers to attributes visible to programmer, organization refers to how features are implemented\",\"Architecture is about performance, organization is about cost\",\"There is no distinction between them\"],correct:1,explanation:\"Architecture includes instruction set, data representation, I/O mechanisms - what's visible to programmers. Organization covers control signals, interfaces, memory technology - the implementation details.\"},{question:\"Which of the following is NOT one of the four basic computer functions?\",options:[\"Data processing\",\"Data storage\",\"Data compilation\",\"Data movement\"],correct:2,explanation:\"The four basic functions are: data processing, data storage, data movement, and control. Data compilation is a software process, not a basic computer function.\"},{question:\"What does the Program Counter (PC) register contain?\",options:[\"The current instruction being executed\",\"The address of the next instruction pair to be fetched\",\"The result of the last arithmetic operation\",\"The memory address being accessed\"],correct:1,explanation:\"The Program Counter (PC) contains the address of the next instruction pair to be fetched from memory.\"},{question:\"In a multicore system, what is a 'core'?\",options:[\"The entire CPU chip\",\"An individual processing unit on a processor chip\",\"The system bus connecting components\",\"The cache memory hierarchy\"],correct:1,explanation:\"A core is an individual processing unit on a processor chip, which may be equivalent in functionality to a CPU on a single-CPU system.\"},{question:\"What is the relationship between clock frequency and clock cycle time?\",options:[\"They are the same thing\",\"Clock cycle time = clock frequency × 2\",\"Clock cycle time = 1 / clock frequency\",\"There is no mathematical relationship\"],correct:2,explanation:\"Clock cycle time is the reciprocal of clock frequency. For example, an 800 MHz clock has a cycle time of 1.25 ns.\"},{question:\"Which component manages the computer's resources and orchestrates performance?\",options:[\"ALU (Arithmetic Logic Unit)\",\"Memory\",\"Control Unit\",\"Registers\"],correct:2,explanation:\"The control unit manages the computer's resources and orchestrates the performance of its functional parts in response to instructions.\"},{question:\"What is the primary purpose of cache memory?\",options:[\"To store the operating system\",\"To backup main memory\",\"To speed up memory access by storing likely-to-be-used data\",\"To control input/output operations\"],correct:2,explanation:\"Cache memory is smaller and faster than main memory, used to speed up memory access by placing data from main memory that is likely to be used in the near future.\"},{question:\"Which register contains the 8-bit opcode instruction being executed?\",options:[\"Program Counter (PC)\",\"Instruction Register (IR)\",\"Memory Address Register (MAR)\",\"Accumulator (AC)\"],correct:1,explanation:\"The Instruction Register (IR) contains the 8-bit opcode instruction being executed.\"},{question:\"What is the function of the Memory Address Register (MAR)?\",options:[\"Contains the instruction being executed\",\"Stores temporary data for ALU operations\",\"Specifies the address in memory of the word to be written or read\",\"Controls the sequence of operations\"],correct:2,explanation:\"The Memory Address Register (MAR) specifies the address in memory of the word to be written from or read into the MBR.\"},{question:\"In embedded systems, what characterizes 'deeply embedded systems'?\",options:[\"They run complex operating systems\",\"They are programmable after deployment\",\"They are dedicated to specific tasks with extreme resource constraints\",\"They always have user interfaces\"],correct:2,explanation:\"Deeply embedded systems are dedicated, single-purpose devices with extreme resource constraints in terms of memory, processor size, time, and power consumption.\"},{question:\"What are the four main structural components of a computer?\",options:[\"CPU, RAM, ROM, Hard Drive\",\"CPU, Main Memory, I/O, System Interconnection\",\"Control Unit, ALU, Registers, Cache\",\"Processor, Memory, Storage, Network\"],correct:1,explanation:\"The four main structural components are: CPU (controls operation and data processing), Main Memory (stores data), I/O (moves data with external environment), and System Interconnection (communication mechanism).\"},{question:\"What is the difference between response time and throughput?\",options:[\"They are the same metric\",\"Response time is speed, throughput is accuracy\",\"Response time is time for one task, throughput is tasks per unit time\",\"Response time is for CPU, throughput is for memory\"],correct:2,explanation:\"Response time is the time between start and completion of a task, while throughput is the total amount of tasks done in a given time period. There is generally no relationship between these metrics.\"},{question:\"What does the Memory Buffer Register (MBR) contain?\",options:[\"The address of the next instruction\",\"A word to be stored in memory or received from memory/I/O\",\"The current instruction being decoded\",\"Control signals for the ALU\"],correct:1,explanation:\"The Memory Buffer Register (MBR) contains a word to be stored in memory or sent to the I/O unit, or is used to receive a word from memory or from the I/O unit.\"},{question:\"Which generation of IoT deployment is characterized by billions of embedded devices?\",options:[\"Information Technology (IT)\",\"Operational Technology (OT)\",\"Personal Technology\",\"Sensor/Actuator Technology\"],correct:3,explanation:\"The fourth generation, Sensor/Actuator Technology, is usually thought of as the IoT and is marked by the use of billions of embedded devices using wireless connectivity.\"},{question:\"What is the primary function of the Instruction Buffer Register (IBR)?\",options:[\"To store the program counter value\",\"To temporarily hold the right-hand instruction from memory\",\"To contain the address of data in memory\",\"To store the result of arithmetic operations\"],correct:1,explanation:\"The Instruction Buffer Register (IBR) is employed to temporarily hold the right-hand instruction from a word in memory.\"},{question:\"In the context of data movement, what distinguishes I/O from data communications?\",options:[\"Speed of data transfer\",\"Type of data being moved\",\"Distance - I/O is direct connection, data communications is over longer distances\",\"Security requirements\"],correct:2,explanation:\"I/O occurs when data are received from or delivered to a device directly connected to the computer, while data communications involves moving data over longer distances to or from remote devices.\"},{question:\"What is the key difference between application processors and dedicated processors in embedded systems?\",options:[\"Power consumption levels\",\"Manufacturing cost\",\"Application processors execute complex OS, dedicated processors serve specific tasks\",\"Physical size differences\"],correct:2,explanation:\"Application processors are defined by their ability to execute complex operating systems and are general-purpose, while dedicated processors are dedicated to one or a small number of specific tasks.\"},{question:\"Which components provide the four basic functions of integrated circuits?\",options:[\"Transistors, resistors, capacitors, inductors\",\"Gates (processing), memory cells (storage), paths (movement), control signals (control)\",\"CPU, memory, I/O, interconnection\",\"Hardware, software, firmware, middleware\"],correct:1,explanation:\"In integrated circuits: gates provide data processing, memory cells provide data storage, paths provide data movement, and control signals provide control functions.\"},{question:\"What advantage do Intel x86 and IBM System/370 families demonstrate?\",options:[\"Higher performance than competitors\",\"Lower manufacturing costs\",\"Code compatibility through shared basic architecture\",\"Better power efficiency\"],correct:2,explanation:\"All Intel x86 family and IBM System/370 family share the same basic architecture, which gives code compatibility (at least backwards), even though organization differs between versions.\"},{question:\"In deeply embedded systems, what type of processor is typically used?\",options:[\"Microprocessor\",\"Microcontroller\",\"Graphics processor\",\"Digital signal processor\"],correct:1,explanation:\"Deeply embedded systems use a microcontroller rather than a microprocessor, are not programmable once the program logic has been burned into ROM, and have no interaction with a user.\"},{question:\"What are the major structural components of a CPU?\",options:[\"Cache, registers, bus, clock\",\"Control Unit, ALU, Registers, CPU Interconnection\",\"Fetch unit, decode unit, execute unit, write-back unit\",\"L1 cache, L2 cache, L3 cache, main memory interface\"],correct:1,explanation:\"The CPU's major structural components are: Control Unit (controls CPU operation), ALU (performs data processing), Registers (provide internal storage), and CPU Interconnection (provides communication among components).\"},{question:\"What characterizes embedded systems' interaction with their environment?\",options:[\"They operate independently of external factors\",\"They are tightly coupled with real-time constraints\",\"They only process stored data\",\"They communicate only through network interfaces\"],correct:1,explanation:\"Embedded systems are often tightly coupled to their environment, giving rise to real-time constraints imposed by the need to interact with the environment, such as required speeds, precision, and timing.\"}],'Chapter 2: Storage Environment and RAID':[{question:\"What is the main difference between memory modules and storage devices?\",options:[\"Memory modules are cheaper than storage devices\",\"Memory modules use semiconductor chips while storage devices use magnetic or optical media\",\"Storage devices are faster than memory modules\",\"Memory modules are non-volatile while storage devices are volatile\"],correct:1,explanation:\"Memory modules are implemented using semiconductor chips, whereas storage devices use either magnetic or optical media. Memory modules also enable data access at higher speed than storage media.\"},{question:\"Which type of memory is volatile and requires constant power supply?\",options:[\"ROM (Read-Only Memory)\",\"RAM (Random Access Memory)\",\"Hard disk storage\",\"CD-ROM storage\"],correct:1,explanation:\"RAM is volatile and requires a constant supply of power to maintain memory cell content. Data is erased when the system's power is turned off or interrupted.\"},{question:\"What does DAS stand for and how does it connect to servers?\",options:[\"Direct Access Storage - connects via network protocols\",\"Distributed Array Storage - connects via fiber optic cables\",\"Direct Attached Storage - connects directly through Host Bus Adapter (HBA)\",\"Dynamic Allocation Storage - connects via USB only\"],correct:2,explanation:\"DAS stands for Direct Attached Storage. It connects directly to a server through Host Bus Adapter (HBA), with no network between storage and host servers.\"},{question:\"What is the main advantage of DAS over other storage environments?\",options:[\"Accessibility from multiple devices\",\"Fast performance and simple setup\",\"Network sharing capabilities\",\"Lowest cost among all options\"],correct:1,explanation:\"DAS offers fast performance, high capacity options, and simple setup as its main advantages.\"},{question:\"What is the primary disadvantage of DAS?\",options:[\"Slow performance\",\"High cost\",\"Not accessible from other devices and prone to data loss if connected computer fails\",\"Complex setup requirements\"],correct:2,explanation:\"DAS is not accessible from other devices and is prone to data loss if the connected computer fails.\"},{question:\"What does SAN stand for and what is its primary characteristic?\",options:[\"Storage Access Network - a wireless storage solution\",\"System Area Network - connects only servers\",\"Storage Area Networks - a dedicated data storage network accessible by multiple servers\",\"Secure Access Network - provides encrypted storage\"],correct:2,explanation:\"SAN stands for Storage Area Networks. It is a dedicated data storage network which can be accessed by multiple servers.\"},{question:\"Which storage environment offers the fastest performance?\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:1,explanation:\"SAN offers the fastest performance among the options due to its dedicated network specifically designed for high-performance connections.\"},{question:\"What are the main protocols used in SAN?\",options:[\"TCP/IP and HTTP\",\"SCSI and SATA\",\"USB and FireWire\",\"Ethernet and WiFi\"],correct:1,explanation:\"The protocols that are used in SAN are SCSI and SATA.\"},{question:\"What is the main weakness of SAN mentioned in the document?\",options:[\"Speed and Latency\",\"Security\",\"Cost\",\"Complexity\"],correct:1,explanation:\"According to the document, the weakness of SAN is Security, while Speed and Latency are listed as disadvantages.\"},{question:\"What does NAS stand for and at what level does it operate?\",options:[\"Network Access Storage - operates at block level\",\"Network Attached Storage - operates at file level\",\"Network Array Storage - operates at bit level\",\"Network Administration Storage - operates at system level\"],correct:1,explanation:\"NAS stands for Network Attached Storage. It is a file level computer data storage that connects to other devices on TCP/IP network.\"},{question:\"Which component is NOT part of NAS architecture?\",options:[\"Head unit (CPU, Memory)\",\"Network Interface Card (NIC)\",\"Host Bus Adapter (HBA)\",\"Optimized operating system\"],correct:2,explanation:\"Host Bus Adapter (HBA) is a component of DAS, not NAS. NAS components include Head unit, NIC, optimized OS, protocols, and storage protocols.\"},{question:\"What does RAID stand for?\",options:[\"Random Array of Independent Disks\",\"Redundant Array of Independent Disks\",\"Reliable Array of Integrated Disks\",\"Rapid Access of Internal Disks\"],correct:1,explanation:\"RAID stands for Redundant Array of Independent Disks.\"},{question:\"Which RAID function writes consecutive logical blocks on consecutive physical disks?\",options:[\"Mirroring\",\"Striping\",\"Parity Calculation\",\"Synchronization\"],correct:1,explanation:\"Striping writes consecutive logical byte/blocks on consecutive physical disks.\"},{question:\"Which RAID level provides striping with no parity or redundancy?\",options:[\"RAID 1\",\"RAID 0\",\"RAID 5\",\"RAID 10\"],correct:1,explanation:\"RAID 0 provides stripe with no parity, offering excellent performance but no redundancy.\"},{question:\"What is the minimum number of disks required for RAID 1?\",options:[\"1 disk\",\"2 disks\",\"3 disks\",\"4 disks\"],correct:1,explanation:\"RAID 1 requires a minimum of 2 disks and provides excellent redundancy as blocks are mirrored.\"},{question:\"Which RAID level is described as 'stripe of mirrors'?\",options:[\"RAID 0+1\",\"RAID 5\",\"RAID 10\",\"RAID 6\"],correct:2,explanation:\"RAID 10 is also called 'stripe of mirrors' and requires a minimum of 4 disks.\"},{question:\"What is the minimum number of disks required for RAID 5?\",options:[\"2 disks\",\"3 disks\",\"4 disks\",\"5 disks\"],correct:1,explanation:\"RAID 5 requires a minimum of 3 disks and provides good performance with distributed parity.\"},{question:\"Which RAID level uses byte-level striping?\",options:[\"RAID 3\",\"RAID 4\",\"RAID 5\",\"RAID 6\"],correct:0,explanation:\"RAID 3 uses byte level striping, while RAID 4 uses block level striping.\"},{question:\"What makes RAID 6 different from RAID 5?\",options:[\"It uses striping instead of mirroring\",\"It has double parity blocks and requires 6 disks\",\"It provides better performance\",\"It uses fewer disks\"],correct:1,explanation:\"RAID 6 is similar to RAID 5 except it has double parity blocks and requires 6 disks.\"},{question:\"Which RAID level is recommended for heavily read-oriented databases?\",options:[\"RAID 0\",\"RAID 1\",\"RAID 5\",\"RAID 10\"],correct:2,explanation:\"RAID 5 is the best cost effective option providing both performance and redundancy, recommended for databases that are heavily read oriented, though write operations will be slow.\"},{question:\"Which RAID level is considered the BEST option for mission critical applications?\",options:[\"RAID 0\",\"RAID 5\",\"RAID 6\",\"RAID 10\"],correct:3,explanation:\"RAID 10 provides excellent redundancy and excellent performance. If you can afford it, this is the BEST option for any mission critical applications, especially databases.\"},{question:\"Which storage environment would be best for a single user storing personal files?\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:0,explanation:\"DAS is best for individual workstations and storing personal data due to its fast performance and simple setup.\"},{question:\"Which storage environment is most suitable for small businesses with multiple employees sharing files?\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:2,explanation:\"NAS is best for small businesses and workgroups as it provides shared storage accessible from multiple devices on the network.\"},{question:\"Which storage environment requires the most technical expertise to manage?\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:1,explanation:\"SAN requires significant technical expertise to manage due to its specialized hardware and complex configuration.\"},{question:\"In terms of cost ranking from lowest to highest, what is the correct order?\",options:[\"SAN, NAS, DAS\",\"DAS, NAS, SAN\",\"NAS, DAS, SAN\",\"DAS, SAN, NAS\"],correct:1,explanation:\"DAS is generally the cheapest, followed by NAS, then SAN is the most expensive due to specialized hardware and configuration.\"},{question:\"Which statement about RAID is TRUE?\",options:[\"RAID guarantees complete data protection against any failure\",\"All RAID levels offer the same level of performance and redundancy\",\"RAID can be implemented on both DAS and NAS systems\",\"Using RAID eliminates the need for backups\"],correct:2,explanation:\"RAID can be implemented on both DAS and NAS systems for added benefits. RAID does not guarantee complete protection, levels differ in performance/redundancy, and backups are still needed.\"},{question:\"What type of data access does SAN provide?\",options:[\"File level data access\",\"Block level data storage\",\"Byte level data access\",\"Application level data access\"],correct:1,explanation:\"SAN provides block level data storage, allowing multiple clients to access files at the same time with very high performance.\"},{question:\"Which benefit is NOT associated with NAS?\",options:[\"Relatively inexpensive\",\"24/7 and remote data availability\",\"Fastest performance among storage options\",\"Automatic backups to other devices and cloud\"],correct:2,explanation:\"NAS has slower performance compared to DAS due to network overhead. The fastest performance is provided by SAN.\"},{question:\"What happens to RAM data when power is interrupted?\",options:[\"Data is automatically backed up\",\"Data remains intact\",\"Data is erased\",\"Data is transferred to ROM\"],correct:2,explanation:\"RAM is volatile and requires constant power supply. Data is erased when the system's power is turned off or interrupted.\"},{question:\"Which RAID level should NOT be used for critical systems?\",options:[\"RAID 0\",\"RAID 1\",\"RAID 5\",\"RAID 10\"],correct:0,explanation:\"RAID 0 has no redundancy (no mirror, no parity), so it should not be used for any critical system despite its excellent performance.\"}],'Chapter 3: Computer Architecture Introduction and Basics':[{question:\"What is the main purpose of computing according to Richard Hamming?\",options:[\"To generate numbers and data\",\"To provide insight, not just numbers\",\"To execute instructions efficiently\",\"To solve mathematical equations\"],correct:1,explanation:\"According to Richard Hamming, 'The purpose of computing is insight, not numbers.' The true value of computing lies in using data to gain understanding and knowledge (insight).\"},{question:\"Which transformation level is directly above Logic in the hierarchy?\",options:[\"Circuits\",\"Microarchitecture\",\"ISA (Architecture)\",\"Runtime System\"],correct:1,explanation:\"In the levels of transformation hierarchy, Microarchitecture is directly above Logic, which is above Circuits.\"},{question:\"What is abstraction in the context of computer systems?\",options:[\"A method to hide implementation details from users\",\"A higher level only needs to know the interface to the lower level, not how it's implemented\",\"A way to make programs run faster\",\"A technique for optimizing hardware design\"],correct:1,explanation:\"Abstraction means a higher level only needs to know about the interface to the lower level, not how the lower level is implemented.\"},{question:\"Why might you need to understand what happens in underlying abstraction levels?\",options:[\"Only for academic purposes\",\"When programs run slow, consume too much energy, or don't run correctly\",\"To impress colleagues with technical knowledge\",\"It's never necessary in modern computing\"],correct:1,explanation:\"You need to understand underlying levels when programs run slow, consume too much energy, don't run correctly, or when designing more efficient systems.\"},{question:\"What are the two key goals of the computer architecture course mentioned?\",options:[\"Learn programming and hardware design\",\"Understand processor internals and make cross-layer optimization decisions\",\"Master assembly language and digital logic\",\"Study algorithms and data structures\"],correct:1,explanation:\"The two key goals are: understand how a processor works underneath the software layer and how hardware decisions affect software/programmers, and enable making design decisions that cross boundaries of different layers.\"},{question:\"In the multi-core system slowdown example, what causes the disparity in performance between applications?\",options:[\"CPU scheduling policies\",\"Cache miss rates\",\"DRAM controller scheduling unfairness\",\"Network latency\"],correct:2,explanation:\"The disparity is caused by DRAM controller scheduling policies that are unfair to some applications, particularly the row-hit first and oldest-first policies.\"},{question:\"What does a row-conflict memory access result in compared to a row-hit access?\",options:[\"Faster access time\",\"Same access time\",\"Significantly longer access time\",\"Slightly longer access time\"],correct:2,explanation:\"A row-conflict memory access takes significantly longer than a row-hit access.\"},{question:\"What does FR-FCFS stand for in DRAM controller scheduling?\",options:[\"Fast-Ready, First-Come-First-Service\",\"First-Ready, First-Come-First-Service\",\"First-Row, First-Column-First-Service\",\"Fast-Row, First-Cache-First-Service\"],correct:1,explanation:\"FR-FCFS stands for First-Ready, First-Come-First-Service, which prioritizes row-hit accesses first, then older accesses first.\"},{question:\"Which application type does the row-hit first policy unfairly prioritize?\",options:[\"CPU-intensive applications\",\"Applications with high row buffer locality\",\"Applications with random memory access\",\"Applications with low memory usage\"],correct:1,explanation:\"Row-hit first policy unfairly prioritizes applications with high row buffer locality - threads that keep accessing the same row.\"},{question:\"What is the difference between STREAM and RANDOM memory access patterns?\",options:[\"STREAM is faster, RANDOM is slower\",\"STREAM has sequential access with high row buffer locality, RANDOM has random access with low row buffer locality\",\"STREAM uses more memory, RANDOM uses less\",\"STREAM is for reading, RANDOM is for writing\"],correct:1,explanation:\"STREAM has sequential memory access with very high row buffer locality (96% hit rate), while RANDOM has random memory access with very low row buffer locality (3% hit rate).\"},{question:\"What does a DRAM cell consist of?\",options:[\"Two transistors and a resistor\",\"A capacitor and an access transistor\",\"A flip-flop circuit\",\"Multiple logic gates\"],correct:1,explanation:\"A DRAM cell consists of a capacitor and an access transistor. It stores data in terms of charge in the capacitor.\"},{question:\"Why does DRAM need to be refreshed periodically?\",options:[\"To prevent data corruption from electromagnetic interference\",\"Because the capacitor charge leaks over time\",\"To maintain synchronization with the CPU clock\",\"To update the stored data\"],correct:1,explanation:\"DRAM capacitor charge leaks over time, so the memory controller needs to refresh each row periodically to restore charge.\"},{question:\"What is the typical refresh period for DRAM?\",options:[\"64 microseconds\",\"64 milliseconds\",\"64 seconds\",\"64 nanoseconds\"],correct:1,explanation:\"The typical refresh period is 64 ms - each row needs to be activated every 64 milliseconds.\"},{question:\"What are the downsides of DRAM refresh mentioned in the document?\",options:[\"Only energy consumption\",\"Energy consumption, performance degradation, QoS impact, and capacity scaling limits\",\"Only performance degradation\",\"Only capacity limitations\"],correct:1,explanation:\"DRAM refresh downsides include: energy consumption, performance degradation (DRAM unavailable during refresh), QoS/predictability impact (pause times), and refresh rate limits DRAM capacity scaling.\"},{question:\"According to the RAIDR research, what percentage of refresh reduction was achieved?\",options:[\"46.8%\",\"74.6%\",\"15.2%\",\"84.3%\"],correct:1,explanation:\"RAIDR achieved 74.6% refresh reduction with only 1.25KB storage overhead for 32GB memory.\"},{question:\"What is the key observation behind the RAIDR approach?\",options:[\"All DRAM rows need frequent refresh\",\"Most DRAM rows can be refreshed much less often without losing data\",\"DRAM refresh is unnecessary\",\"Refresh frequency should be increased\"],correct:1,explanation:\"RAIDR's key observation is that most DRAM rows can be refreshed much less often without losing data, allowing for different refresh rates for different rows.\"},{question:\"What are the three main steps in the RAIDR approach?\",options:[\"Reading, Writing, Refreshing\",\"Profiling, Binning, Refreshing\",\"Measuring, Sorting, Optimizing\",\"Testing, Grouping, Scheduling\"],correct:1,explanation:\"RAIDR uses three steps: 1) Profiling retention time of all rows, 2) Binning rows by retention time using Bloom Filters, 3) Refreshing rows in different bins at different rates.\"},{question:\"How much storage overhead does RAIDR require for 32GB memory?\",options:[\"1.25MB\",\"1.25KB\",\"12.5KB\",\"125KB\"],correct:1,explanation:\"RAIDR requires only 1.25KB storage for 32GB memory using efficient storage with Bloom Filters.\"},{question:\"What performance improvement did RAIDR achieve?\",options:[\"~5%\",\"~9%\",\"~16%\",\"~20%\"],correct:1,explanation:\"RAIDR achieved approximately 9% performance improvement along with 16%/20% DRAM dynamic/idle power reduction.\"},{question:\"In the memory hog example, what happens when T0 (STREAM) and T1 (RANDOM) compete for memory access?\",options:[\"They get equal access\",\"T1 gets prioritized due to oldest-first policy\",\"128 requests of T0 are serviced before T1 due to row buffer locality\",\"Random scheduling occurs\"],correct:2,explanation:\"Due to row buffer locality, 128 requests of T0 (STREAM) are serviced before T1 (RANDOM) gets access, since T0 keeps hitting the same row while T1 causes row conflicts.\"},{question:\"What is the main takeaway about abstraction layers from this chapter?\",options:[\"Abstraction layers should never be broken\",\"Breaking abstraction layers and knowing what's underneath enables problem solving and better system design\",\"Only hardware designers need to understand multiple layers\",\"Abstraction layers are only important for software development\"],correct:1,explanation:\"The main takeaway is that breaking abstraction layers and knowing what happens underneath enables you to solve problems and design better future systems.\"},{question:\"Which component in a multi-core system is shared among all cores?\",options:[\"L2 Cache\",\"L3 Cache and DRAM Memory Controller\",\"CPU registers\",\"Instruction decoder\"],correct:1,explanation:\"In the multi-core system diagram, the Shared L3 Cache and DRAM Memory Controller are shared among all cores, while each core has its own L2 cache.\"},{question:\"What makes the DRAM controller vulnerable to denial of service attacks?\",options:[\"Poor encryption mechanisms\",\"Unfair scheduling policies that can be exploited by specially written programs\",\"Insufficient bandwidth\",\"Hardware design flaws\"],correct:1,explanation:\"DRAM scheduling policies are unfair to some applications, and programs can be written to exploit this unfairness, making the controller vulnerable to denial of service attacks.\"},{question:\"What is the row size mentioned in the memory hog example?\",options:[\"4KB\",\"8KB\",\"16KB\",\"32KB\"],correct:1,explanation:\"In the memory hog example, the row size is 8KB and cache block size is 64B, resulting in 128 (8KB/64B) requests.\"},{question:\"According to the refresh overhead graphs, what percentage of performance overhead can refresh cause?\",options:[\"Up to 8%\",\"Up to 46%\",\"Up to 15%\",\"Up to 47%\"],correct:1,explanation:\"According to the refresh overhead performance graph, DRAM refresh can cause up to 46% performance overhead.\"},{question:\"What cooperation approach does the chapter suggest for solving complex system problems?\",options:[\"Hardware-only solutions\",\"Software-only solutions\",\"Cooperation between multiple components and layers\",\"Operating system level solutions only\"],correct:2,explanation:\"The chapter emphasizes that cooperation between multiple components and layers can enable more effective solutions and systems.\"},{question:\"In the levels of transformation, what is at the bottom of the hierarchy?\",options:[\"Logic\",\"Circuits\",\"Electrons\",\"Microarchitecture\"],correct:2,explanation:\"In the levels of transformation hierarchy, Electrons is at the bottom, representing the most fundamental physical level.\"},{question:\"What does the course aim to enable students to do regarding design decisions?\",options:[\"Make decisions within single layers only\",\"Focus only on software optimization\",\"Make design and optimization decisions that cross boundaries of different layers\",\"Specialize in one specific layer\"],correct:2,explanation:\"The course aims to enable students to be comfortable making design and optimization decisions that cross the boundaries of different layers and system components.\"},{question:\"What information does RAIDR expose to solve the refresh problem?\",options:[\"CPU utilization patterns\",\"Retention time profile information of DRAM rows\",\"Cache miss rates\",\"Network traffic patterns\"],correct:1,explanation:\"RAIDR exposes retention time profile information of DRAM rows to the memory controller, enabling different refresh rates for different rows based on their retention characteristics.\"},{question:\"What is the relationship between the programmer's view and hardware designer's view in computer systems?\",options:[\"They are completely independent\",\"Only the programmer's view matters\",\"The architect/microarchitect's choices critically affect both views\",\"Only the hardware designer's view is important\"],correct:2,explanation:\"The architect/microarchitect's view involves designing computers that meet system design goals, and these choices critically affect both the software programmer and the hardware designer.\"}],'Chapter 4: Introduction and Basics':[{question:\"According to Richard Hamming, what is the purpose of computing?\",options:[\"To generate numbers and data\",\"To solve mathematical equations\",\"To gain insight, not numbers\",\"To process information quickly\"],correct:2,explanation:\"Richard Hamming stated that 'The purpose of computing is insight, not numbers'. The true value of computing lies not just in generating numbers (data), but in using that data to gain understanding and knowledge (insight).\"},{question:\"What are the levels of transformation in computer systems from top to bottom?\",options:[\"Problem → Algorithm → Program → ISA → Microarchitecture → Logic → Circuits → Electrons\",\"Algorithm → Problem → Program → ISA → Logic → Microarchitecture → Circuits → Electrons\",\"Problem → Program → Algorithm → ISA → Microarchitecture → Logic → Circuits → Electrons\",\"Problem → Algorithm → ISA → Program → Microarchitecture → Logic → Circuits → Electrons\"],correct:0,explanation:\"The correct hierarchy is: Problem → Algorithm → Program/Language → Runtime System → ISA (Architecture) → Microarchitecture → Logic → Circuits → Electrons, representing the transformation from high-level problems to physical implementation.\"},{question:\"What is abstraction in the context of computer systems?\",options:[\"A method to make systems more complex\",\"A higher level only needs to know about the interface to the lower level, not how it's implemented\",\"A way to combine multiple levels into one\",\"A technique to eliminate unnecessary components\"],correct:1,explanation:\"Abstraction means that a higher level only needs to know about the interface to the lower level, not how the lower level is implemented. For example, a high-level language programmer doesn't need to know what the ISA is or how a computer executes instructions.\"},{question:\"Why might you need to understand what happens in underlying abstraction layers?\",options:[\"Only for academic purposes\",\"When programs run slow, incorrectly, or consume too much energy\",\"To make programming more difficult\",\"It's never necessary to understand underlying layers\"],correct:1,explanation:\"Understanding underlying layers becomes crucial when: the program runs slow, doesn't run correctly, consumes too much energy, or when designing more efficient and higher performance systems.\"},{question:\"In the multi-core system memory performance attack example, what causes the disparity in slowdowns between applications?\",options:[\"Different CPU speeds\",\"Cache size differences\",\"DRAM scheduling policy unfairness due to row buffer locality\",\"Operating system scheduling\"],correct:2,explanation:\"The disparity is caused by DRAM scheduling policies being unfair to some applications. Row-hit first policy unfairly prioritizes apps with high row buffer locality, while oldest-first unfairly prioritizes memory-intensive applications.\"},{question:\"What is the FR-FCFS scheduling policy in DRAM controllers?\",options:[\"First-Request, First-Come-First-Service\",\"First-Ready, First-Come-First-Service\",\"First-Row, First-Column-First-Service\",\"Fast-Response, First-Come-First-Service\"],correct:1,explanation:\"FR-FCFS stands for First-Ready, First-Come-First-Service. It has two rules: (1) Row-hit first: Service row-hit memory accesses first, (2) Oldest-first: Then service older accesses first.\"},{question:\"What makes a DRAM row-conflict access significantly slower than a row-hit access?\",options:[\"CPU processing delays\",\"Cache miss penalties\",\"Need to close current row and open new row in DRAM\",\"Network latency\"],correct:2,explanation:\"A row-conflict access requires closing the currently open row and opening a new row in DRAM, which takes significantly longer than accessing data from an already open row (row-hit).\"},{question:\"In the memory performance hog example, what characterizes the STREAM access pattern?\",options:[\"Random memory access with low row buffer locality\",\"Sequential memory access with very high row buffer locality (96% hit rate)\",\"Scattered memory access with medium locality\",\"Circular memory access pattern\"],correct:1,explanation:\"STREAM is characterized by sequential memory access with very high row buffer locality (96% hit rate) and is memory intensive, making it a memory performance hog.\"},{question:\"What characterizes the RANDOM access pattern in the memory performance example?\",options:[\"Sequential access with high locality\",\"Random memory access with very low row buffer locality (3% hit rate)\",\"Structured access with medium locality\",\"Predictable access pattern\"],correct:1,explanation:\"RANDOM is characterized by random memory access with very low row buffer locality (3% hit rate) and is similarly memory intensive compared to STREAM.\"},{question:\"What does a DRAM cell consist of?\",options:[\"Two transistors and a resistor\",\"A capacitor and an access transistor\",\"Three capacitors in series\",\"A flip-flop circuit\"],correct:1,explanation:\"A DRAM cell consists of a capacitor and an access transistor. It stores data in terms of charge in the capacitor.\"},{question:\"Why does DRAM need to be refreshed?\",options:[\"To improve performance\",\"Because capacitor charge leaks over time\",\"To reduce power consumption\",\"To increase storage capacity\"],correct:1,explanation:\"DRAM capacitor charge leaks over time, so the memory controller needs to refresh each row periodically to restore charge. Typically each row must be refreshed every 64ms.\"},{question:\"What are the main downsides of DRAM refresh?\",options:[\"Only increased cost\",\"Only performance degradation\",\"Energy consumption, performance degradation, QoS impact, and capacity scaling limits\",\"Only energy consumption\"],correct:2,explanation:\"DRAM refresh has multiple downsides: energy consumption (each refresh consumes energy), performance degradation (DRAM unavailable while refreshed), QoS/predictability impact (long pause times), and refresh rate limits DRAM capacity scaling.\"},{question:\"What is the typical refresh period for DRAM rows?\",options:[\"64 microseconds\",\"64 milliseconds\",\"64 seconds\",\"64 nanoseconds\"],correct:1,explanation:\"The typical refresh period is 64 milliseconds (64 ms). Each row must be activated (refreshed) every 64 ms to restore the charge in the capacitors.\"},{question:\"What key observation does RAIDR make about DRAM refresh?\",options:[\"All rows need frequent refresh\",\"Most DRAM rows can be refreshed much less often without losing data\",\"Refresh is unnecessary\",\"Only some rows need any refresh\"],correct:1,explanation:\"RAIDR observes that most DRAM rows can be refreshed much less often without losing data, leading to the idea of refreshing rows containing weak cells more frequently and other rows less frequently.\"},{question:\"How does RAIDR achieve refresh reduction?\",options:[\"By eliminating refresh entirely\",\"By profiling retention times, binning rows, and refreshing different bins at different rates\",\"By using different DRAM technology\",\"By increasing refresh frequency for all rows\"],correct:1,explanation:\"RAIDR works in three steps: (1) Profiling retention time of all rows, (2) Binning rows by retention time in memory controller using Bloom Filters, (3) Refreshing rows in different bins at different rates.\"},{question:\"What are the benefits achieved by RAIDR?\",options:[\"Only performance improvement\",\"74.6% refresh reduction, ~16%/20% DRAM power reduction, ~9% performance improvement\",\"Only power reduction\",\"Only refresh reduction\"],correct:1,explanation:\"RAIDR achieves multiple benefits: 74.6% refresh reduction with only 1.25KB storage overhead, ~16%/20% DRAM dynamic/idle power reduction, and ~9% performance improvement, with benefits increasing with DRAM capacity.\"},{question:\"What is one of the two key goals of the computer architecture course mentioned in the lecture?\",options:[\"To learn programming languages\",\"To understand how a processor works underneath the software layer\",\"To design operating systems\",\"To build hardware components\"],correct:1,explanation:\"One key goal is to understand how a processor works underneath the software layer and how decisions made in hardware affect the software/programmer.\"},{question:\"What is the second key goal of the computer architecture course?\",options:[\"To memorize instruction sets\",\"To enable making design and optimization decisions that cross boundaries of different layers\",\"To focus only on hardware design\",\"To specialize in one abstraction layer\"],correct:1,explanation:\"The second key goal is to enable students to be comfortable in making design and optimization decisions that cross the boundaries of different layers and system components.\"},{question:\"In the memory performance hog scenario, approximately how many requests of the STREAM application (T0) are serviced before the RANDOM application (T1) gets served?\",options:[\"64 requests\",\"96 requests\",\"128 requests\",\"256 requests\"],correct:2,explanation:\"With a row size of 8KB and cache block size of 64B, there are 128 (8KB/64B) requests of T0 (STREAM) serviced before T1 (RANDOM) gets a chance, demonstrating the unfairness of the row-hit first policy.\"},{question:\"What is the main takeaway about abstraction layers from this lecture?\",options:[\"Abstraction layers should never be crossed\",\"Breaking abstraction layers and knowing what is underneath enables problem solving\",\"Only hardware designers need to understand multiple layers\",\"Abstraction layers are only theoretical concepts\"],correct:1,explanation:\"The main takeaway is that breaking the abstraction layers (between components and transformation hierarchy levels) and knowing what is underneath enables you to solve problems and design better future systems. Cooperation between multiple components and layers can enable more effective solutions.\"}],'Chapter 5: What is A Computer and Von Neumann Model':[{question:\"What are the three key components that define a computer?\",options:[\"Hardware, software, and users\",\"Computation, communication, and storage (memory)\",\"Input, processing, and output\",\"CPU, RAM, and hard drive\"],correct:1,explanation:\"A computer is defined by three key components: Computation (processing), Communication (I/O), and Storage (memory). These components work together to form a complete computing system.\"},{question:\"What are the two key properties of the Von Neumann model?\",options:[\"Fast processing and large memory\",\"Stored program and sequential instruction processing\",\"Multiple cores and parallel processing\",\"Input/output capabilities and user interface\"],correct:1,explanation:\"The Von Neumann model has two key properties: (1) Stored program - instructions stored in linear memory array with unified memory for instructions and data, (2) Sequential instruction processing - one instruction processed at a time with Program Counter identifying current instruction.\"},{question:\"In the Von Neumann model, what determines whether a stored value is interpreted as an instruction?\",options:[\"The value itself\",\"The memory location\",\"The control signals\",\"The data type\"],correct:2,explanation:\"In the Von Neumann model, the interpretation of a stored value depends on the control signals. The same bit pattern can be interpreted as data or as an instruction depending on how the control unit processes it.\"},{question:\"What is another name for the Von Neumann architecture?\",options:[\"Parallel processing computer\",\"Stored program computer\",\"Data flow computer\",\"Multi-core computer\"],correct:1,explanation:\"The Von Neumann architecture is also called a 'stored program computer' because instructions are stored in memory along with data, rather than being hardwired into the machine.\"},{question:\"In the Von Neumann model, how is the Program Counter (instruction pointer) advanced?\",options:[\"Randomly based on available instructions\",\"Based on data availability\",\"Sequentially except for control transfer instructions\",\"In parallel for multiple instructions\"],correct:2,explanation:\"The Program Counter is advanced sequentially except for control transfer instructions (like jumps, branches, calls). This sequential advancement is a fundamental characteristic of Von Neumann execution.\"},{question:\"In the dataflow model, when is an instruction executed?\",options:[\"When the instruction pointer points to it\",\"When all its operands are ready\",\"In sequential order\",\"When the CPU is idle\"],correct:1,explanation:\"In the dataflow model, an instruction is executed when all its operands are ready (i.e., when all inputs have tokens). There is no instruction pointer - execution is driven by data availability.\"},{question:\"What is the main difference between Von Neumann and dataflow execution models?\",options:[\"Von Neumann uses more memory\",\"Von Neumann is control-driven/sequential, dataflow is data-driven/parallel\",\"Dataflow is slower than Von Neumann\",\"Von Neumann requires special hardware\"],correct:1,explanation:\"Von Neumann model is control-driven with sequential execution (instruction pointer controls order), while dataflow model is data-driven with potentially parallel execution (data availability controls order).\"},{question:\"Which execution model is inherently more parallel?\",options:[\"Von Neumann model\",\"Dataflow model\",\"Both are equally parallel\",\"Neither supports parallelism\"],correct:1,explanation:\"The dataflow model is inherently more parallel because multiple instructions can 'fire' (execute) simultaneously when their operands are ready, unlike Von Neumann's sequential execution model.\"},{question:\"In a dataflow machine, what causes a data flow node to 'fire'?\",options:[\"A clock signal\",\"The instruction pointer\",\"When all its inputs have tokens (are ready)\",\"A random trigger\"],correct:2,explanation:\"A data flow node fires (is fetched and executed) when all its inputs are ready, i.e., when all inputs have tokens. This is the fundamental execution principle of dataflow computing.\"},{question:\"What major instruction set architectures use the Von Neumann model today?\",options:[\"Only x86\",\"x86, ARM, MIPS, SPARC, Alpha, POWER\",\"Only ARM and x86\",\"Only older architectures\"],correct:1,explanation:\"All major instruction set architectures today use the Von Neumann model, including x86, ARM, MIPS, SPARC, Alpha, and POWER architectures.\"},{question:\"At the microarchitecture level, how do modern processors actually execute instructions?\",options:[\"Exactly as specified by Von Neumann model\",\"Very differently from Von Neumann model (pipelined, out-of-order, etc.)\",\"Only in sequential order\",\"Without any optimization\"],correct:1,explanation:\"Modern microarchitectures execute very differently from the Von Neumann model - using pipelined execution, multiple instructions at a time, out-of-order execution, and separate instruction/data caches, but this is not exposed to software.\"},{question:\"What is the key difference between ISA and microarchitecture?\",options:[\"ISA is hardware, microarchitecture is software\",\"ISA is the agreed interface between SW/HW, microarchitecture is the specific implementation\",\"They are the same thing\",\"ISA is old, microarchitecture is new\"],correct:1,explanation:\"ISA is the agreed upon interface between software and hardware (what software writer needs to know), while microarchitecture is the specific implementation of an ISA (not visible to software).\"},{question:\"Using the car analogy, what represents ISA vs. microarchitecture?\",options:[\"Engine vs. wheels\",\"Gas pedal (interface) vs. engine internals (implementation)\",\"Steering wheel vs. brakes\",\"Exterior vs. interior\"],correct:1,explanation:\"The gas pedal represents ISA (interface for 'acceleration' that driver uses), while the internals of the engine represent microarchitecture (how 'acceleration' is actually implemented).\"},{question:\"Which changes faster: ISA or microarchitecture?\",options:[\"ISA changes faster\",\"Microarchitecture changes faster\",\"They change at the same rate\",\"Neither changes\"],correct:1,explanation:\"Microarchitecture usually changes faster than ISA. There are few ISAs (x86, ARM, SPARC, MIPS, Alpha) but many microarchitectures. For example, x86 ISA has many implementations: 286, 386, 486, Pentium, Pentium Pro, Pentium 4, Core, etc.\"},{question:\"What does superscalar processing refer to?\",options:[\"Using multiple CPU cores\",\"A technique to execute multiple instructions in parallel within the same processor core\",\"Increasing clock frequency\",\"Adding more memory\"],correct:1,explanation:\"Superscalar processing is a technique used in modern microprocessor design to increase instruction throughput by executing multiple instructions in parallel within the same processor core, allowing more than one instruction per clock cycle.\"},{question:\"Which of the following is part of the ISA?\",options:[\"Number of ports to the register file\",\"ADD instruction's opcode\",\"Whether machine employs pipelined execution\",\"Number of cycles to execute MUL instruction\"],correct:1,explanation:\"ADD instruction's opcode is part of the ISA as it defines the instruction interface. Number of register file ports, pipelining, and execution cycles are microarchitecture implementation details not visible to software.\"},{question:\"Which of the following is part of microarchitecture?\",options:[\"Number of general purpose registers\",\"Instruction opcodes\",\"Number of ports to the register file\",\"Memory addressing modes\"],correct:2,explanation:\"Number of ports to the register file is a microarchitecture detail (implementation choice for performance). Number of registers, opcodes, and addressing modes are ISA specifications visible to programmers.\"},{question:\"What does ISA specify regarding instructions?\",options:[\"Only the instruction format\",\"Opcodes, addressing modes, data types, instruction types and formats, registers, condition codes\",\"Only the execution time\",\"Only the memory requirements\"],correct:1,explanation:\"ISA specifies comprehensive instruction-related elements: opcodes, addressing modes, data types, instruction types and formats, registers, and condition codes - everything a programmer needs to know to write programs.\"},{question:\"Which of the following are microarchitecture implementation choices?\",options:[\"Virtual memory management\",\"Pipelining, out-of-order execution, caching policies, superscalar processing\",\"Instruction set definition\",\"Memory addressing modes\"],correct:1,explanation:\"Microarchitecture includes implementation choices like pipelining, in-order vs out-of-order execution, memory access scheduling, superscalar processing, caching policies, prefetching, etc. - all done without exposure to software.\"},{question:\"In the out-of-order execution example with instructions (1) mov eax,0 (2) mov edx,1 (3) mov edx,3 (4) inc edx (5) mov ecx,3, what determines the execution order?\",options:[\"The original program order must be maintained\",\"The transistors/hardware decides based on dependencies and available resources\",\"Random selection\",\"Always execute in reverse order\"],correct:1,explanation:\"In out-of-order execution, the transistors (hardware) decide which instructions to execute based on data dependencies and available execution resources, while maintaining the correct program semantics.\"}],'Chapter 6: Introduction to ISA Tradeoffs':[{question:\"What is a design point in computer architecture?\",options:[\"A specific location on the processor chip\",\"A set of design considerations and their importance that leads to tradeoffs\",\"The final stage of processor design\",\"A testing methodology for processors\"],correct:1,explanation:\"A design point is a set of design considerations and their importance that leads to tradeoffs in both ISA and microarchitecture. It's determined by the application space and intended users/market.\"},{question:\"Which of the following are key design considerations mentioned in the lecture?\",options:[\"Only cost and performance\",\"Cost, performance, power consumption, energy consumption, availability, reliability, time to market\",\"Only performance and reliability\",\"Hardware complexity and software compatibility\"],correct:1,explanation:\"The key design considerations include: Cost, Performance, Maximum power consumption, Energy consumption (battery life), Availability, Reliability and Correctness, and Time to Market.\"},{question:\"What determines the design point of a computer system?\",options:[\"The available technology\",\"The manufacturing cost\",\"The 'Problem' space (application space) and intended users/market\",\"Government regulations\"],correct:2,explanation:\"The design point is determined by the 'Problem' space (application space) and the intended users/market, which influences the relative importance of different design considerations.\"},{question:\"What are the two main components of an instruction?\",options:[\"Address and data\",\"Opcode and operands\",\"Source and destination\",\"Input and output\"],correct:1,explanation:\"An instruction consists of: (1) opcode - what the instruction does, and (2) operands - who it is to do it to. This is the basic element of the HW/SW interface.\"},{question:\"What is the concept of 'bit steering' in instruction encoding?\",options:[\"Using bits to control data flow direction\",\"A bit in the instruction determines the interpretation of other bits\",\"Steering bits toward the ALU\",\"Managing bit-level operations\"],correct:1,explanation:\"Bit steering is a concept where a bit in the instruction determines the interpretation of other bits, allowing for more efficient use of the instruction encoding space.\"},{question:\"In a 0-address (stack) machine, how are operations performed?\",options:[\"Using registers only\",\"Operations work on top elements of the stack (push/pop)\",\"Direct memory addressing\",\"Using accumulator register\"],correct:1,explanation:\"In a 0-address stack machine, operations work on the top elements of the stack. Operands are pushed onto the stack, operations are performed on stack top elements, and results are popped off.\"},{question:\"What characterizes a 1-address (accumulator) machine?\",options:[\"All operations use stack\",\"Operations use accumulator register (op ACC, ld A, st A)\",\"Two operands per instruction\",\"Three separate operands\"],correct:1,explanation:\"In a 1-address accumulator machine, operations typically involve the accumulator register (ACC). Instructions like 'op ACC', 'ld A' (load into ACC), 'st A' (store from ACC) are characteristic.\"},{question:\"In a 2-address machine, what happens to one of the operands?\",options:[\"It remains unchanged\",\"One operand is both source and destination (gets clobbered)\",\"It gets copied to memory\",\"It gets pushed to stack\"],correct:1,explanation:\"In a 2-address machine (op S,D), one operand serves as both source and destination, meaning the original value gets overwritten (clobbered) with the operation result.\"},{question:\"What is the main advantage of a 3-address machine?\",options:[\"Smaller instruction size\",\"Source and destination are separate (op S1,S2,D)\",\"Faster execution\",\"Lower power consumption\"],correct:1,explanation:\"In a 3-address machine (op S1,S2,D), the source operands and destination are separate, which means source values are preserved and not clobbered during operations.\"},{question:\"What are the main advantages of stack machines?\",options:[\"Large instruction size and complex logic\",\"Small instruction size, simpler logic, compact code, efficient procedure calls\",\"High flexibility and parallel operations\",\"Complex data type support\"],correct:1,explanation:\"Stack machines have: small instruction size (no operands needed for operate instructions), simpler logic, compact code, and efficient procedure calls (all parameters on stack with no additional cycles for parameter passing).\"},{question:\"What are the main disadvantages of stack machines?\",options:[\"Large code size and slow execution\",\"Computations not easily expressible in postfix notation are difficult; limited flexibility\",\"High power consumption\",\"Complex instruction decoding\"],correct:1,explanation:\"Stack machines have disadvantages: computations not easily expressible with postfix notation are difficult to map, cannot perform operations on many values simultaneously (only top N values), and lack flexibility.\"},{question:\"The PDP-11 is an example of which type of machine?\",options:[\"0-address (stack) machine\",\"1-address (accumulator) machine\",\"2-address machine\",\"3-address machine\"],correct:2,explanation:\"The PDP-11 is a 2-address machine. Its ADD instruction has a 4-bit opcode and 2 6-bit operand specifiers, with limited bits to specify an instruction.\"},{question:\"What is the main disadvantage of the PDP-11's 2-address design?\",options:[\"Too many operands\",\"One source operand is always clobbered with the result\",\"Instructions are too long\",\"Cannot access memory\"],correct:1,explanation:\"In PDP-11's 2-address design, one source operand is always clobbered (overwritten) with the result of the instruction, requiring additional steps to preserve original values when needed.\"},{question:\"What type of machine is the Alpha architecture?\",options:[\"2-address memory/memory machine\",\"Stack machine\",\"3-address load/store machine\",\"1-address accumulator machine\"],correct:2,explanation:\"Alpha is a 3-address load/store machine, meaning it has separate source and destination operands, and memory access is only through explicit load and store instructions.\"},{question:\"What type of machine is x86?\",options:[\"3-address load/store machine\",\"2-address memory/memory machine\",\"Stack machine only\",\"1-address accumulator machine\"],correct:1,explanation:\"x86 is a 2-address memory/memory machine, meaning it can perform operations directly between memory locations and registers, with one operand serving as both source and destination.\"},{question:\"How is a data type defined in ISA context?\",options:[\"Any binary representation\",\"Representation of information for which there are instructions that operate on the representation\",\"Only primitive types like integers\",\"Memory storage format only\"],correct:1,explanation:\"A data type is defined as a representation of information for which there are instructions that operate on that representation. It's not just about storage format, but about having instruction support.\"},{question:\"Which of the following are examples of data types mentioned?\",options:[\"Only integer and floating point\",\"Integer, floating point, character, binary, decimal, BCD, doubly linked list, queue, string, bit vector, stack\",\"Only primitive data types\",\"Only numeric types\"],correct:1,explanation:\"The lecture mentions various data types: Integer, floating point, character, binary, decimal, BCD, doubly linked list, queue, string, bit vector, and stack - ranging from primitive to complex structured types.\"},{question:\"What is an example of a high-level data type instruction from VAX?\",options:[\"ADD and SUB only\",\"INSQUEUE (Insert Queue) and REMQUEUE (Remove Queue) on doubly linked lists\",\"Only load and store\",\"Basic arithmetic operations\"],correct:1,explanation:\"VAX provided high-level instructions like INSQUEUE (Insert Queue) and REMQUEUE (Remove Queue) that operated on doubly linked lists or queues, and FINDFIRST for complex data structure operations.\"},{question:\"What does the 'semantic gap' refer to in computer architecture?\",options:[\"Physical distance between components\",\"The disparity between high-level software concepts and low-level hardware operations\",\"Time delay in instruction execution\",\"Memory access latency\"],correct:1,explanation:\"The semantic gap refers to the disparity between high-level concepts and abstractions used in software programming and the low-level operations and mechanisms implemented in hardware.\"},{question:\"How do Early RISC architectures and Intel 432 differ in terms of semantic gap?\",options:[\"Both have the same approach\",\"Early RISC: only integer data type (large gap); Intel 432: object data type, capability-based (small gap)\",\"Both focus on complex data types\",\"Both use only primitive types\"],correct:1,explanation:\"Early RISC architectures had only integer data types (creating a large semantic gap), while Intel 432 supported object data types and was capability-based (attempting to close the semantic gap with high-level features).\"}],'Chapter 7: ISA Tradeoffs':[// Data Types (Pages 3-5)\n{question:\"Which ISA introduced dedicated instructions for doubly linked list operations like INSQUEUE?\",options:[\"x86\",\"VAX\",\"MIPS\",\"ARM\"],correct:1,explanation:\"VAX had specialized instructions for queue/list operations, reflecting its CISC design philosophy.\"},{question:\"What was the primary data type supported in early RISC architectures?\",options:[\"Floating point\",\"Integer only\",\"Object references\",\"Binary-coded decimal\"],correct:1,explanation:\"Early RISC designs like MIPS supported only integers to maintain simplicity.\"},// Semantic Gap (Pages 5,25)\n{question:\"The Intel 432's object data types illustrate what kind of semantic gap approach?\",options:[\"Maximized gap\",\"Minimized gap\",\"No gap\",\"Variable gap\"],correct:1,explanation:\"Intel 432 aimed to minimize the gap by supporting high-level constructs directly in hardware.\"},// Memory Organization (Pages 6-8)\n{question:\"In a 32-bit addressable system like the first Alpha, how would you add two 32-bit numbers?\",options:[\"Using two 32-bit load/store instructions\",\"With a single 64-bit ADD instruction\",\"Through memory-memory operations\",\"Using bit-addressable operations\"],correct:0,explanation:\"Required multiple operations due to 32-bit addressability constraints.\"},{question:\"Which supercomputer architecture used 64-bit addressability?\",options:[\"Burroughs 1700\",\"Cray-1\",\"Intel 432\",\"VAX-11\"],correct:1,explanation:\"Cray supercomputers pioneered 64-bit addressability for scientific computing.\"},// Endianness (Pages 7-8)\n{question:\"Which architecture uses big-endian byte ordering?\",options:[\"x86\",\"PowerPC\",\"ARM (little-endian mode)\",\"Original PCI bus\"],correct:1,explanation:\"PowerPC and SPARC are notable big-endian architectures.\"},{question:\"In little-endian systems, how is the value 0x12345678 stored at address A?\",options:[\"A:12 A+1:34 A+2:56 A+3:78\",\"A:78 A+1:56 A+2:34 A+3:12\",\"A:56 A+1:78 A+2:12 A+3:34\",\"Split across cache lines\"],correct:1,explanation:\"Little-endian stores least significant byte at lowest address.\"},// Registers (Pages 9-12)\n{question:\"What characteristic of programs justifies having registers in an ISA?\",options:[\"Spatial locality\",\"Data locality (temporal and spatial)\",\"Memory wall effect\",\"Von Neumann bottleneck\"],correct:1,explanation:\"Registers exploit temporal locality (reused data) and spatial locality (nearby data).\"},{question:\"How many general-purpose registers did IA-64 (Itanium) introduce?\",options:[\"8\",\"16\",\"32\",\"128\"],correct:3,explanation:\"IA-64 expanded to 128 registers for explicit parallelism.\"},// Programmer Invisible State (Pages 10-11)\n{question:\"Why can't programmers directly access pipeline registers?\",options:[\"They are protected by the OS\",\"They represent microarchitectural state\",\"They are physically inaccessible\",\"They violate memory protection\"],correct:1,explanation:\"Pipeline registers are part of implementation-specific microarchitecture.\"},// Instruction Classes (Page 13)\n{question:\"Which instruction class changes the sequence of execution?\",options:[\"Operate instructions\",\"Data movement instructions\",\"Control flow instructions\",\"Floating-point instructions\"],correct:2,explanation:\"Control flow instructions (branches/jumps) alter the PC.\"},// Addressing Modes (Pages 14-19)\n{question:\"Which addressing mode combines a base register and index register?\",options:[\"Displacement\",\"Register indirect\",\"Indexed addressing\",\"Memory indirect\"],correct:2,explanation:\"Indexed addressing uses base + index calculation.\"},{question:\"What does 'orthogonal ISA' mean?\",options:[\"Instructions use only right angles\",\"All instructions can use all addressing modes\",\"Fixed 90-degree instruction alignment\",\"Separate integer/floating-point pipelines\"],correct:1,explanation:\"Orthogonality means uniform combination of operations and addressing modes.\"},{question:\"What is a key advantage of variable-length instructions?\",options:[\"Simpler hardware decoding\",\"Better code density\",\"Faster clock speeds\",\"More registers\"],correct:1,explanation:\"Variable-length enables compact encoding (e.g., x86).\"},{question:\"Which field in MIPS I-type instructions holds the immediate value?\",options:[\"rs\",\"rt\",\"opcode\",\"16-bit immediate field\"],correct:3,explanation:\"I-type uses 16-bit immediate for constants/offsets.\"},{question:\"What was a major disadvantage of complex CISC instructions?\",options:[\"Limited compiler optimization opportunities\",\"Too many registers\",\"Fixed-length encoding\",\"Lack of virtual memory support\"],correct:0,explanation:\"Complex instructions created coarse-grained operations that constrained optimizations.\"},{question:\"Which VAX instruction provided array access with bounds checking?\",options:[\"MOV\",\"INDEX\",\"BOUNDS\",\"ARRAY\"],correct:1,explanation:\"VAX INDEX instruction exemplified high-level language support.\"},{question:\"Which characteristic is NOT typical of RISC designs?\",options:[\"Many addressing modes\",\"Uniform decode\",\"Fixed-length instructions\",\"Load/store architecture\"],correct:0,explanation:\"RISC minimizes addressing modes for simplicity.\"},{question:\"What motivated the x86's instruction prefixes?\",options:[\"Backward compatibility\",\"Faster decoding\",\"Fewer registers\",\"Big-endian support\"],correct:0,explanation:\"Prefixes allowed extending the ISA while maintaining compatibility.\"},{question:\"What drove ISA evolution according to the chapter?\",options:[\"Compiler limitations\",\"Memory constraints\",\"Specialization needs\",\"All of the above\"],correct:3,explanation:\"All these factors historically influenced ISA design.\"},{question:\"How many bytes can x86 instruction prefixes occupy?\",options:[\"0\",\"1\",\"Up to 4\",\"Exactly 2\"],correct:2,explanation:\"x86 allows up to four 1-byte prefixes.\"},{question:\"What MIPS instruction format has a 26-bit immediate?\",options:[\"R-type\",\"I-type\",\"J-type\",\"U-type\"],correct:2,explanation:\"J-type (jump) uses 26-bit immediates for address targets.\"}],'Chapter 8: Single-Cycle Microarchitecture':[{question:\"What is the primary purpose of cache memory?\",options:[\"To permanently store all program instructions\",\"To store active/commonly used instructions and speed up processing\",\"To replace the main memory entirely\",\"To store only the results of arithmetic operations\"],correct:1,explanation:\"Cache memory temporarily stores active or frequently used instructions to speed up processing and reduce bottlenecks between RAM and the CPU.\"},{question:\"During the fetch part of the instruction cycle, what is the role of the address bus?\",options:[\"It carries the instruction's opcode to the ALU\",\"It carries the address of the instruction to main memory\",\"It stores the result of the executed instruction\",\"It decodes the instruction for the control unit\"],correct:1,explanation:\"The address bus carries the memory address of the instruction to be fetched from main memory to the CPU.\"},{question:\"Which of the following is a drawback of higher clock speeds in CPUs?\",options:[\"Fewer instructions can be executed per second\",\"The CPU may overheat and require more cooling\",\"Programs run slower due to increased complexity\",\"The data bus width is reduced\"],correct:1,explanation:\"Higher clock speeds increase power consumption and heat generation, potentially causing overheating and requiring additional cooling solutions.\"},{question:\"In a single-cycle microarchitecture, how many clock cycles does each instruction take to execute?\",options:[\"One cycle\",\"Two cycles\",\"Variable cycles depending on the instruction\",\"Six cycles (one per phase)\"],correct:0,explanation:\"In a single-cycle microarchitecture, all phases of an instruction (fetch, decode, execute, etc.) are completed within a single clock cycle.\"},{question:\"What determines the clock cycle time in a single-cycle microarchitecture?\",options:[\"The fastest instruction\",\"The average instruction latency\",\"The slowest instruction\",\"The number of functional units\"],correct:2,explanation:\"The slowest instruction dictates the clock cycle time because all instructions must complete within one cycle.\"}],'Chapter 9: Multi-Cycle and Pipelined Microarchitecture':[{question:\"How does a multi-cycle microarchitecture differ from a single-cycle design?\",options:[\"Instructions always take fewer cycles to complete\",\"Each phase of the instruction cycle may span multiple clock cycles\",\"It eliminates the need for a control unit\",\"It uses a smaller data bus\"],correct:1,explanation:\"In a multi-cycle microarchitecture, each phase (fetch, decode, etc.) can take multiple clock cycles, allowing for shorter cycle times.\"},{question:\"What is a key advantage of multi-cycle machines over single-cycle machines?\",options:[\"The slowest instruction determines the cycle time\",\"Clock cycle time is shorter as it depends on the slowest stage, not instruction\",\"They require no control signals\",\"All instructions execute in parallel\"],correct:1,explanation:\"Multi-cycle machines break instructions into stages, allowing the clock cycle time to be determined by the slowest stage rather than the slowest instruction.\"},{question:\"Which component generates control signals to coordinate the datapath in instruction processing?\",options:[\"ALU\",\"Cache memory\",\"Control logic\",\"Address bus\"],correct:2,explanation:\"The control logic decodes instructions and generates signals to direct the datapath (e.g., ALU, registers) on how to process data.\"},{question:\"What happens to the program counter (PC) during the fetch stage?\",options:[\"It is reset to zero\",\"It is incremented to point to the next instruction\",\"It stores the result of the ALU operation\",\"It holds the opcode for decoding\"],correct:1,explanation:\"After fetching an instruction, the PC is incremented to point to the next instruction in memory.\"},{question:\"Which of the following is true about the execute stage?\",options:[\"It retrieves the instruction from main memory\",\"It decodes the opcode into control signals\",\"It performs the actual operation (e.g., ALU computation)\",\"It stores the result in the instruction register\"],correct:2,explanation:\"The execute stage carries out the operation specified by the instruction, such as arithmetic in the ALU or data transfer.\"}],'Chapter 10: Introduction to Microarchitecture':[{question:\"What is the key characteristic of a single-cycle microarchitecture?\",options:[\"All instructions complete execution in one clock cycle\",\"Instructions are pipelined across multiple cycles\",\"Only arithmetic instructions use a single cycle\",\"Memory access takes variable cycles depending on latency\"],correct:0,explanation:\"In a single-cycle microarchitecture, every instruction (e.g., ALU, load/store) completes all stages (fetch, decode, execute, etc.) within one clock cycle.\"},{question:\"Which component is responsible for holding the current instruction address in the single-cycle datapath?\",options:[\"Register file\",\"Program counter (PC)\",\"ALU\",\"Data memory\"],correct:1,explanation:\"The program counter (PC) stores the address of the current instruction being executed and increments by 4 (for MIPS) after each fetch.\"},{question:\"What is the role of the 'sign-extend' unit in the datapath?\",options:[\"To convert 16-bit immediate values to 32-bit signed values\",\"To perform arithmetic operations\",\"To select between register or immediate operands\",\"To manage memory addresses\"],correct:0,explanation:\"The sign-extend unit expands 16-bit immediate values (e.g., in I-type instructions) to 32 bits while preserving the sign for correct arithmetic operations.\"},{question:\"Which control signal determines whether the ALU uses a register value or an immediate value as its second operand?\",options:[\"RegWrite\",\"ALUSrc\",\"MemtoReg\",\"Branch\"],correct:1,explanation:\"ALUSrc selects between the second register operand (e.g., for R-type) or a sign-extended immediate (e.g., for ADDI/LW/SW).\"},{question:\"What happens during the 'MEM' stage of the LW instruction?\",options:[\"The ALU computes the effective memory address\",\"Data is read from memory and written to a register\",\"The instruction is fetched from memory\",\"The PC is updated\"],correct:1,explanation:\"In the MEM stage, the data memory is accessed using the address computed in EX, and the result is later written back to a register in WB.\"},{question:\"Which instruction type requires the 'RegDst' control signal to select the destination register from bits [15:11]?\",options:[\"I-type (e.g., ADDI)\",\"R-type (e.g., ADD)\",\"Load (e.g., LW)\",\"Store (e.g., SW)\"],correct:1,explanation:\"R-type instructions use bits [15:11] for the destination register (rd), while I-type (e.g., ADDI/LW) use bits [20:16] (rt).\"},{question:\"Why is the single-cycle design inefficient for real-world implementations?\",options:[\"It cannot handle branch instructions\",\"The clock cycle must accommodate the slowest instruction (e.g., LW)\",\"It lacks a register file\",\"Memory accesses are asynchronous\"],correct:1,explanation:\"The clock cycle length is determined by the slowest instruction (e.g., LW, which uses memory access), making faster instructions (e.g., ADD) unnecessarily slow.\"},{question:\"What is the purpose of the 'MemtoReg' multiplexer in the datapath?\",options:[\"To select between ALU result or memory data for register writeback\",\"To choose between register operands\",\"To extend immediate values\",\"To compute branch targets\"],correct:0,explanation:\"MemtoReg selects whether the writeback data comes from the ALU result (e.g., for ADD) or memory (e.g., for LW).\"}]};const quizDataArabic={'الفصل 1: مقدمة':[{question:\"ما هو التمييز الرئيسي بين بنية الكمبيوتر وتنظيم الكمبيوتر؟\",options:[\"البنية تتعامل مع الأجهزة، التنظيم يتعامل مع البرامج\",\"البنية تشير إلى السمات المرئية للمبرمج، التنظيم يشير إلى كيفية تنفيذ الميزات\",\"البنية تتعلق بالأداء، التنظيم يتعلق بالتكلفة\",\"لا يوجد فرق بينهما\"],correct:1,explanation:\"تتضمن البنية مجموعة التعليمات، تمثيل البيانات، آليات الإدخال/الإخراج - ما هو مرئي للمبرمجين. يغطي التنظيم إشارات التحكم، الواجهات، تقنية الذاكرة - تفاصيل التنفيذ.\"},{question:\"أي مما يلي ليس أحد وظائف الكمبيوتر الأربع الأساسية؟\",options:[\"معالجة البيانات\",\"تخزين البيانات\",\"تجميع البيانات\",\"نقل البيانات\"],correct:2,explanation:\"الوظائف الأساسية الأربع هي: معالجة البيانات، تخزين البيانات، نقل البيانات، والتحكم. تجميع البيانات هي عملية برمجية، وليست وظيفة حاسوب أساسية.\"},{question:\"ماذا يحتوي سجل عداد البرنامج (PC)؟\",options:[\"التعليمات الحالية التي يتم تنفيذها\",\"عنوان زوج التعليمات التالي الذي سيتم جلبه\",\"نتيجة آخر عملية حسابية\",\"عنوان الذاكرة الذي يتم الوصول إليه\"],correct:1,explanation:\"يحتوي عداد البرنامج (PC) على عنوان زوج التعليمات التالي الذي سيتم جلبه من الذاكرة.\"},{question:\"في نظام متعدد النواة، ما هو 'النواة'؟\",options:[\"شريحة وحدة المعالجة المركزية بأكملها\",\"وحدة معالجة فردية على شريحة المعالج\",\"ناقل النظام الذي يربط المكونات\",\"هيكل ذاكرة التخزين المؤقت\"],correct:1,explanation:\"النواة هي وحدة معالجة فردية على شريحة المعالج، والتي قد تكون مكافئة في الوظائف لوحدة المعالجة المركزية في نظام أحادي وحدة المعالجة المركزية.\"},{question:\"ما هي العلاقة بين تردد الساعة ووقت دورة الساعة؟\",options:[\"هما نفس الشيء\",\"وقت دورة الساعة = تردد الساعة × 2\",\"وقت دورة الساعة = 1 / تردد الساعة\",\"لا توجد علاقة رياضية\"],correct:2,explanation:\"وقت دورة الساعة هو مقلوب تردد الساعة. على سبيل المثال، ساعة 800 ميجاهرتز لديها وقت دورة يبلغ 1.25 نانو ثانية.\"},{question:\"أي مكون يدير موارد الكمبيوتر وينسق الأداء؟\",options:[\"وحدة المنطق والحساب (ALU)\",\"الذاكرة\",\"وحدة التحكم\",\"السجلات\"],correct:2,explanation:\"تقوم وحدة التحكم بإدارة موارد الكمبيوتر وتنسيق أداء أجزائه الوظيفية استجابةً للتعليمات.\"},{question:\"ما هو الغرض الأساسي من ذاكرة التخزين المؤقت (Cache Memory)؟\",options:[\"لتخزين نظام التشغيل\",\"لعمل نسخة احتياطية من الذاكرة الرئيسية\",\"لتسريع الوصول إلى الذاكرة عن طريق تخزين البيانات التي من المرجح أن تستخدم\",\"للتحكم في عمليات الإدخال/الإخراج\"],correct:2,explanation:\"ذاكرة التخزين المؤقت أصغر وأسرع من الذاكرة الرئيسية، وتستخدم لتسريع الوصول إلى الذاكرة عن طريق وضع البيانات من الذاكرة الرئيسية التي من المرجح أن تستخدم في المستقبل القريب.\"},{question:\"أي سجل يحتوي على تعليمة الرمز التشغيلي (opcode) ذات 8 بت التي يتم تنفيذها؟\",options:[\"عداد البرنامج (PC)\",\"سجل التعليمات (IR)\",\"سجل عنوان الذاكرة (MAR)\",\"المُجمِّع (AC)\"],correct:1,explanation:\"يحتوي سجل التعليمات (IR) على تعليمة الرمز التشغيلي (opcode) ذات 8 بت التي يتم تنفيذها.\"},{question:\"ما هي وظيفة سجل عنوان الذاكرة (MAR)؟\",options:[\"يحتوي على التعليمات التي يتم تنفيذها\",\"يخزن البيانات المؤقتة لعمليات وحدة المنطق والحساب\",\"يحدد العنوان في الذاكرة للكلمة المراد كتابتها أو قراءتها\",\"يتحكم في تسلسل العمليات\"],correct:2,explanation:\"يحدد سجل عنوان الذاكرة (MAR) العنوان في الذاكرة للكلمة المراد كتابتها من أو قراءتها إلى سجل مخزن الذاكرة (MBR).\"},{question:\"في الأنظمة المضمنة، ما الذي يميز 'الأنظمة المضمنة بعمق'؟\",options:[\"إنها تشغل أنظمة تشغيل معقدة\",\"إنها قابلة للبرمجة بعد النشر\",\"إنها مخصصة لمهام محددة مع قيود شديدة على الموارد\",\"إنها تحتوي دائمًا على واجهات مستخدم\"],correct:2,explanation:\"الأنظمة المضمنة بعمق هي أجهزة مخصصة أحادية الغرض ذات قيود شديدة على الموارد من حيث الذاكرة، حجم المعالج، الوقت، واستهلاك الطاقة.\"},{question:\"ما هي المكونات الهيكلية الأربعة الرئيسية للكمبيوتر؟\",options:[\"وحدة المعالجة المركزية، ذاكرة الوصول العشوائي، ذاكرة القراءة فقط، القرص الصلب\",\"وحدة المعالجة المركزية، الذاكرة الرئيسية، الإدخال/الإخراج، التوصيل البيني للنظام\",\"وحدة التحكم، وحدة المنطق والحساب، السجلات، ذاكرة التخزين المؤقت\",\"المعالج، الذاكرة، التخزين، الشبكة\"],correct:1,explanation:\"المكونات الهيكلية الأربعة الرئيسية هي: وحدة المعالجة المركزية (تتحكم في التشغيل ومعالجة البيانات)، الذاكرة الرئيسية (تخزن البيانات)، الإدخال/الإخراج (تنقل البيانات مع البيئة الخارجية)، والتوصيل البيني للنظام (آلية الاتصال).\"},{question:\"ما هو الفرق بين وقت الاستجابة والإنتاجية؟\",options:[\"هما نفس المقياس\",\"وقت الاستجابة هو السرعة، الإنتاجية هي الدقة\",\"وقت الاستجابة هو الوقت لمهمة واحدة، الإنتاجية هي المهام لكل وحدة زمنية\",\"وقت الاستجابة لوحدة المعالجة المركزية، الإنتاجية للذاكرة\"],correct:2,explanation:\"وقت الاستجابة هو الوقت بين بدء وإكمال مهمة، بينما الإنتاجية هي إجمالي كمية المهام المنجزة في فترة زمنية معينة. لا توجد علاقة عامة بين هذه المقاييس.\"},{question:\"ماذا يحتوي سجل مخزن الذاكرة (MBR)؟\",options:[\"عنوان التعليمات التالية\",\"كلمة ستُخزن في الذاكرة أو تُستقبل من الذاكرة/الإدخال والإخراج\",\"التعليمات الحالية التي يتم فك تشفيرها\",\"إشارات التحكم لوحدة المنطق والحساب\"],correct:1,explanation:\"يحتوي سجل مخزن الذاكرة (MBR) على كلمة ستُخزن في الذاكرة أو تُرسل إلى وحدة الإدخال/الإخراج، أو يُستخدم لاستقبال كلمة من الذاكرة أو من وحدة الإدخال/الإخراج.\"},{question:\"أي جيل من نشر إنترنت الأشياء (IoT) يتميز بمليارات الأجهزة المضمنة؟\",options:[\"تكنولوجيا المعلومات (IT)\",\"تكنولوجيا التشغيل (OT)\",\"التكنولوجيا الشخصية\",\"تكنولوجيا المستشعرات/المحركات\"],correct:3,explanation:\"الجيل الرابع، تكنولوجيا المستشعرات/المحركات، يُعتبر عادةً إنترنت الأشياء ويتميز باستخدام مليارات الأجهزة المضمنة باستخدام الاتصال اللاسلكي.\"},{question:\"ما هي الوظيفة الأساسية لسجل مخزن التعليمات (IBR)؟\",options:[\"لتخزين قيمة عداد البرنامج\",\"للاحتفاظ مؤقتًا بالتعليمات اليمنى من الذاكرة\",\"لاحتواء عنوان البيانات في الذاكرة\",\"لتخزين نتيجة العمليات الحسابية\"],correct:1,explanation:\"يُستخدم سجل مخزن التعليمات (IBR) للاحتفاظ مؤقتًا بالتعليمات اليمنى من كلمة في الذاكرة.\"},{question:\"في سياق نقل البيانات، ما الذي يميز الإدخال/الإخراج عن اتصالات البيانات؟\",options:[\"سرعة نقل البيانات\",\"نوع البيانات التي يتم نقلها\",\"المسافة - الإدخال/الإخراج اتصال مباشر، اتصالات البيانات عبر مسافات أطول\",\"متطلبات الأمان\"],correct:2,explanation:\"يحدث الإدخال/الإخراج عندما يتم استقبال البيانات من أو تسليمها إلى جهاز متصل مباشرة بالكمبيوتر، بينما تتضمن اتصالات البيانات نقل البيانات عبر مسافات أطول إلى أو من أجهزة بعيدة.\"},{question:\"ما هو الفرق الرئيسي بين معالجات التطبيقات والمعالجات المخصصة في الأنظمة المضمنة؟\",options:[\"مستويات استهلاك الطاقة\",\"تكلفة التصنيع\",\"معالجات التطبيقات تنفذ أنظمة تشغيل معقدة، المعالجات المخصصة تخدم مهام محددة\",\"اختلافات الحجم المادي\"],correct:2,explanation:\"تُعرف معالجات التطبيقات بقدرتها على تنفيذ أنظمة تشغيل معقدة وهي ذات غرض عام، بينما المعالجات المخصصة مخصصة لمهمة واحدة أو عدد قليل من المهام المحددة.\"},{question:\"أي المكونات توفر الوظائف الأساسية الأربعة للدوائر المتكاملة؟\",options:[\"الترانزستورات، المقاومات، المكثفات، المحاثات\",\"البوابات (المعالجة)، خلايا الذاكرة (التخزين)، المسارات (الحركة)، إشارات التحكم (التحكم)\",\"وحدة المعالجة المركزية، الذاكرة، الإدخال/الإخراج، التوصيل البيني\",\"الأجهزة، البرامج، البرامج الثابتة، البرمجيات الوسيطة\"],correct:1,explanation:\"في الدوائر المتكاملة: توفر البوابات معالجة البيانات، توفر خلايا الذاكرة تخزين البيانات، توفر المسارات نقل البيانات، وتوفر إشارات التحكم وظائف التحكم.\"},{question:\"ما هي الميزة التي تظهرها عائلات Intel x86 و IBM System/370؟\",options:[\"أداء أعلى من المنافسين\",\"تكاليف تصنيع أقل\",\"توافق الكود من خلال بنية أساسية مشتركة\",\"كفاءة أفضل في استهلاك الطاقة\"],correct:2,explanation:\"تتشارك جميع عائلات Intel x86 و IBM System/370 نفس البنية الأساسية، مما يوفر توافق الكود (على الأقل رجوعًا)، حتى لو اختلف التنظيم بين الإصدارات.\"},{question:\"في الأنظمة المضمنة بعمق، ما نوع المعالج الذي يستخدم عادةً؟\",options:[\"المعالج الدقيق (Microprocessor)\",\"المتحكم الدقيق (Microcontroller)\",\"معالج الرسوميات\",\"معالج الإشارة الرقمية\"],correct:1,explanation:\"تستخدم الأنظمة المضمنة بعمق متحكمًا دقيقًا بدلاً من معالج دقيق، وهي غير قابلة للبرمجة بمجرد حرق منطق البرنامج في ذاكرة القراءة فقط، وليس لديها تفاعل مع المستخدم.\"},{question:\"ما هي المكونات الهيكلية الرئيسية لوحدة المعالجة المركزية؟\",options:[\"ذاكرة التخزين المؤقت، السجلات، الناقل، الساعة\",\"وحدة التحكم، وحدة المنطق والحساب، السجلات، التوصيل البيني لوحدة المعالجة المركزية\",\"وحدة الجلب، وحدة فك التشفير، وحدة التنفيذ، وحدة الكتابة الخلفية\",\"ذاكرة التخزين المؤقت L1، ذاكرة التخزين المؤقت L2، ذاكرة التخزين المؤقت L3، واجهة الذاكرة الرئيسية\"],correct:1,explanation:\"المكونات الهيكلية الرئيسية لوحدة المعالجة المركزية هي: وحدة التحكم (تتحكم في تشغيل وحدة المعالجة المركزية)، وحدة المنطق والحساب (تنفذ معالجة البيانات)، السجلات (توفر تخزينًا داخليًا)، والتوصيل البيني لوحدة المعالجة المركزية (يوفر الاتصال بين المكونات).\"},{question:\"ما الذي يميز تفاعل الأنظمة المضمنة مع بيئتها؟\",options:[\"إنها تعمل بشكل مستقل عن العوامل الخارجية\",\"إنها مرتبطة ارتباطًا وثيقًا بقيود الوقت الفعلي\",\"إنها تعالج فقط البيانات المخزنة\",\"إنها تتواصل فقط عبر واجهات الشبكة\"],correct:1,explanation:\"غالبًا ما ترتبط الأنظمة المضمنة ارتباطًا وثيقًا ببيئتها، مما يؤدي إلى قيود الوقت الفعلي التي تفرضها الحاجة إلى التفاعل مع البيئة، مثل السرعات المطلوبة والدقة والتوقيت.\"}],'الفصل 2: بيئة التخزين و RAID':[{question:\"ما هو الفرق الرئيسي بين وحدات الذاكرة وأجهزة التخزين؟\",options:[\"وحدات الذاكرة أرخص من أجهزة التخزين\",\"تستخدم وحدات الذاكرة شرائح أشباه الموصلات بينما تستخدم أجهزة التخزين وسائط مغناطيسية أو بصرية\",\"أجهزة التخزين أسرع من وحدات الذاكرة\",\"وحدات الذاكرة غير متطايرة بينما أجهزة التخزين متطايرة\"],correct:1,explanation:\"يتم تنفيذ وحدات الذاكرة باستخدام شرائح أشباه الموصلات، بينما تستخدم أجهزة التخزين وسائط مغناطيسية أو بصرية. كما أن وحدات الذاكرة تتيح الوصول إلى البيانات بسرعة أعلى من وسائط التخزين.\"},{question:\"أي نوع من الذاكرة متطاير ويتطلب إمدادًا مستمرًا بالطاقة؟\",options:[\"ذاكرة القراءة فقط (ROM)\",\"ذاكرة الوصول العشوائي (RAM)\",\"تخزين القرص الصلب\",\"تخزين القرص المضغوط (CD-ROM)\"],correct:1,explanation:\"ذاكرة الوصول العشوائي (RAM) متطايرة وتتطلب إمدادًا مستمرًا بالطاقة للحفاظ على محتوى خلايا الذاكرة. يتم مسح البيانات عند إيقاف تشغيل طاقة النظام أو انقطاعها.\"},{question:\"ماذا تعني DAS وكيف تتصل بالخوادم؟\",options:[\"Direct Access Storage - تتصل عبر بروتوكولات الشبكة\",\"Distributed Array Storage - تتصل عبر كابلات الألياف البصرية\",\"Direct Attached Storage - تتصل مباشرة عبر محول ناقل المضيف (HBA)\",\"Dynamic Allocation Storage - تتصل عبر USB فقط\"],correct:2,explanation:\"DAS تعني Direct Attached Storage. تتصل مباشرة بخادم عبر محول ناقل المضيف (HBA)، بدون وجود شبكة بين التخزين وخوادم الاستضافة.\"},{question:\"ما هي الميزة الرئيسية لـ DAS على بيئات التخزين الأخرى؟\",options:[\"إمكانية الوصول من أجهزة متعددة\",\"أداء سريع وإعداد بسيط\",\"قدرات مشاركة الشبكة\",\"أقل تكلفة بين جميع options\"],correct:1,explanation:\"توفر DAS أداءً سريعًا وخيارات سعة عالية وإعدادًا بسيطًا كمزاياها الرئيسية.\"},{question:\"ما هو العيب الأساسي لـ DAS؟\",options:[\"أداء بطيء\",\"تكلفة عالية\",\"غير قابل للوصول من أجهزة أخرى وعرضة لفقدان البيانات إذا تعطل الكمبيوتر المتصل\",\"متطلبات إعداد معقدة\"],correct:2,explanation:\"DAS غير قابل للوصول من أجهزة أخرى وعرضة لفقدان البيانات إذا تعطل الكمبيوتر المتصل.\"},{question:\"ماذا تعني SAN وما هي خاصيتها الأساسية؟\",options:[\"Storage Access Network - حل تخزين لاسلكي\",\"System Area Network - يربط الخوادم فقط\",\"Storage Area Networks - شبكة تخزين بيانات مخصصة يمكن الوصول إليها بواسطة خوادم متعددة\",\"Secure Access Network - يوفر تخزينًا مشفرًا\"],correct:2,explanation:\"SAN تعني Storage Area Networks. إنها شبكة تخزين بيانات مخصصة يمكن الوصول إليها بواسطة خوادم متعددة.\"},{question:\"أي بيئة تخزين توفر أسرع أداء؟\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:1,explanation:\"توفر SAN أسرع أداء بين options نظرًا لشبكتها المخصصة المصممة خصيصًا لاتصالات عالية الأداء.\"},{question:\"ما هي البروتوكولات الرئيسية المستخدمة في SAN؟\",options:[\"TCP/IP و HTTP\",\"SCSI و SATA\",\"USB و FireWire\",\"Ethernet و WiFi\"],correct:1,explanation:\"البروتوكولات المستخدمة في SAN هي SCSI و SATA.\"},{question:\"ما هي نقطة الضعف الرئيسية في SAN المذكورة في الوثيقة؟\",options:[\"السرعة وزمن الوصول\",\"الأمان\",\"التكلفة\",\"التعقيد\"],correct:1,explanation:\"وفقًا للوثيقة، ضعف SAN هو الأمان، بينما السرعة وزمن الوصول مدرجة كعيوب.\"},{question:\"ماذا تعني NAS وعلى أي مستوى تعمل؟\",options:[\"Network Access Storage - تعمل على مستوى الكتل\",\"Network Attached Storage - تعمل على مستوى الملفات\",\"Network Array Storage - تعمل على مستوى البتات\",\"Network Administration Storage - تعمل على مستوى النظام\"],correct:1,explanation:\"NAS تعني Network Attached Storage. إنها تخزين بيانات كمبيوتر على مستوى الملفات يتصل بأجهزة أخرى على شبكة TCP/IP.\"},{question:\"أي مكون ليس جزءًا من بنية NAS؟\",options:[\"وحدة الرأس (وحدة المعالجة المركزية، الذاكرة)\",\"بطاقة واجهة الشبكة (NIC)\",\"محول ناقل المضيف (HBA)\",\"نظام تشغيل محسن\"],correct:2,explanation:\"محول ناقل المضيف (HBA) هو مكون من DAS، وليس NAS. تتضمن مكونات NAS وحدة الرأس، بطاقة واجهة الشبكة، نظام تشغيل محسن، بروتوكولات، وبروتوكولات التخزين.\"},{question:\"ماذا تعني RAID؟\",options:[\"مجموعة عشوائية من الأقراص المستقلة\",\"مجموعة زائدة من الأقراص المستقلة\",\"مجموعة موثوقة من الأقراص المتكاملة\",\"وصول سريع للأقراص الداخلية\"],correct:1,explanation:\"RAID تعني Redundant Array of Independent Disks (مجموعة زائدة من الأقراص المستقلة).\"},{question:\"أي وظيفة RAID تكتب كتلًا منطقية متتالية على أقراص فعلية متتالية؟\",options:[\"النسخ المتطابق (Mirroring)\",\"التقسيم (Striping)\",\"حساب التكافؤ (Parity Calculation)\",\"المزامنة (Synchronization)\"],correct:1,explanation:\"التقسيم (Striping) يكتب بايتات/كتل منطقية متتالية على أقراص فعلية متتالية.\"},{question:\"أي مستوى RAID يوفر التقسيم بدون تكافؤ أو تكرار؟\",options:[\"RAID 1\",\"RAID 0\",\"RAID 5\",\"RAID 10\"],correct:1,explanation:\"RAID 0 يوفر التقسيم بدون تكافؤ، مما يوفر أداءً ممتازًا ولكن بدون تكرار.\"},{question:\"ما هو الحد الأدنى لعدد الأقراص المطلوبة لـ RAID 1؟\",options:[\"قرص واحد\",\"قرصان\",\"3 أقراص\",\"4 أقراص\"],correct:1,explanation:\"يتطلب RAID 1 قرصين على الأقل ويوفر تكرارًا ممتازًا حيث يتم نسخ الكتل.\"},{question:\"أي مستوى RAID يوصف بأنه 'شريط من المرايا'؟\",options:[\"RAID 0+1\",\"RAID 5\",\"RAID 10\",\"RAID 6\"],correct:2,explanation:\"يُسمى RAID 10 أيضًا 'شريط من المرايا' ويتطلب قرصين على الأقل.\"},{question:\"ما هو الحد الأدنى لعدد الأقراص المطلوبة لـ RAID 5؟\",options:[\"قرصان\",\"3 أقراص\",\"4 أقراص\",\"5 أقراص\"],correct:1,explanation:\"يتطلب RAID 5 ثلاثة أقراص على الأقل ويوفر أداءً جيدًا مع تكافؤ موزع.\"},{question:\"أي مستوى RAID يستخدم تقسيمًا على مستوى البايت؟\",options:[\"RAID 3\",\"RAID 4\",\"RAID 5\",\"RAID 6\"],correct:0,explanation:\"RAID 3 يستخدم تقسيمًا على مستوى البايت، بينما RAID 4 يستخدم تقسيمًا على مستوى الكتل.\"},{question:\"ما الذي يميز RAID 6 عن RAID 5؟\",options:[\"يستخدم التقسيم بدلاً من النسخ المتطابق\",\"يحتوي على كتل تكافؤ مزدوجة ويتطلب 6 أقراص\",\"يوفر أداءً أفضل\",\"يستخدم عددًا أقل من الأقراص\"],correct:1,explanation:\"RAID 6 مشابه لـ RAID 5 باستثناء أنه يحتوي على كتل تكافؤ مزدوجة ويتطلب 6 أقراص.\"},{question:\"أي مستوى RAID موصى به لقواعد البيانات الموجهة للقراءة بكثافة؟\",options:[\"RAID 0\",\"RAID 1\",\"RAID 5\",\"RAID 10\"],correct:2,explanation:\"RAID 5 هو الخيار الأفضل من حيث التكلفة الذي يوفر الأداء والتكرار، ويوصى به لقواعد البيانات الموجهة للقراءة بكثافة، على الرغم من أن عمليات الكتابة ستكون بطيئة.\"},{question:\"أي مستوى RAID يعتبر الخيار الأفضل للتطبيقات ذات الأهمية القصوى؟\",options:[\"RAID 0\",\"RAID 5\",\"RAID 6\",\"RAID 10\"],correct:3,explanation:\"يوفر RAID 10 تكرارًا ممتازًا وأداءً ممتازًا. إذا كنت تستطيع تحمل التكلفة، فهذا هو الخيار الأفضل لأي تطبيقات ذات أهمية قصوى، خاصة قواعد البيانات.\"},{question:\"أي بيئة تخزين ستكون الأفضل لمستخدم واحد يخزن ملفات شخصية؟\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:0,explanation:\"DAS هو الأفضل لمحطات العمل الفردية وتخزين البيانات الشخصية نظرًا لأدائه السريع وإعداداته البسيطة.\"},{question:\"أي بيئة تخزين هي الأنسب للشركات الصغيرة التي لديها عدة موظفين يشاركون الملفات؟\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:2,explanation:\"NAS هو الأفضل للشركات الصغيرة ومجموعات العمل لأنه يوفر تخزينًا مشتركًا يمكن الوصول إليه من أجهزة متعددة على الشبكة.\"},{question:\"أي بيئة تخزين تتطلب أكبر قدر من الخبرة التقنية لإدارتها؟\",options:[\"DAS\",\"SAN\",\"NAS\",\"RAID\"],correct:1,explanation:\"تتطلب SAN خبرة تقنية كبيرة لإدارتها نظرًا لأجهزتها المتخصصة وتكوينها المعقد.\"},{question:\"من حيث ترتيب التكلفة من الأقل إلى الأعلى، ما هو الترتيب correct؟\",options:[\"SAN, NAS, DAS\",\"DAS, NAS, SAN\",\"NAS, DAS, SAN\",\"DAS, SAN, NAS\"],correct:1,explanation:\"DAS هو الأرخص بشكل عام، يليه NAS، ثم SAN هو الأغلى نظرًا لأجهزته المتخصصة وتكوينه.\"},{question:\"أي عبارة عن RAID صحيحة؟\",options:[\"RAID يضمن حماية كاملة للبيانات ضد أي فشل\",\"جميع مستويات RAID توفر نفس مستوى الأداء والتكرار\",\"يمكن تنفيذ RAID على كل من أنظمة DAS و NAS\",\"استخدام RAID يلغي الحاجة إلى النسخ الاحتياطي\"],correct:2,explanation:\"يمكن تنفيذ RAID على كل من أنظمة DAS و NAS للحصول على فوائد إضافية. لا يضمن RAID حماية كاملة، وتختلف المستويات في الأداء/التكرار، ولا يزال هناك حاجة للنسخ الاحتياطي.\"},{question:\"ما نوع الوصول إلى البيانات الذي توفره SAN؟\",options:[\"وصول البيانات على مستوى الملفات\",\"تخزين البيانات على مستوى الكتل\",\"وصول البيانات على مستوى البايت\",\"وصول البيانات على مستوى التطبيق\"],correct:1,explanation:\"توفر SAN تخزين البيانات على مستوى الكتل، مما يسمح لعدة عملاء بالوصول إلى الملفات في نفس الوقت بأداء عالٍ جدًا.\"},{question:\"أي فائدة ليست مرتبطة بـ NAS؟\",options:[\"غير مكلفة نسبيًا\",\"توفر البيانات على مدار الساعة طوال أيام الأسبوع وعن بعد\",\"أسرع أداء بين خيارات التخزين\",\"النسخ الاحتياطي التلقائي إلى أجهزة أخرى والسحابة\"],correct:2,explanation:\"أداء NAS أبطأ مقارنة بـ DAS بسبب الحمل الزائد للشبكة. أسرع أداء توفره SAN.\"},{question:\"ماذا يحدث لبيانات RAM عند انقطاع الطاقة؟\",options:[\"يتم نسخ البيانات احتياطيًا تلقائيًا\",\"تبقى البيانات سليمة\",\"يتم مسح البيانات\",\"يتم نقل البيانات إلى ROM\"],correct:2,explanation:\"ذاكرة الوصول العشوائي (RAM) متطايرة وتتطلب إمدادًا مستمرًا بالطاقة. يتم مسح البيانات عند إيقاف تشغيل طاقة النظام أو انقطاعها.\"},{question:\"أي مستوى RAID يجب ألا يستخدم للأنظمة الحيوية؟\",options:[\"RAID 0\",\"RAID 1\",\"RAID 5\",\"RAID 10\"],correct:0,explanation:\"RAID 0 لا يحتوي على تكرار (لا يوجد نسخة متطابقة، لا يوجد تكافؤ)، لذلك لا ينبغي استخدامه لأي نظام حيوي على الرغم من أدائه الممتاز.\"}],'الفصل 3: مقدمة وهياكل الكمبيوتر الأساسية':[{question:\"ما هو الغرض الأساسي من الحوسبة وفقًا لريتشارد هامينغ؟\",options:[\"توليد الأرقام والبيانات\",\"توفير الرؤية، وليس مجرد أرقام\",\"تنفيذ التعليمات بكفاءة\",\"حل المعادلات الرياضية\"],correct:1,explanation:\"وفقًا لريتشارد هامينغ، 'الغرض من الحوسبة هو الرؤية، وليس الأرقام.' القيمة الحقيقية للحوسبة تكمن في استخدام البيانات لاكتساب الفهم والمعرفة (الرؤية).\"},{question:\"أي مستوى تحويل يقع مباشرة فوق المنطق في التسلسل الهرمي؟\",options:[\"الدوائر\",\"البنية الدقيقة\",\"ISA (البنية)\",\"نظام وقت التشغيل\"],correct:1,explanation:\"في مستويات التسلسل الهرمي للتحويل، تقع البنية الدقيقة مباشرة فوق المنطق، والذي يقع فوق الدوائر.\"},{question:\"ما هو التجريد في سياق أنظمة الكمبيوتر؟\",options:[\"طريقة لإخفاء تفاصيل التنفيذ عن المستخدمين\",\"مستوى أعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذها\",\"طريقة لجعل البرامج تعمل بشكل أسرع\",\"تقنية لتحسين تصميم الأجهزة\"],correct:1,explanation:\"يعني التجريد أن المستوى الأعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذ المستوى الأدنى.\"},{question:\"لماذا قد تحتاج إلى فهم ما يحدث في مستويات التجريد الأساسية؟\",options:[\"لأغراض أكاديمية فقط\",\"عندما تعمل البرامج ببطء، تستهلك الكثير من الطاقة، أو لا تعمل بشكل صحيح\",\"لإبهار الزملاء بالمعرفة التقنية\",\"ليس ضروريًا أبدًا في الحوسبة الحديثة\"],correct:1,explanation:\"تحتاج إلى فهم المستويات الأساسية عندما تعمل البرامج ببطء، تستهلك الكثير من الطاقة، لا تعمل بشكل صحيح، أو عند تصميم أنظمة أكثر كفاءة.\"},{question:\"ما هما الهدفان الرئيسيان لدورة هندسة الكمبيوتر المذكورة؟\",options:[\"تعلم البرمجة وتصميم الأجهزة\",\"فهم المكونات الداخلية للمعالج واتخاذ قرارات تحسين عبر الطبقات\",\"إتقان لغة التجميع والمنطق الرقمي\",\"دراسة الخوارزميات وهياكل البيانات\"],correct:1,explanation:\"الهدفان الرئيسيان هما: فهم كيفية عمل المعالج تحت طبقة البرامج وكيف تؤثر قرارات الأجهزة على البرامج/المبرمجين، والتمكين من اتخاذ قرارات التصميم التي تتجاوز حدود الطبقات المختلفة.\"},{question:\"في مثال تباطؤ النظام متعدد النواة، ما الذي يسبب التفاوت في الأداء بين التطبيقات؟\",options:[\"سياسات جدولة وحدة المعالجة المركزية\",\"معدلات فشل ذاكرة التخزين المؤقت\",\"عدم عدالة جدولة متحكم DRAM\",\"زمن انتقال الشبكة\"],correct:2,explanation:\"ينجم التفاوت عن سياسات جدولة متحكم DRAM التي تكون غير عادلة لبعض التطبيقات، ولا سيما سياسات 'أول صف إصابة' و 'أقدم أولاً'.\"},{question:\"ماذا يترتب على الوصول إلى الذاكرة المتعارض مع الصف مقارنة بالوصول إلى الصف المصاب؟\",options:[\"وقت وصول أسرع\",\"نفس وقت الوصول\",\"وقت وصول أطول بكثير\",\"وقت وصول أطول قليلاً\"],correct:2,explanation:\"يستغرق الوصول إلى الذاكرة المتعارض مع الصف وقتًا أطول بكثير من الوصول إلى الصف المصاب.\"},{question:\"ماذا تعني FR-FCFS في جدولة متحكم DRAM؟\",options:[\"Fast-Ready, First-Come-First-Service\",\"First-Ready, First-Come-First-Service\",\"First-Row, First-Column-First-Service\",\"Fast-Row, First-Cache-First-Service\"],correct:1,explanation:\"FR-FCFS تعني First-Ready, First-Come-First-Service، والتي تعطي الأولوية لعمليات الوصول إلى الصفوف المصابة أولاً، ثم لعمليات الوصول الأقدم أولاً.\"},{question:\"أي نوع من التطبيقات تعطي سياسة 'أول صف إصابة' أولوية غير عادلة؟\",options:[\"التطبيقات كثيفة استخدام وحدة المعالجة المركزية\",\"التطبيقات ذات التموضع العالي لمخزن الصفوف\",\"التطبيقات ذات الوصول العشوائي للذاكرة\",\"التطبيقات ذات الاستخدام المنخفض للذاكرة\"],correct:1,explanation:\"تعطي سياسة 'أول صف إصابة' أولوية غير عادلة للتطبيقات ذات التموضع العالي لمخزن الصفوف - الخيوط التي تستمر في الوصول إلى نفس الصف.\"},{question:\"ما الفرق بين أنماط الوصول إلى الذاكرة STREAM و RANDOM؟\",options:[\"STREAM أسرع، RANDOM أبطأ\",\"STREAM لديه وصول تسلسلي بتموضع عالٍ لمخزن الصفوف، RANDOM لديه وصول عشوائي بتموضع منخفض لمخزن الصفوف\",\"STREAM يستخدم ذاكرة أكبر، RANDOM يستخدم ذاكرة أقل\",\"STREAM للقراءة، RANDOM للكتابة\"],correct:1,explanation:\"لدى STREAM وصول تسلسلي إلى الذاكرة بتموضع عالٍ جدًا لمخزن الصفوف (معدل إصابة 96%)، بينما لدى RANDOM وصول عشوائي إلى الذاكرة بتموضع منخفض جدًا لمخزن الصفوف (معدل إصابة 3%).\"},{question:\"ما الذي تتكون منه خلية DRAM؟\",options:[\"ترانزستوران ومقاوم\",\"مكثف وترانزستور وصول\",\"دائرة قلب (Flip-flop)\",\"بوابات منطقية متعددة\"],correct:1,explanation:\"تتكون خلية DRAM من مكثف وترانزستور وصول. تخزن البيانات من حيث الشحنة في المكثف.\"},{question:\"لماذا تحتاج DRAM إلى التحديث بشكل دوري؟\",options:[\"لمنع تلف البيانات من التداخل الكهرومغناطيسي\",\"لأن شحنة المكثف تتسرب بمرور الوقت\",\"للحفاظ على التزامن مع ساعة وحدة المعالجة المركزية\",\"لتحديث البيانات المخزنة\"],correct:1,explanation:\"تتسرب شحنة مكثف DRAM بمرور الوقت، لذا يحتاج متحكم الذاكرة إلى تحديث كل صف بشكل دوري لاستعادة الشحنة.\"},{question:\"ما هي الفترة الزمنية النموذجية لتحديث DRAM؟\",options:[\"64 ميكروثانية\",\"64 مللي ثانية\",\"64 ثانية\",\"64 نانوثانية\"],correct:1,explanation:\"الفترة الزمنية النموذجية للتحديث هي 64 مللي ثانية - كل صف يحتاج إلى التنشيط كل 64 مللي ثانية.\"},{question:\"ما هي عيوب تحديث DRAM المذكورة في الوثيقة؟\",options:[\"استهلاك الطاقة فقط\",\"استهلاك الطاقة، تدهور الأداء، تأثير جودة الخدمة، وقيود توسيع السعة\",\"تدهور الأداء فقط\",\"قيود السعة فقط\"],correct:1,explanation:\"عيوب تحديث DRAM تشمل: استهلاك الطاقة، تدهور الأداء (DRAM غير متاحة أثناء التحديث)، تأثير جودة الخدمة/القدرة على التنبؤ (أوقات توقف)، ومعدل التحديث يحد من توسيع سعة DRAM.\"},{question:\"وفقًا لبحث RAIDR، ما هي نسبة تقليل التحديث التي تم تحقيقها؟\",options:[\"46.8%\",\"74.6%\",\"15.2%\",\"84.3%\"],correct:1,explanation:\"حقق RAIDR تقليلًا للتحديث بنسبة 74.6% مع حمل تخزين إضافي يبلغ 1.25 كيلوبايت فقط لذاكرة 32 جيجابايت.\"},{question:\"ما هي الملاحظة الرئيسية وراء نهج RAIDR؟\",options:[\"جميع صفوف DRAM تحتاج إلى تحديث متكرر\",\"يمكن تحديث معظم صفوف DRAM بشكل أقل تكرارًا دون فقدان البيانات\",\"تحديث DRAM غير ضروري\",\"يجب زيادة تردد التحديث\"],correct:1,explanation:\"الملاحظة الرئيسية لـ RAIDR هي أن معظم صفوف DRAM يمكن تحديثها بشكل أقل تكرارًا دون فقدان البيانات، مما يسمح بمعدلات تحديث مختلفة لصفوف مختلفة.\"},{question:\"ما هي الخطوات الرئيسية الثلاث في نهج RAIDR؟\",options:[\"القراءة، الكتابة، التحديث\",\"التنميط، التجميع، التحديث\",\"القياس، الفرز، التحسين\",\"الاختبار، التجميع، الجدولة\"],correct:1,explanation:\"يستخدم RAIDR ثلاث خطوات: 1) تنميط وقت الاحتفاظ بجميع الصفوف، 2) تجميع الصفوف حسب وقت الاحتفاظ باستخدام فلاتر بلوم، 3) تحديث الصفوف في سلال مختلفة بمعدلات مختلفة.\"},{question:\"ما هو الحمل التخزيني الإضافي الذي يتطلبه RAIDR لذاكرة 32 جيجابايت؟\",options:[\"1.25 ميجابايت\",\"1.25 كيلوبايت\",\"12.5 كيلوبايت\",\"125 كيلوبايت\"],correct:1,explanation:\"يتطلب RAIDR 1.25 كيلوبايت فقط من التخزين لذاكرة 32 جيجابايت باستخدام تخزين فعال مع فلاتر بلوم.\"},{question:\"ما هو تحسين الأداء الذي حققه RAIDR؟\",options:[\"~5%\",\"~9%\",\"~16%\",\"~20%\"],correct:1,explanation:\"حقق RAIDR تحسينًا في الأداء بنسبة 9% تقريبًا إلى جانب تقليل طاقة DRAM الديناميكية/الخاملة بنسبة 16%/20%.\"},{question:\"في مثال استهلاك الذاكرة، ماذا يحدث عندما تتنافس T0 (STREAM) و T1 (RANDOM) على الوصول إلى الذاكرة؟\",options:[\"يحصلان على وصول متساوٍ\",\"يتم إعطاء الأولوية لـ T1 بسبب سياسة 'الأقدم أولاً'\",\"يتم خدمة 128 طلبًا من T0 قبل T1 بسبب تموضع مخزن الصفوف\",\"تحدث جدولة عشوائية\"],correct:2,explanation:\"نظرًا لتموضع مخزن الصفوف، يتم خدمة 128 طلبًا من T0 (STREAM) قبل أن تحصل T1 (RANDOM) على الوصول، حيث تستمر T0 في إصابة نفس الصف بينما تسبب T1 تعارضات في الصفوف.\"},{question:\"ما هي الفكرة الرئيسية حول طبقات التجريد من هذا الفصل؟\",options:[\"يجب عدم كسر طبقات التجريد أبدًا\",\"كسر طبقات التجريد ومعرفة ما هو تحتها يمكّن من حل المشكلات وتصميم نظام أفضل\",\"مصممو الأجهزة فقط هم من يحتاجون إلى فهم طبقات متعددة\",\"طبقات التجريد مهمة فقط لتطوير البرامج\"],correct:1,explanation:\"الفكرة الرئيسية هي أن كسر طبقات التجريد ومعرفة ما يحدث تحتها يمكّنك من حل المشكلات وتصميم أنظمة مستقبلية أفضل.\"},{question:\"أي مكون في نظام متعدد النواة مشترك بين جميع النوى؟\",options:[\"ذاكرة التخزين المؤقت L2\",\"ذاكرة التخزين المؤقت L3 ومتحكم ذاكرة DRAM\",\"سجلات وحدة المعالجة المركزية\",\"فك تشفير التعليمات\"],correct:1,explanation:\"في مخطط النظام متعدد النوى، ذاكرة التخزين المؤقت L3 المشتركة ومتحكم ذاكرة DRAM مشتركة بين جميع النوى، بينما كل نواة لديها ذاكرة التخزين المؤقت L2 الخاصة بها.\"},{question:\"ما الذي يجعل متحكم DRAM عرضة لهجمات حجب الخدمة (Denial of Service)؟\",options:[\"آليات التشفير الضعيفة\",\"سياسات الجدولة غير العادلة التي يمكن استغلالها بواسطة برامج مكتوبة خصيصًا\",\"عرض النطاق الترددي غير الكافي\",\"عيوب في تصميم الأجهزة\"],correct:1,explanation:\"سياسات جدولة DRAM غير عادلة لبعض التطبيقات، ويمكن كتابة البرامج لاستغلال هذا الظلم، مما يجعل المتحكم عرضة لهجمات حجب الخدمة.\"},{question:\"ما هو حجم الصف المذكور في مثال استهلاك الذاكرة؟\",options:[\"4 كيلوبايت\",\"8 كيلوبايت\",\"16 كيلوبايت\",\"32 كيلوبايت\"],correct:1,explanation:\"في مثال استهلاك الذاكرة، حجم الصف هو 8 كيلوبايت وحجم كتلة ذاكرة التخزين المؤقت هو 64 بايت، مما يؤدي إلى 128 (8 كيلوبايت/64 بايت) طلبًا.\"},{question:\"وفقًا لرسوم بيانية حمل التحديث الزائد، ما هي نسبة حمل الأداء الزائد التي يمكن أن يسببها التحديث؟\",options:[\"حتى 8%\",\"حتى 46%\",\"حتى 15%\",\"حتى 47%\"],correct:1,explanation:\"وفقًا لرسوم بيانية أداء حمل التحديث الزائد، يمكن أن يسبب تحديث DRAM حمل أداء زائد يصل إلى 46%.\"},{question:\"أي نهج تعاوني يقترحه الفصل لحل مشاكل الأنظمة المعقدة؟\",options:[\"حلول الأجهزة فقط\",\"حلول البرامج فقط\",\"التعاون بين مكونات وطبقات متعددة\",\"حلول على مستوى نظام التشغيل فقط\"],correct:2,explanation:\"يؤكد الفصل أن التعاون بين مكونات وطبقات متعددة يمكن أن يتيح حلولًا وأنظمة أكثر فعالية.\"},{question:\"في مستويات التحويل، ما الذي يقع في أسفل التسلسل الهرمي؟\",options:[\"المنطق\",\"الدوائر\",\"الإلكترونات\",\"البنية الدقيقة\"],correct:2,explanation:\"في مستويات التسلسل الهرمي للتحويل، تقع الإلكترونات في الأسفل، مما يمثل المستوى المادي الأساسي.\"},{question:\"ما الذي تهدف الدورة إلى تمكين الطلاب من فعله فيما يتعلق بقرارات التصميم؟\",options:[\"اتخاذ القرارات ضمن طبقات فردية فقط\",\"التركيز فقط على تحسين البرامج\",\"اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات المختلفة\",\"التخصص في طبقة واحدة محددة\"],correct:2,explanation:\"تهدف الدورة إلى تمكين الطلاب من الشعور بالراحة في اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات والمكونات المختلفة للنظام.\"},{question:\"ما هي المعلومات التي يكشفها RAIDR لحل مشكلة التحديث؟\",options:[\"أنماط استخدام وحدة المعالجة المركزية\",\"معلومات ملف وقت الاحتفاظ بصفوف DRAM\",\"معدلات فشل ذاكرة التخزين المؤقت\",\"أنماط حركة مرور الشبكة\"],correct:1,explanation:\"يكشف RAIDR معلومات ملف وقت الاحتفاظ بصفوف DRAM إلى متحكم الذاكرة، مما يتيح معدلات تحديث مختلفة لصفوف مختلفة بناءً على خصائص الاحتفاظ بها.\"},{question:\"ما هي العلاقة بين رؤية المبرمج ورؤية مصمم الأجهزة في أنظمة الكمبيوتر؟\",options:[\"هما مستقلان تمامًا\",\"رؤية المبرمج فقط هي المهمة\",\"اختيارات المهندس المعماري/المعماري الدقيق تؤثر بشكل حاسم على كلتا الرؤيتين\",\"رؤية مصمم الأجهزة فقط هي المهمة\"],correct:2,explanation:\"تتضمن رؤية المهندس المعماري/المعماري الدقيق تصميم أجهزة كمبيوتر تلبي أهداف تصميم النظام، وتؤثر هذه الاختيارات بشكل حاسم على كل من مبرمج البرامج ومصمم الأجهزة.\"}],'الفصل 4: مقدمة وأساسيات':[{question:\"وفقًا لريتشارد هامينغ، ما هو الغرض من الحوسبة؟\",options:[\"لتوليد الأرقام والبيانات\",\"لحل المعادلات الرياضية\",\"لاكتساب البصيرة، وليس الأرقام\",\"لمعالجة المعلومات بسرعة\"],correct:2,explanation:\"صرح ريتشارد هامينغ بأن 'الغرض من الحوسبة هو البصيرة، وليس الأرقام'. القيمة الحقيقية للحوسبة لا تكمن فقط في توليد الأرقام (البيانات)، بل في استخدام تلك البيانات لاكتساب الفهم والمعرفة (البصيرة).\"},{question:\"ما هي مستويات التحويل في أنظمة الكمبيوتر من الأعلى إلى الأسفل؟\",options:[\"المشكلة ← الخوارزمية ← البرنامج ← ISA ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات\",\"الخوارزمية ← المشكلة ← البرنامج ← ISA ← المنطق ← البنية الدقيقة ← الدوائر ← الإلكترونات\",\"المشكلة ← البرنامج ← الخوارزمية ← ISA ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات\",\"المشكلة ← الخوارزمية ← ISA ← البرنامج ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات\"],correct:0,explanation:\"التسلسل الهرمي correct هو: المشكلة ← الخوارزمية ← البرنامج/اللغة ← نظام وقت التشغيل ← ISA (البنية) ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات، ويمثل التحويل من المشكلات عالية المستوى إلى التنفيذ المادي.\"},{question:\"ما هو التجريد في سياق أنظمة الكمبيوتر؟\",options:[\"طريقة لجعل الأنظمة أكثر تعقيدًا\",\"مستوى أعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذها\",\"طريقة لدمج مستويات متعددة في مستوى واحد\",\"تقنية للتخلص من المكونات غير الضرورية\"],correct:1,explanation:\"يعني التجريد أن المستوى الأعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذ المستوى الأدنى. على سبيل المثال، لا يحتاج مبرمج لغة عالية المستوى إلى معرفة ما هو ISA أو كيفية تنفيذ الكمبيوتر للتعليمات.\"},{question:\"لماذا قد تحتاج إلى فهم ما يحدث في طبقات التجريد الأساسية؟\",options:[\"لأغراض أكاديمية فقط\",\"عندما تعمل البرامج ببطء، بشكل غير صحيح، أو تستهلك الكثير من الطاقة\",\"لجعل البرمجة أكثر صعوبة\",\"ليس من الضروري أبدًا فهم الطبقات الأساسية\"],correct:1,explanation:\"يصبح فهم الطبقات الأساسية أمرًا حاسمًا عندما: يعمل البرنامج ببطء، لا يعمل بشكل صحيح، يستهلك الكثير من الطاقة، أو عند تصميم أنظمة أكثر كفاءة وأداءً أعلى.\"},{question:\"في مثال هجوم أداء الذاكرة في النظام متعدد النواة، ما الذي يسبب التفاوت في التباطؤ بين التطبيقات؟\",options:[\"سرعات وحدة المعالجة المركزية المختلفة\",\"اختلافات حجم ذاكرة التخزين المؤقت\",\"عدم عدالة سياسة جدولة DRAM بسبب تموضع مخزن الصفوف\",\"جدولة نظام التشغيل\"],correct:2,explanation:\"ينجم التفاوت عن سياسات جدولة DRAM التي تكون غير عادلة لبعض التطبيقات. سياسة 'أول صف إصابة' تعطي أولوية غير عادلة للتطبيقات ذات التموضع العالي لمخزن الصفوف، بينما سياسة 'الأقدم أولاً' تعطي أولوية غير عادلة للتطبيقات كثيفة الذاكرة.\"},{question:\"ما هي سياسة جدولة FR-FCFS في متحكمات DRAM؟\",options:[\"First-Request, First-Come-First-Service\",\"First-Ready, First-Come-First-Service\",\"First-Row, First-Column-First-Service\",\"Fast-Response, First-Come-First-Service\"],correct:1,explanation:\"FR-FCFS تعني First-Ready, First-Come-First-Service. لديها قاعدتان: (1) 'أول صف إصابة': خدمة عمليات الوصول إلى الذاكرة التي تصيب الصف أولاً، (2) 'الأقدم أولاً': ثم خدمة عمليات الوصول الأقدم أولاً.\"},{question:\"ما الذي يجعل الوصول إلى صف متعارض في DRAM أبطأ بكثير من الوصول إلى صف مصاب؟\",options:[\"تأخيرات معالجة وحدة المعالجة المركزية\",\"عقوبات عدم إصابة ذاكرة التخزين المؤقت\",\"الحاجة إلى إغلاق الصف الحالي وفتح صف جديد في DRAM\",\"زمن انتقال الشبكة\"],correct:2,explanation:\"يتطلب الوصول إلى صف متعارض إغلاق الصف المفتوح حاليًا وفتح صف جديد في DRAM، الأمر الذي يستغرق وقتًا أطول بكثير من الوصول إلى البيانات من صف مفتوح بالفعل (إصابة الصف).\"},{question:\"في مثال استهلاك أداء الذاكرة، ما الذي يميز نمط الوصول STREAM؟\",options:[\"وصول عشوائي للذاكرة بتموضع منخفض لمخزن الصفوف\",\"وصول تسلسلي للذاكرة بتموضع عالٍ جدًا لمخزن الصفوف (معدل إصابة 96%)\",\"وصول ذاكرة مبعثر بتموضع متوسط\",\"نمط وصول ذاكرة دائري\"],correct:1,explanation:\"يتميز STREAM بالوصول التسلسلي إلى الذاكرة بتموضع عالٍ جدًا لمخزن الصفوف (معدل إصابة 96%) وهو كثيف الذاكرة، مما يجعله مستهلكًا لأداء الذاكرة.\"},{question:\"ما الذي يميز نمط الوصول RANDOM في مثال أداء الذاكرة؟\",options:[\"وصول تسلسلي بتموضع عالٍ\",\"وصول عشوائي للذاكرة بتموضع منخفض جدًا لمخزن الصفوف (معدل إصابة 3%)\",\"وصول منظم بتموضع متوسط\",\"نمط وصول يمكن التنبؤ به\"],correct:1,explanation:\"يتميز RANDOM بالوصول العشوائي إلى الذاكرة بتموضع منخفض جدًا لمخزن الصفوف (معدل إصابة 3%) وهو كثيف الذاكرة بالمثل مقارنة بـ STREAM.\"},{question:\"ما الذي تتكون منه خلية DRAM؟\",options:[\"ترانزستوران ومقاوم\",\"مكثف وترانزستور وصول\",\"ثلاثة مكثفات متسلسلة\",\"دائرة قلب (Flip-flop)\"],correct:1,explanation:\"تتكون خلية DRAM من مكثف وترانزستور وصول. تخزن البيانات من حيث الشحنة في المكثف.\"},{question:\"لماذا تحتاج DRAM إلى التحديث؟\",options:[\"لتحسين الأداء\",\"لأن شحنة المكثف تتسرب بمرور الوقت\",\"لتقليل استهلاك الطاقة\",\"لزيادة سعة التخزين\"],correct:1,explanation:\"تتسرب شحنة مكثف DRAM بمرور الوقت، لذا يحتاج متحكم الذاكرة إلى تحديث كل صف بشكل دوري لاستعادة الشحنة. عادة ما يجب تحديث كل صف كل 64 مللي ثانية.\"},{question:\"ما هي العيوب الرئيسية لتحديث DRAM؟\",options:[\"زيادة التكلفة فقط\",\"تدهور الأداء فقط\",\"استهلاك الطاقة، تدهور الأداء، تأثير جودة الخدمة، وقيود توسيع السعة\",\"استهلاك الطاقة فقط\"],correct:2,explanation:\"يحتوي تحديث DRAM على العديد من العيوب: استهلاك الطاقة (كل تحديث يستهلك طاقة)، تدهور الأداء (DRAM غير متاحة أثناء التحديث)، تأثير جودة الخدمة/القدرة على التنبؤ (أوقات توقف طويلة)، ومعدل التحديث يحد من توسيع سعة DRAM.\"},{question:\"ما هي الفترة الزمنية النموذجية لتحديث صفوف DRAM؟\",options:[\"64 ميكروثانية\",\"64 مللي ثانية\",\"64 ثانية\",\"64 نانوثانية\"],correct:1,explanation:\"الفترة الزمنية النموذجية للتحديث هي 64 مللي ثانية (64 ms). يجب تنشيط (تحديث) كل صف كل 64 مللي ثانية لاستعادة الشحنة في المكثفات.\"},{question:\"ما هي الملاحظة الرئيسية التي يقدمها RAIDR حول تحديث DRAM؟\",options:[\"جميع الصفوف تحتاج إلى تحديث متكرر\",\"يمكن تحديث معظم صفوف DRAM بشكل أقل تكرارًا دون فقدان البيانات\",\"التحديث غير ضروري\",\"فقط بعض الصفوف تحتاج إلى أي تحديث\"],correct:1,explanation:\"يلاحظ RAIDR أن معظم صفوف DRAM يمكن تحديثها بشكل أقل تكرارًا دون فقدان البيانات، مما يؤدي إلى فكرة تحديث الصفوف التي تحتوي على خلايا ضعيفة بشكل متكرر والصفوف الأخرى بشكل أقل.\"},{question:\"كيف يحقق RAIDR تقليل التحديث؟\",options:[\"عن طريق إلغاء التحديث تمامًا\",\"عن طريق تنميط أوقات الاحتفاظ، وتجميع الصفوف، وتحديث المجموعات المختلفة بمعدلات مختلفة\",\"عن طريق استخدام تقنية DRAM مختلفة\",\"عن طريق زيادة تردد التحديث لجميع الصفوف\"],correct:1,explanation:\"يعمل RAIDR في ثلاث خطوات: (1) تنميط وقت الاحتفاظ بجميع الصفوف، (2) تجميع الصفوف حسب وقت الاحتفاظ في متحكم الذاكرة باستخدام فلاتر بلوم، (3) تحديث الصفوف في سلال مختلفة بمعدلات مختلفة.\"},{question:\"ما هي الفوائد التي حققها RAIDR؟\",options:[\"تحسين الأداء فقط\",\"74.6% تقليل التحديث، ~16%/20% تقليل طاقة DRAM، ~9% تحسين الأداء\",\"تقليل الطاقة فقط\",\"تقليل التحديث فقط\"],correct:1,explanation:\"يحقق RAIDR فوائد متعددة: 74.6% تقليل التحديث مع حمل تخزين إضافي يبلغ 1.25 كيلوبايت فقط، ~16%/20% تقليل طاقة DRAM الديناميكية/الخاملة، و ~9% تحسين الأداء، مع زيادة الفوائد بزيادة سعة DRAM.\"},{question:\"ما هو أحد الهدفين الرئيسيين لدورة هندسة الكمبيوتر المذكورة في المحاضرة؟\",options:[\"تعلم لغات البرمجة\",\"فهم كيفية عمل المعالج تحت طبقة البرامج\",\"تصميم أنظمة التشغيل\",\"بناء مكونات الأجهزة\"],correct:1,explanation:\"أحد الأهداف الرئيسية هو فهم كيفية عمل المعالج تحت طبقة البرامج وكيف تؤثر القرارات المتخذة في الأجهزة على البرامج/المبرمج.\"},{question:\"ما هو الهدف الرئيسي الثاني لدورة هندسة الكمبيوتر؟\",options:[\"حفظ مجموعات التعليمات\",\"التمكين من اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات المختلفة\",\"التركيز فقط على تصميم الأجهزة\",\"التخصص في طبقة تجريد واحدة\"],correct:1,explanation:\"الهدف الرئيسي الثاني هو تمكين الطلاب من الشعور بالراحة في اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات والمكونات المختلفة للنظام.\"},{question:\"في سيناريو استهلاك أداء الذاكرة، كم عدد الطلبات تقريبًا لتطبيق STREAM (T0) يتم خدمتها قبل خدمة تطبيق RANDOM (T1)؟\",options:[\"64 طلبًا\",\"96 طلبًا\",\"128 طلبًا\",\"256 طلبًا\"],correct:2,explanation:\"مع حجم صف يبلغ 8 كيلوبايت وحجم كتلة ذاكرة تخزين مؤقت يبلغ 64 بايت، هناك 128 (8 كيلوبايت/64 بايت) طلبًا من T0 (STREAM) يتم خدمتها قبل أن يحصل T1 (RANDOM) على فرصة، مما يوضح عدم عدالة سياسة 'أول صف إصابة'.\"},{question:\"ما هي الفكرة الرئيسية حول طبقات التجريد من هذه المحاضرة؟\",options:[\"يجب عدم عبور طبقات التجريد أبدًا\",\"كسر طبقات التجريد ومعرفة ما هو تحتها يمكّن من حل المشكلات\",\"مصممو الأجهزة فقط هم من يحتاجون إلى فهم طبقات متعددة\",\"طبقات التجريد هي مفاهيم نظرية فقط\"],correct:1,explanation:\"الفكرة الرئيسية هي أن كسر طبقات التجريد (بين المكونات ومستويات التسلسل الهرمي للتحويل) ومعرفة ما هو تحتها يمكّنك من حل المشكلات وتصميم أنظمة مستقبلية أفضل. يمكن أن يتيح التعاون بين مكونات وطبقات متعددة حلولًا أكثر فعالية.\"}],\"الفصل الخامس: ما هو الكمبيوتر ونموذج فون نيومان\":[{question:\"ما هي المكونات الرئيسية الثلاثة التي تحدد الكمبيوتر؟\",options:[\"الأجهزة، البرامج، والمستخدمون\",\"الحساب، الاتصال، والتخزين (الذاكرة)\",\"الإدخال، المعالجة، والإخراج\",\"وحدة المعالجة المركزية، ذاكرة الوصول العشوائي، والقرص الصلب\"],correct:1,explanation:\"يتم تعريف الكمبيوتر من خلال ثلاثة مكونات رئيسية: الحساب (المعالجة)، الاتصال (الإدخال/الإخراج)، والتخزين (الذاكرة). تعمل هذه المكونات معًا لتشكيل نظام حوسبة كامل.\"},{question:\"ما هما الخاصيتان الرئيسيتان لنموذج فون نيومان؟\",options:[\"معالجة سريعة وذاكرة كبيرة\",\"برنامج مخزن ومعالجة تعليمات متسلسلة\",\"نوى متعددة ومعالجة متوازية\",\"إمكانيات الإدخال/الإخراج وواجهة المستخدم\"],correct:1,explanation:\"يحتوي نموذج فون نيومان على خاصيتين رئيسيتين: (1) برنامج مخزن - تعليمات مخزنة في مصفوفة ذاكرة خطية مع ذاكرة موحدة للتعليمات والبيانات، (2) معالجة تعليمات متسلسلة - تعليمة واحدة تتم معالجتها في كل مرة مع عداد البرنامج يحدد التعليمات الحالية.\"},{question:\"في نموذج فون نيومان، ما الذي يحدد ما إذا كانت القيمة المخزنة تفسر كتعليمات؟\",options:[\"القيمة نفسها\",\"موقع الذاكرة\",\"إشارات التحكم\",\"نوع البيانات\"],correct:2,explanation:\"في نموذج فون نيومان، يعتمد تفسير القيمة المخزنة على إشارات التحكم. يمكن تفسير نفس نمط البت كبيانات أو كتعليمات اعتمادًا على كيفية معالجة وحدة التحكم لها.\"},{question:\"ما هو الاسم الآخر لبنية فون نيومان؟\",options:[\"كمبيوتر معالجة متوازية\",\"كمبيوتر برنامج مخزن\",\"كمبيوتر تدفق البيانات\",\"كمبيوتر متعدد النواة\"],correct:1,explanation:\"تُسمى بنية فون نيومان أيضًا 'كمبيوتر برنامج مخزن' لأن التعليمات تخزن في الذاكرة جنبًا إلى جنب مع البيانات، بدلاً من أن تكون موصلة بشكل ثابت في الجهاز.\"},{question:\"في نموذج فون نيومان، كيف يتم تقدم عداد البرنامج (مؤشر التعليمات)؟\",options:[\"عشوائيًا بناءً على التعليمات المتاحة\",\"بناءً على توفر البيانات\",\"بشكل تسلسلي باستثناء تعليمات نقل التحكم\",\"بشكل متوازٍ لتعليمات متعددة\"],correct:2,explanation:\"يتم تقدم عداد البرنامج بشكل تسلسلي باستثناء تعليمات نقل التحكم (مثل القفزات، التفرعات، الاستدعاءات). هذا التقدم التسلسلي هو سمة أساسية لتنفيذ فون نيومان.\"},{question:\"في نموذج تدفق البيانات، متى يتم تنفيذ تعليمات؟\",options:[\"عندما يشير مؤشر التعليمات إليها\",\"عندما تكون جميع معاملاتها جاهزة\",\"بترتيب تسلسلي\",\"عندما تكون وحدة المعالجة المركزية خاملة\"],correct:1,explanation:\"في نموذج تدفق البيانات، يتم تنفيذ التعليمات عندما تكون جميع معاملاتها جاهزة (أي، عندما تحتوي جميع المدخلات على رموز). لا يوجد مؤشر تعليمات - يتم تشغيل التنفيذ بتوفر البيانات.\"},{question:\"ما هو الفرق الرئيسي بين نماذج تنفيذ فون نيومان وتدفق البيانات؟\",options:[\"فون نيومان يستخدم ذاكرة أكبر\",\"فون نيومان موجه بالتحكم/تسلسلي، تدفق البيانات موجه بالبيانات/متوازٍ\",\"تدفق البيانات أبطأ من فون نيومان\",\"فون نيومان يتطلب أجهزة خاصة\"],correct:1,explanation:\"نموذج فون نيومان موجه بالتحكم مع تنفيذ تسلسلي (مؤشر التعليمات يتحكم في الترتيب)، بينما نموذج تدفق البيانات موجه بالبيانات مع تنفيذ متوازٍ محتمل (توفر البيانات يتحكم في الترتيب).\"},{question:\"أي نموذج تنفيذ هو أكثر توازيًا بطبيعته؟\",options:[\"نموذج فون نيومان\",\"نموذج تدفق البيانات\",\"كلاهما متوازٍ بالتساوي\",\"لا يدعم أي منهما التوازي\"],correct:1,explanation:\"نموذج تدفق البيانات أكثر توازيًا بطبيعته لأن تعليمات متعددة يمكن أن 'تطلق' (تنفذ) في وقت واحد عندما تكون معاملاتها جاهزة، على عكس التنفيذ التسلسلي لفون نيومان.\"},{question:\"في آلة تدفق البيانات، ما الذي يتسبب في 'إطلاق' عقدة تدفق البيانات؟\",options:[\"إشارة ساعة\",\"مؤشر التعليمات\",\"عندما تكون جميع مدخلاتها تحتوي على رموز (جاهزة)\",\"محفز عشوائي\"],correct:2,explanation:\"تطلق عقدة تدفق البيانات (يتم جلبها وتنفيذها) عندما تكون جميع مدخلاتها جاهزة، أي عندما تحتوي جميع المدخلات على رموز. هذا هو مبدأ التنفيذ الأساسي للحوسبة بتدفق البيانات.\"},{question:\"ما هي بنيات مجموعات التعليمات الرئيسية التي تستخدم نموذج فون نيومان اليوم؟\",options:[\"x86 فقط\",\"x86، ARM، MIPS، SPARC، Alpha، POWER\",\"ARM و x86 فقط\",\"البنيات القديمة فقط\"],correct:1,explanation:\"جميع بنيات مجموعات التعليمات الرئيسية اليوم تستخدم نموذج فون نيومان، بما في ذلك بنيات x86، ARM، MIPS، SPARC، Alpha، و POWER.\"},{question:\"على مستوى البنية الدقيقة، كيف تنفذ المعالجات الحديثة التعليمات فعليًا؟\",options:[\"تمامًا كما هو محدد بواسطة نموذج فون نيومان\",\"بشكل مختلف تمامًا عن نموذج فون نيومان (مقسمة، خارج الترتيب، إلخ)\",\"بترتيب تسلسلي فقط\",\"بدون أي تحسين\"],correct:1,explanation:\"تنفذ البنيات الدقيقة الحديثة بشكل مختلف تمامًا عن نموذج فون نيومان - باستخدام التنفيذ المقسم، تعليمات متعددة في نفس الوقت، التنفيذ خارج الترتيب، وذاكرات تخزين مؤقت منفصلة للتعليمات/البيانات، ولكن هذا لا يُكشف للبرامج.\"},{question:\"ما هو الفرق الرئيسي بين ISA والبنية الدقيقة؟\",options:[\"ISA هي الأجهزة، البنية الدقيقة هي البرامج\",\"ISA هي الواجهة المتفق عليها بين البرامج/الأجهزة، البنية الدقيقة هي التنفيذ المحدد\",\"هما نفس الشيء\",\"ISA قديمة، البنية الدقيقة جديدة\"],correct:1,explanation:\"ISA هي الواجهة المتفق عليها بين البرامج والأجهزة (ما يحتاج كاتب البرامج إلى معرفته)، بينما البنية الدقيقة هي التنفيذ المحدد لـ ISA (غير مرئي للبرامج).\"},{question:\"باستخدام تشبيه السيارة، ما الذي يمثل ISA مقابل البنية الدقيقة؟\",options:[\"المحرك مقابل العجلات\",\"دواسة الوقود (الواجهة) مقابل المكونات الداخلية للمحرك (التنفيذ)\",\"عجلة القيادة مقابل الفرامل\",\"الخارج مقابل الداخل\"],correct:1,explanation:\"تمثل دواسة الوقود ISA (واجهة 'التسارع' التي يستخدمها السائق)، بينما تمثل المكونات الداخلية للمحرك البنية الدقيقة (كيف يتم 'التسارع' فعليًا).\"},{question:\"ما الذي يتغير بشكل أسرع: ISA أم البنية الدقيقة؟\",options:[\"ISA تتغير بشكل أسرع\",\"البنية الدقيقة تتغير بشكل أسرع\",\"يتغيران بنفس المعدل\",\"لا يتغير أي منهما\"],correct:1,explanation:\"تتغير البنية الدقيقة عادةً بشكل أسرع من ISA. هناك عدد قليل من ISAs (x86، ARM، SPARC، MIPS، Alpha) ولكن العديد من البنيات الدقيقة. على سبيل المثال، لدى x86 ISA العديد من التطبيقات: 286، 386، 486، بنتيوم، بنتيوم برو، بنتيوم 4، كور، إلخ.\"},{question:\"ماذا تشير المعالجة الفائقة إلى؟\",options:[\"استخدام نوى وحدة المعالجة المركزية متعددة\",\"تقنية لتنفيذ تعليمات متعددة بالتوازي داخل نفس نواة المعالج\",\"زيادة تردد الساعة\",\"إضافة المزيد من الذاكرة\"],correct:1,explanation:\"المعالجة الفائقة هي تقنية تستخدم في تصميم المعالجات الدقيقة الحديثة لزيادة إنتاجية التعليمات عن طريق تنفيذ تعليمات متعددة بالتوازي داخل نفس نواة المعالج، مما يسمح بأكثر من تعليمات واحدة لكل دورة ساعة.\"},{question:\"أي مما يلي جزء من ISA؟\",options:[\"عدد المنافذ لملف السجل\",\"رمز تشغيل تعليمة ADD\",\"ما إذا كان الجهاز يستخدم التنفيذ المقسم\",\"عدد الدورات لتنفيذ تعليمة MUL\"],correct:1,explanation:\"رمز تشغيل تعليمة ADD جزء من ISA لأنه يحدد واجهة التعليمات. عدد منافذ ملف السجل، التنفيذ المقسم، ودورات التنفيذ هي تفاصيل تنفيذ البنية الدقيقة غير مرئية للبرامج.\"},{question:\"أي مما يلي جزء من البنية الدقيقة؟\",options:[\"عدد السجلات ذات الأغراض العامة\",\"رموز تشغيل التعليمات\",\"عدد المنافذ لملف السجل\",\"أوضاع عنونة الذاكرة\"],correct:2,explanation:\"عدد المنافذ لملف السجل هو تفصيل في البنية الدقيقة (خيار تنفيذ للأداء). عدد السجلات، رموز التشغيل، وأوضاع العنونة هي مواصفات ISA مرئية للمبرمجين.\"},{question:\"ما الذي تحدده ISA فيما يتعلق بالتعليمات؟\",options:[\"تنسيق التعليمات فقط\",\"رموز التشغيل، أوضاع العنونة، أنواع البيانات، أنواع وتنسيقات التعليمات، السجلات، رموز الشرط\",\"وقت التنفيذ فقط\",\"متطلبات الذاكرة فقط\"],correct:1,explanation:\"تحدد ISA عناصر شاملة متعلقة بالتعليمات: رموز التشغيل، أوضاع العنونة، أنواع البيانات، أنواع وتنسيقات التعليمات، السجلات، ورموز الشرط - كل ما يحتاج المبرمج إلى معرفته لكتابة البرامج.\"},{question:\"أي مما يلي خيارات تنفيذ البنية الدقيقة؟\",options:[\"إدارة الذاكرة الافتراضية\",\"التنفيذ المقسم، التنفيذ خارج الترتيب، سياسات التخزين المؤقت، المعالجة الفائقة\",\"تعريف مجموعة التعليمات\",\"أوضاع عنونة الذاكرة\"],correct:1,explanation:\"تتضمن البنية الدقيقة خيارات تنفيذ مثل التنفيذ المقسم، التنفيذ بالترتيب أم خارج الترتيب، جدولة الوصول إلى الذاكرة، المعالجة الفائقة، سياسات التخزين المؤقت، الجلب المسبق، إلخ - كل ذلك يتم بدون كشف للبرامج.\"},{question:\"في مثال التنفيذ خارج الترتيب بالتعليمات (1) mov eax,0 (2) mov edx,1 (3) mov edx,3 (4) inc edx (5) mov ecx,3، ما الذي يحدد ترتيب التنفيذ؟\",options:[\"يجب الحفاظ على ترتيب البرنامج الأصلي\",\"تحدد الترانزستورات/الأجهزة بناءً على التبعيات والموارد المتاحة\",\"اختيار عشوائي\",\"دائمًا يتم التنفيذ بترتيب عكسي\"],correct:1,explanation:\"في التنفيذ خارج الترتيب، تحدد الترانزستورات (الأجهزة) التعليمات التي يجب تنفيذها بناءً على تبعيات البيانات والموارد التنفيذية المتاحة، مع الحفاظ على دلالات البرنامج correctة.\"}],'الفصل 6: مقدمة في المقايضات في ISA':[{question:\"ما هي نقطة التصميم في هندسة الكمبيوتر؟\",options:[\"موقع محدد على شريحة المعالج\",\"مجموعة من اعتبارات التصميم وأهميتها التي تؤدي إلى مقايضات\",\"المرحلة النهائية لتصميم المعالج\",\"منهجية اختبار للمعالجات\"],correct:1,explanation:\"نقطة التصميم هي مجموعة من اعتبارات التصميم وأهميتها التي تؤدي إلى مقايضات في كل من ISA والبنية الدقيقة. يتم تحديدها بواسطة مساحة التطبيق والسوق/المستخدمين المستهدفين.\"},{question:\"أي مما يلي هي اعتبارات تصميم رئيسية مذكورة في المحاضرة؟\",options:[\"التكلفة والأداء فقط\",\"التكلفة، الأداء، استهلاك الطاقة، استهلاك الطاقة (عمر البطارية)، التوفر، الموثوقية، الوقت اللازم للتسويق\",\"الأداء والموثوقية فقط\",\"تعقيد الأجهزة وتوافق البرامج\"],correct:1,explanation:\"تشمل اعتبارات التصميم الرئيسية: التكلفة، الأداء، أقصى استهلاك للطاقة، استهلاك الطاقة (عمر البطارية)، التوفر، الموثوقية والصحة، والوقت اللازم للتسويق.\"},{question:\"ما الذي يحدد نقطة تصميم نظام الكمبيوتر؟\",options:[\"التقنية المتاحة\",\"تكلفة التصنيع\",\"مساحة 'المشكلة' (مساحة التطبيق) والسوق/المستخدمون المستهدفون\",\"اللوائح الحكومية\"],correct:2,explanation:\"يتم تحديد نقطة التصميم بواسطة مساحة 'المشكلة' (مساحة التطبيق) والسوق/المستخدمين المستهدفين، مما يؤثر على الأهمية النسبية لاعتبارات التصميم المختلفة.\"},{question:\"ما هما المكونان الرئيسيان للتعليمات؟\",options:[\"العنوان والبيانات\",\"رمز التشغيل والمعاملات\",\"المصدر والوجهة\",\"الإدخال والإخراج\"],correct:1,explanation:\"تتكون التعليمات من: (1) رمز التشغيل - ما تفعله التعليمات، و (2) المعاملات - لمن تقوم بها. هذا هو العنصر الأساسي لواجهة الأجهزة/البرامج.\"},{question:\"ما هو مفهوم 'توجيه البتات' في ترميز التعليمات؟\",options:[\"استخدام البتات للتحكم في اتجاه تدفق البيانات\",\"بت في التعليمات يحدد تفسير البتات الأخرى\",\"توجيه البتات نحو وحدة المنطق والحساب\",\"إدارة العمليات على مستوى البتات\"],correct:1,explanation:\"توجيه البتات هو مفهوم حيث يحدد بت في التعليمات تفسير البتات الأخرى، مما يسمح باستخدام أكثر كفاءة لمساحة ترميز التعليمات.\"},{question:\"في آلة ذات 0 عنوان (مكدس)، كيف يتم تنفيذ العمليات؟\",options:[\"باستخدام السجلات فقط\",\"تعمل العمليات على العناصر العلوية للمكدس (دفع/سحب)\",\"عنونة الذاكرة المباشرة\",\"باستخدام سجل التجميع\"],correct:1,explanation:\"في آلة مكدس ذات 0 عنوان، تعمل العمليات على العناصر العلوية للمكدس. يتم دفع المعاملات إلى المكدس، وتنفذ العمليات على العناصر العلوية للمكدس، ويتم سحب النتائج.\"},{question:\"ما الذي يميز آلة ذات 1 عنوان (تجميع)؟\",options:[\"تستخدم جميع العمليات المكدس\",\"العمليات تستخدم سجل التجميع (op ACC, ld A, st A)\",\"معاملان لكل تعليمة\",\"ثلاثة معاملات منفصلة\"],correct:1,explanation:\"في آلة تجميع ذات 1 عنوان، تتضمن العمليات عادة سجل التجميع (ACC). التعليمات مثل 'op ACC'، 'ld A' (تحميل إلى ACC)، 'st A' (تخزين من ACC) هي مميزة.\"},{question:\"في آلة ذات 2 عنوان، ماذا يحدث لأحد المعاملات؟\",options:[\"يبقى دون تغيير\",\"معامل واحد هو المصدر والوجهة (يتم تدميره)\",\"يتم نسخه إلى الذاكرة\",\"يتم دفعه إلى المكدس\"],correct:1,explanation:\"في آلة ذات 2 عنوان (op S,D)، يعمل أحد المعاملات كمصدر ووجهة، مما يعني أن القيمة الأصلية يتم الكتابة فوقها (تدميرها) بنتيجة العملية.\"},{question:\"ما هي الميزة الرئيسية لآلة ذات 3 عناوين؟\",options:[\"حجم تعليمات أصغر\",\"المصدر والوجهة منفصلان (op S1,S2,D)\",\"تنفيذ أسرع\",\"استهلاك طاقة أقل\"],correct:1,explanation:\"في آلة ذات 3 عناوين (op S1,S2,D)، يكون معاملا المصدر والوجهة منفصلين، مما يعني أن قيم المصدر محفوظة ولا يتم تدميرها أثناء العمليات.\"},{question:\"ما هي المزايا الرئيسية لآلات المكدس؟\",options:[\"حجم تعليمات كبير ومنطق معقد\",\"حجم تعليمات صغير، منطق أبسط، كود مدمج، استدعاءات إجراءات فعالة\",\"مرونة عالية وعمليات متوازية\",\"دعم أنواع بيانات معقدة\"],correct:1,explanation:\"تتميز آلات المكدس بـ: حجم تعليمات صغير (لا توجد حاجة لمعاملات لتعليمات التشغيل)، منطق أبسط، كود مدمج، واستدعاءات إجراءات فعالة (جميع المعلمات على المكدس بدون دورات إضافية لتمرير المعلمات).\"},{question:\"ما هي العيوب الرئيسية لآلات المكدس؟\",options:[\"حجم كود كبير وتنفيذ بطيء\",\"العمليات الحسابية التي لا يمكن التعبير عنها بسهولة في تدوين لاحق (postfix) صعبة؛ مرونة محدودة\",\"استهلاك طاقة عالٍ\",\"فك تشفير تعليمات معقد\"],correct:1,explanation:\"تتميز آلات المكدس بعيوب: العمليات الحسابية التي لا يمكن التعبير عنها بسهولة في تدوين لاحق صعبة التخطيط، لا يمكنها إجراء عمليات على العديد من القيم في وقت واحد (فقط أعلى N قيم)، وتفتقر إلى المرونة.\"},{question:\"PDP-11 هو مثال على أي نوع من الآلات؟\",options:[\"آلة ذات 0 عنوان (مكدس)\",\"آلة ذات 1 عنوان (تجميع)\",\"آلة ذات 2 عنوان\",\"آلة ذات 3 عناوين\"],correct:2,explanation:\"PDP-11 هي آلة ذات 2 عنوان. تحتوي تعليمة ADD الخاصة بها على رمز تشغيل 4 بت و2 مُحددات معامل 6 بت، مع بتات محدودة لتحديد تعليمة.\"},{question:\"ما هي العيب الرئيسي لتصميم PDP-11 ذو 2 عنوان؟\",options:[\"الكثير من المعاملات\",\"يتم دائمًا تدمير أحد معاملي المصدر بالنتيجة\",\"التعليمات طويلة جدًا\",\"لا يمكن الوصول إلى الذاكرة\"],correct:1,explanation:\"في تصميم PDP-11 ذو 2 عنوان، يتم دائمًا تدمير أحد معاملي المصدر (الكتابة فوقه) بنتيجة التعليمات، مما يتطلب خطوات إضافية للحفاظ على القيم الأصلية عند الحاجة.\"},{question:\"ما هو نوع آلة بنية ألفا؟\",options:[\"آلة ذاكرة/ذاكرة ذات 2 عنوان\",\"آلة مكدس\",\"آلة تحميل/تخزين ذات 3 عناوين\",\"آلة تجميع ذات 1 عنوان\"],correct:2,explanation:\"ألفا هي آلة تحميل/تخزين ذات 3 عناوين، مما يعني أنها تحتوي على معاملات مصدر ووجهة منفصلة، ويتم الوصول إلى الذاكرة فقط من خلال تعليمات تحميل وتخزين صريحة.\"},{question:\"ما هو نوع آلة x86؟\",options:[\"آلة تحميل/تخزين ذات 3 عناوين\",\"آلة ذاكرة/ذاكرة ذات 2 عنوان\",\"آلة مكدس فقط\",\"آلة تجميع ذات 1 عنوان\"],correct:1,explanation:\"x86 هي آلة ذاكرة/ذاكرة ذات 2 عنوان، مما يعني أنها يمكن أن تنفذ عمليات مباشرة بين مواقع الذاكرة والسجلات، مع معامل واحد يعمل كمصدر ووجهة.\"},{question:\"كيف يتم تعريف نوع البيانات في سياق ISA؟\",options:[\"أي تمثيل ثنائي\",\"تمثيل للمعلومات توجد له تعليمات تعمل على هذا التمثيل\",\"الأنواع الأولية فقط مثل الأعداد correctة\",\"تنسيق تخزين الذاكرة فقط\"],correct:1,explanation:\"يتم تعريف نوع البيانات على أنه تمثيل للمعلومات توجد له تعليمات تعمل على هذا التمثيل. لا يتعلق الأمر بتنسيق التخزين فقط، بل بدعم التعليمات.\"},{question:\"أي مما يلي أمثلة على أنواع البيانات المذكورة؟\",options:[\"الأعداد correctة والنقطة العائمة فقط\",\"الأعداد correctة، النقطة العائمة، الحرف، الثنائي، العشري، BCD، القائمة المترابطة المزدوجة، قائمة الانتظار، السلسلة، المتجه البت، المكدس\",\"أنواع البيانات الأولية فقط\",\"الأنواع الرقمية فقط\"],correct:1,explanation:\"تذكر المحاضرة أنواع بيانات مختلفة: الأعداد correctة، النقطة العائمة، الحرف، الثنائي، العشري، BCD، القائمة المترابطة المزدوجة، قائمة الانتظار، السلسلة، المتجه البت، والمكدس - تتراوح من الأنواع الأولية إلى الأنواع المهيكلة المعقدة.\"},{question:\"ما هو مثال لتعليمة نوع بيانات عالية المستوى من VAX؟\",options:[\"ADD و SUB فقط\",\"INSQUEUE (إدراج في قائمة الانتظار) و REMQUEUE (إزالة من قائمة الانتظار) على قوائم مترابطة مزدوجة\",\"التحميل والتخزين فقط\",\"العمليات الحسابية الأساسية\"],correct:1,explanation:\"قدمت VAX تعليمات عالية المستوى مثل INSQUEUE (إدراج في قائمة الانتظار) و REMQUEUE (إزالة من قائمة الانتظار) التي تعمل على قوائم مترابطة مزدوجة أو قوائم انتظار، و FINDFIRST لعمليات هيكل البيانات المعقدة.\"},{question:\"ما الذي يشير إليه 'الفجوة الدلالية' في هندسة الكمبيوتر؟\",options:[\"المسافة المادية بين المكونات\",\"التفاوت بين مفاهيم البرامج عالية المستوى وعمليات الأجهزة منخفضة المستوى\",\"التأخير الزمني في تنفيذ التعليمات\",\"زمن انتقال الوصول إلى الذاكرة\"],correct:1,explanation:\"تشير الفجوة الدلالية إلى التفاوت بين المفاهيم والتجريدات عالية المستوى المستخدمة في برمجة البرامج والعمليات والآليات منخفضة المستوى المطبقة في الأجهزة.\"},{question:\"كيف تختلف بنيات RISC المبكرة و Intel 432 من حيث الفجوة الدلالية؟\",options:[\"كلاهما له نفس النهج\",\"RISC المبكر: نوع بيانات عدد صحيح فقط (فجوة كبيرة)؛ Intel 432: نوع بيانات كائن، قائم على القدرات (فجوة صغيرة)\",\"كلاهما يركز على أنواع البيانات المعقدة\",\"كلاهما يستخدم الأنواع الأولية فقط\"],correct:1,explanation:\"كانت بنيات RISC المبكرة تحتوي على أنواع بيانات عدد صحيح فقط (مما أدى إلى فجوة دلالية كبيرة)، بينما دعمت Intel 432 أنواع بيانات الكائنات وكانت قائمة على القدرات (محاولة لسد الفجوة الدلالية بميزات عالية المستوى).\"}],'الفصل 7: المقايضات في ISA':[{question:\"أي ISA قدم تعليمات مخصصة لعمليات القائمة المترابطة المزدوجة مثل INSQUEUE؟\",options:[\"x86\",\"VAX\",\"MIPS\",\"ARM\"],correct:1,explanation:\"كان لدى VAX تعليمات متخصصة لعمليات قوائم الانتظار/القوائم، مما يعكس فلسفة تصميم CISC.\"},{question:\"ما هو نوع البيانات الأساسي المدعوم في بنيات RISC المبكرة؟\",options:[\"نقطة عائمة\",\"عدد صحيح فقط\",\"مراجع الكائنات\",\"عشري مشفر ثنائيًا\"],correct:1,explanation:\"دعمت تصميمات RISC المبكرة مثل MIPS الأعداد correctة فقط للحفاظ على البساطة.\"},{question:\"توضح أنواع بيانات الكائنات في Intel 432 أي نوع من نهج الفجوة الدلالية؟\",options:[\"فجوة قصوى\",\"فجوة مصغرة\",\"لا فجوة\",\"فجوة متغيرة\"],correct:1,explanation:\"هدفت Intel 432 إلى تقليل الفجوة من خلال دعم البنى عالية المستوى مباشرة في الأجهزة.\"},{question:\"في نظام قابل للعنونة 32 بت مثل Alpha الأول، كيف يمكنك إضافة رقمين 32 بت؟\",options:[\"باستخدام تعليمات تحميل/تخزين 32 بت\",\"باستخدام تعليمة ADD واحدة 64 بت\",\"من خلال عمليات الذاكرة إلى الذاكرة\",\"باستخدام عمليات قابلة للعنونة بالبت\"],correct:0,explanation:\"يتطلب عمليات متعددة بسبب قيود العنونة 32 بت.\"},{question:\"أي بنية حاسوب عملاق استخدمت عنونة 64 بت؟\",options:[\"Burroughs 1700\",\"Cray-1\",\"Intel 432\",\"VAX-11\"],correct:1,explanation:\"أجهزة الكمبيوتر العملاقة Cray كانت رائدة في عنونة 64 بت للحوسبة العلمية.\"},{question:\"أي بنية تستخدم ترتيب البايت الكبير (big-endian)؟\",options:[\"x86\",\"PowerPC\",\"ARM (وضع little-endian)\",\"ناقل PCI الأصلي\"],correct:1,explanation:\"تعد PowerPC و SPARC من البنيات الكبيرة البارزة.\"},{question:\"في أنظمة little-endian، كيف تخزن القيمة 0x12345678 في العنوان A؟\",options:[\"A:12 A+1:34 A+2:56 A+3:78\",\"A:78 A+1:56 A+2:34 A+3:12\",\"A:56 A+1:78 A+2:12 A+3:34\",\"مقسمة عبر خطوط ذاكرة التخزين المؤقت\"],correct:1,explanation:\"يخزن little-endian البايت الأقل أهمية في أدنى عنوان.\"},{question:\"ما هي خاصية البرامج التي تبرر وجود السجلات في ISA؟\",options:[\"التوطين المكاني\",\"توطين البيانات (زماني ومكاني)\",\"تأثير جدار الذاكرة\",\"عنق الزجاجة في فون نيومان\"],correct:1,explanation:\"تستغل السجلات التوطين الزماني (البيانات المعاد استخدامها) والتوطين المكاني (البيانات القريبة).\"},{question:\"كم عدد السجلات ذات الأغراض العامة التي قدمتها IA-64 (Itanium)؟\",options:[\"8\",\"16\",\"32\",\"128\"],correct:3,explanation:\"توسعت IA-64 إلى 128 سجلًا للتوازي الصريح.\"},{question:\"لماذا لا يستطيع المبرمجون الوصول مباشرة إلى سجلات خط الأنابيب؟\",options:[\"محمية بواسطة نظام التشغيل\",\"تمثل حالة البنية الدقيقة\",\"غير قابلة للوصول ماديًا\",\"تخالف حماية الذاكرة\"],correct:1,explanation:\"تعد سجلات خط الأنابيب جزءًا من البنية الدقيقة الخاصة بالتنفيذ.\"},{question:\"أي فئة تعليمات تغير تسلسل التنفيذ؟\",options:[\"تعليمات التشغيل\",\"تعليمات نقل البيانات\",\"تعليمات تدفق التحكم\",\"تعليمات النقطة العائمة\"],correct:2,explanation:\"تعليمات تدفق التحكم (التفرعات/القفزات) تغير عداد البرنامج.\"},{question:\"أي وضع عنونة يجمع بين سجل أساسي وسجل فهرس؟\",options:[\"الإزاحة\",\"التسجيل غير المباشر\",\"العنونة المفهرسة\",\"الذاكرة غير المباشرة\"],correct:2,explanation:\"تستخدم العنونة المفهرسة حساب الأساس + الفهرس.\"},{question:\"ماذا يعني 'ISA المتعامد'؟\",options:[\"التعليمات تستخدم الزوايا القائمة فقط\",\"جميع التعليمات يمكنها استخدام جميع أوضاع العنونة\",\"محاذاة تعليمات ثابتة 90 درجة\",\"خطوط أنابيب منفصلة للأعداد correctة/النقطة العائمة\"],correct:1,explanation:\"التعامد يعني التجميع الموحد للعمليات وأوضاع العنونة.\"},{question:\"ما هي الميزة الرئيسية للتعليمات ذات الطول المتغير؟\",options:[\"فك تشفير أجهزة أبسط\",\"كثافة كود أفضل\",\"سرعات ساعة أسرع\",\"سجلات أكثر\"],correct:1,explanation:\"يتيح الطول المتغير ترميزًا مدمجًا (مثل x86).\"},{question:\"أي حقل في تعليمات MIPS I-type يحمل القيمة الفورية؟\",options:[\"rs\",\"rt\",\"opcode\",\"حقل فوري 16 بت\"],correct:3,explanation:\"يستخدم I-type قيمة فورية 16 بت للثوابت/الزوايا.\"},{question:\"ما هو العيب الرئيسي لتعليمات CISC المعقدة؟\",options:[\"فرص تحسين محدودة للمترجم\",\"الكثير من السجلات\",\"ترميز ثابت الطول\",\"نقص دعم الذاكرة الافتراضية\"],correct:0,explanation:\"خلقت التعليمات المعقدة عمليات ذات مستوى تفصيلي كبير قيدت التحسينات.\"},{question:\"أي تعليمات VAX وفرت الوصول إلى المصفوفات مع التحقق من الحدود؟\",\"خيارات\":[\"MOV\",\"INDEX\",\"BOUNDS\",\"ARRAY\"],correct:1,explanation:\"تعليمات VAX INDEX كانت مثالاً على دعم لغة عالية المستوى.\"},{question:\"أي خاصية ليست نموذجية لتصميمات RISC؟\",options:[\"أوضاع عنونة متعددة\",\"فك تشفير موحد\",\"تعليمات ثابتة الطول\",\"بنية تحميل/تخزين\"],correct:0,explanation:\"تقلل RISC من أوضاع العنونة من أجل البساطة.\"},{question:\"ما الذي حفز بادئات تعليمات x86؟\",options:[\"التوافق مع الإصدارات السابقة\",\"فك تشفير أسرع\",\"سجلات أقل\",\"دعم big-endian\"],correct:0,explanation:\"سمحت البادئات بتوسيع ISA مع الحفاظ على التوافق.\"},{question:\"ما الذي دفع تطور ISA وفقًا للفصل؟\",options:[\"قيود المترجم\",\"قيود الذاكرة\",\"احتياجات التخصص\",\"كل ما سبق\"],correct:3,explanation:\"كل هذه العوامل أثرت تاريخيًا على تصميم ISA.\"},{question:\"كم عدد البايتات التي يمكن أن تشغلها بادئات تعليمات x86؟\",options:[\"0\",\"1\",\"حتى 4\",\"2 بالضبط\"],correct:2,explanation:\"يسمح x86 بما يصل إلى أربع بادئات بايت واحد.\"},{question:\"أي تنسيق تعليمات MIPS يحتوي على قيمة فورية 26 بت؟\",options:[\"R-type\",\"I-type\",\"J-type\",\"U-type\"],correct:2,explanation:\"يستخدم J-type (القفز) قيمًا فورية 26 بت لأهداف العنوان.\"}],'الفصل 8: البنية الدقيقة ذات الدورة الواحدة':[{question:\"ما هو الغرض الأساسي من ذاكرة التخزين المؤقت؟\",options:[\"لتخزين جميع تعليمات البرنامج بشكل دائم\",\"لتخزين التعليمات النشطة/المستخدمة بشكل متكرر وتسريع المعالجة\",\"لاستبدال الذاكرة الرئيسية بالكامل\",\"لتخزين نتائج العمليات الحسابية فقط\"],correct:1,explanation:\"تقوم ذاكرة التخزين المؤقت بتخزين التعليمات النشطة أو المستخدمة بشكل متكرر مؤقتًا لتسريع المعالجة وتقليل الاختناقات بين ذاكرة الوصول العشوائي ووحدة المعالجة المركزية.\"},{question:\"أثناء جزء الجلب من دورة التعليمات، ما هو دور ناقل العنوان؟\",options:[\"ينقل رمز تشغيل التعليمات إلى وحدة المنطق والحساب\",\"ينقل عنوان التعليمات إلى الذاكرة الرئيسية\",\"يخزن نتيجة التعليمات المنفذة\",\"يفك تشفير التعليمات لوحدة التحكم\"],correct:1,explanation:\"ينقل ناقل العنوان عنوان الذاكرة للتعليمات المراد جلبها من الذاكرة الرئيسية إلى وحدة المعالجة المركزية.\"},{question:\"أي مما يلي هو عيب لسرعات الساعة الأعلى في وحدات المعالجة المركزية؟\",options:[\"يمكن تنفيذ عدد أقل من التعليمات في الثانية\",\"قد ترتفع درجة حرارة وحدة المعالجة المركزية وتتطلب المزيد من التبريد\",\"تعمل البرامج بشكل أبطأ بسبب زيادة التعقيد\",\"يتم تقليل عرض ناقل البيانات\"],correct:1,explanation:\"تزيد سرعات الساعة الأعلى من استهلاك الطاقة وتوليد الحرارة، مما قد يتسبب في ارتفاع درجة الحرارة ويتطلب حلول تبريد إضافية.\"},{question:\"في بنية دقيقة ذات دورة واحدة، كم عدد دورات الساعة التي تستغرقها كل تعليمة للتنفيذ؟\",options:[\"دورة واحدة\",\"دورتين\",\"دورات متغيرة حسب التعليمات\",\"ست دورات (واحدة لكل مرحلة)\"],correct:0,explanation:\"في بنية دقيقة ذات دورة واحدة، يتم إكمال جميع مراحل التعليمات (الجلب، فك التشفير، التنفيذ، إلخ) ضمن دورة ساعة واحدة.\"},{question:\"ما الذي يحدد وقت دورة الساعة في بنية دقيقة ذات دورة واحدة؟\",options:[\"أسرع تعليمة\",\"متوسط زمن انتقال التعليمات\",\"أبطأ تعليمة\",\"عدد الوحدات الوظيفية\"],correct:2,explanation:\"تحدد أبطأ تعليمة وقت دورة الساعة لأن جميع التعليمات يجب أن تكتمل ضمن دورة واحدة.\"}],'الفصل 9: البنية الدقيقة متعددة الدورات والخطية':[{question:\"كيف تختلف البنية الدقيقة متعددة الدورات عن تصميم الدورة الواحدة؟\",options:[\"تستغرق التعليمات دائمًا دورات أقل لإكمالها\",\"قد تمتد كل مرحلة من دورة التعليمات على عدة دورات ساعة\",\"تلغي الحاجة إلى وحدة تحكم\",\"تستخدم ناقل بيانات أصغر\"],correct:1,explanation:\"في بنية دقيقة متعددة الدورات، يمكن أن تستغرق كل مرحلة (الجلب، فك التشفير، إلخ) عدة دورات ساعة، مما يسمح بأوقات دورة أقصر.\"},{question:\"ما هي الميزة الرئيسية للآلات متعددة الدورات على الآلات ذات الدورة الواحدة؟\",options:[\"تحدد أبطأ تعليمة وقت الدورة\",\"وقت دورة الساعة أقصر لأنه يعتمد على أبطأ مرحلة، وليس التعليمات\",\"لا تتطلب إشارات تحكم\",\"جميع التعليمات تنفذ بالتوازي\"],correct:1,explanation:\"تقوم الآلات متعددة الدورات بتقسيم التعليمات إلى مراحل، مما يسمح بتحديد وقت دورة الساعة بواسطة أبطأ مرحلة بدلاً من أبطأ تعليمة.\"},{question:\"أي مكون يولد إشارات التحكم لتنسيق مسار البيانات في معالجة التعليمات؟\",\"خيارات\":[\"ALU\",\"ذاكرة التخزين المؤقت\",\"منطق التحكم\",\"ناقل العنوان\"],correct:2,explanation:\"يفك تشفير منطق التحكم التعليمات ويولد إشارات لتوجيه مسار البيانات (مثل ALU، السجلات) حول كيفية معالجة البيانات.\"},{question:\"ماذا يحدث لعداد البرنامج (PC) أثناء مرحلة الجلب؟\",options:[\"يتم إعادة تعيينه إلى الصفر\",\"يتم زيادته ليشير إلى التعليمات التالية\",\"يخزن نتيجة عملية ALU\",\"يحتفظ برمز التشغيل لفك التشفير\"],correct:1,explanation:\"بعد جلب التعليمات، يتم زيادة عداد البرنامج ليشير إلى التعليمات التالية في الذاكرة.\"},{question:\"أي مما يلي صحيح حول مرحلة التنفيذ؟\",options:[\"تسترد التعليمات من الذاكرة الرئيسية\",\"تفك تشفير رمز التشغيل إلى إشارات تحكم\",\"تنفذ العملية الفعلية (مثل حساب ALU)\",\"تخزن النتيجة في سجل التعليمات\"],correct:2,explanation:\"تنفذ مرحلة التنفيذ العملية المحددة بواسطة التعليمات، مثل العمليات الحسابية في ALU أو نقل البيانات.\"}],'الفصل 10: مقدمة في البنية الدقيقة':[{question:\"ما هي السمة الرئيسية للبنية الدقيقة ذات الدورة الواحدة؟\",options:[\"تكمل جميع التعليمات التنفيذ في دورة ساعة واحدة\",\"يتم تقسيم التعليمات على عدة دورات\",\"فقط تعليمات الحساب تستخدم دورة واحدة\",\"يستغرق الوصول إلى الذاكرة دورات متغيرة حسب زمن الوصول\"],correct:0,explanation:\"في البنية الدقيقة ذات الدورة الواحدة، تكمل كل تعليمة (مثل ALU، تحميل/تخزين) جميع المراحل (الجلب، فك التشفير، التنفيذ، إلخ) ضمن دورة ساعة واحدة.\"},{question:\"أي مكون مسؤول عن الاحتفاظ بعنوان التعليمات الحالية في مسار البيانات ذي الدورة الواحدة؟\",options:[\"ملف السجل\",\"عداد البرنامج (PC)\",\"ALU\",\"ذاكرة البيانات\"],correct:1,explanation:\"يخزن عداد البرنامج (PC) عنوان التعليمات الحالية التي يتم تنفيذها ويزداد بمقدار 4 (لـ MIPS) بعد كل جلب.\"},{question:\"ما هو دور وحدة 'تمديد الإشارة' في مسار البيانات؟\",options:[\"لتحويل القيم الفورية ذات 16 بت إلى قيم موقعة 32 بت\",\"لإجراء عمليات حسابية\",\"للاختيار بين سجل أو معاملات فورية\",\"لإدارة عناوين الذاكرة\"],correct:0,explanation:\"تقوم وحدة تمديد الإشارة بتوسيع القيم الفورية ذات 16 بت (على سبيل المثال، في تعليمات I-type) إلى 32 بت مع الحفاظ على الإشارة لعمليات حسابية صحيحة.\"},{question:\"أي إشارة تحكم تحدد ما إذا كانت ALU تستخدم قيمة سجل أو قيمة فورية كمعاملها الثاني؟\",options:[\"RegWrite\",\"ALUSrc\",\"MemtoReg\",\"Branch\"],correct:1,explanation:\"تختار ALUSrc بين معامل السجل الثاني (على سبيل المثال، لـ R-type) أو قيمة فورية ممتدة الإشارة (على سبيل المثال، لـ ADDI/LW/SW).\"},{question:\"ماذا يحدث أثناء مرحلة 'MEM' لتعليمات LW؟\",options:[\"تحسب ALU عنوان الذاكرة الفعلي\",\"يتم قراءة البيانات من الذاكرة وكتابتها في سجل\",\"يتم جلب التعليمات من الذاكرة\",\"يتم تحديث PC\"],correct:1,explanation:\"في مرحلة MEM، يتم الوصول إلى ذاكرة البيانات باستخدام العنوان المحسوب في EX، ويتم كتابة النتيجة لاحقًا إلى سجل في WB.\"},{question:\"أي نوع تعليمات يتطلب إشارة التحكم 'RegDst' لتحديد سجل الوجهة من البتات [15:11]؟\",options:[\"I-type (على سبيل المثال، ADDI)\",\"R-type (على سبيل المثال، ADD)\",\"Load (على سبيل المثال، LW)\",\"Store (على سبيل المثال، SW)\"],correct:1,explanation:\"تستخدم تعليمات R-type البتات [15:11] لسجل الوجهة (rd)، بينما تستخدم I-type (على سبيل المثال، ADDI/LW) البتات [20:16] (rt).\"},{question:\"لماذا تصميم الدورة الواحدة غير فعال للتطبيقات الواقعية؟\",options:[\"لا يمكنه التعامل مع تعليمات التفرع\",\"يجب أن تستوعب دورة الساعة أبطأ تعليمة (على سبيل المثال، LW)\",\"يفتقر إلى ملف سجل\",\"وصول الذاكرة غير متزامن\"],correct:1,explanation:\"يتم تحديد طول دورة الساعة بواسطة أبطأ تعليمة (مثل LW، التي تستخدم الوصول إلى الذاكرة)، مما يجعل التعليمات الأسرع (مثل ADD) بطيئة بشكل غير ضروري.\"},{question:\"ما هو الغرض من مضاعف 'MemtoReg' في مسار البيانات؟\",options:[\"للاختيار بين نتيجة ALU أو بيانات الذاكرة للكتابة الخلفية إلى السجل\",\"للاختيار بين معاملات السجل\",\"لتمديد القيم الفورية\",\"لحساب أهداف التفرع\"],correct:0,explanation:\"تختار MemtoReg ما إذا كانت بيانات الكتابة الخلفية تأتي من نتيجة ALU (على سبيل المثال، لـ ADD) أو الذاكرة (على سبيل المثال، لـ LW).\"}]};// Create a mapping between English and Arabic chapter names\nconst chapterMapping={// Add your English to Arabic mappings here.\n// IMPORTANT: The LEFT side (English) MUST EXACTLY match the keys in your `quizData`.\n// The RIGHT side (Arabic) MUST EXACTLY match the keys in your `quizDataArabic`.\n'Chapter 1: Introduction':'الفصل 1: مقدمة','Chapter 2: Storage Environment and RAID':'الفصل 2: بيئة التخزين و RAID','Chapter 3: Computer Architecture Introduction and Basics':'الفصل 3: مقدمة وهياكل الكمبيوتر الأساسية','Chapter 4: Introduction and Basics':'الفصل 4: مقدمة وأساسيات','Chapter 5: What is A Computer and Von Neumann Model':'الفصل 5: ما هو الكمبيوتر ونموذج فون نيومان','Chapter 6: Introduction to ISA Tradeoffs':'الفصل 6: مقدمة في المقايضات في ISA','Chapter 7: ISA Tradeoffs':'الفصل 7: المقايضات في ISA','Chapter 8: Single-Cycle Microarchitecture':'الفصل 8: البنية الدقيقة ذات الدورة الواحدة','Chapter 9: Multi-Cycle and Pipelined Microarchitecture':'الفصل 9: البنية الدقيقة متعددة الدورات والخطية','Chapter 10: Introduction to Microarchitecture':'الفصل 10: مقدمة في البنية الدقيقة'};// Reverse mapping (Arabic to English)\nconst reverseChapterMapping={};Object.keys(chapterMapping).forEach(englishName=>{reverseChapterMapping[chapterMapping[englishName]]=englishName;});export{quizData,quizDataArabic,chapterMapping,reverseChapterMapping};","map":{"version":3,"names":["quizData","question","options","correct","explanation","quizDataArabic","chapterMapping","reverseChapterMapping","Object","keys","forEach","englishName"],"sources":["/Users/abameda/Downloads/CA_QUIZZ/src/data/questions.js"],"sourcesContent":["const quizData = {\n'Chapter 1: Introduction': [\n    {\n      question: \"What is the main distinction between computer architecture and computer organization?\",\n      options: [\n        \"Architecture deals with hardware, organization deals with software\",\n        \"Architecture refers to attributes visible to programmer, organization refers to how features are implemented\",\n        \"Architecture is about performance, organization is about cost\",\n        \"There is no distinction between them\"\n      ],\n      correct: 1,\n      explanation: \"Architecture includes instruction set, data representation, I/O mechanisms - what's visible to programmers. Organization covers control signals, interfaces, memory technology - the implementation details.\"\n    },\n    {\n      question: \"Which of the following is NOT one of the four basic computer functions?\",\n      options: [\n        \"Data processing\",\n        \"Data storage\", \n        \"Data compilation\",\n        \"Data movement\"\n      ],\n      correct: 2,\n      explanation: \"The four basic functions are: data processing, data storage, data movement, and control. Data compilation is a software process, not a basic computer function.\"\n    },\n    {\n      question: \"What does the Program Counter (PC) register contain?\",\n      options: [\n        \"The current instruction being executed\",\n        \"The address of the next instruction pair to be fetched\",\n        \"The result of the last arithmetic operation\",\n        \"The memory address being accessed\"\n      ],\n      correct: 1,\n      explanation: \"The Program Counter (PC) contains the address of the next instruction pair to be fetched from memory.\"\n    },\n    {\n      question: \"In a multicore system, what is a 'core'?\",\n      options: [\n        \"The entire CPU chip\",\n        \"An individual processing unit on a processor chip\",\n        \"The system bus connecting components\",\n        \"The cache memory hierarchy\"\n      ],\n      correct: 1,\n      explanation: \"A core is an individual processing unit on a processor chip, which may be equivalent in functionality to a CPU on a single-CPU system.\"\n    },\n    {\n      question: \"What is the relationship between clock frequency and clock cycle time?\",\n      options: [\n        \"They are the same thing\",\n        \"Clock cycle time = clock frequency × 2\",\n        \"Clock cycle time = 1 / clock frequency\",\n        \"There is no mathematical relationship\"\n      ],\n      correct: 2,\n      explanation: \"Clock cycle time is the reciprocal of clock frequency. For example, an 800 MHz clock has a cycle time of 1.25 ns.\"\n    },\n    {\n      question: \"Which component manages the computer's resources and orchestrates performance?\",\n      options: [\n        \"ALU (Arithmetic Logic Unit)\",\n        \"Memory\",\n        \"Control Unit\",\n        \"Registers\"\n      ],\n      correct: 2,\n      explanation: \"The control unit manages the computer's resources and orchestrates the performance of its functional parts in response to instructions.\"\n    },\n    {\n      question: \"What is the primary purpose of cache memory?\",\n      options: [\n        \"To store the operating system\",\n        \"To backup main memory\",\n        \"To speed up memory access by storing likely-to-be-used data\",\n        \"To control input/output operations\"\n      ],\n      correct: 2,\n      explanation: \"Cache memory is smaller and faster than main memory, used to speed up memory access by placing data from main memory that is likely to be used in the near future.\"\n    },\n    {\n      question: \"Which register contains the 8-bit opcode instruction being executed?\",\n      options: [\n        \"Program Counter (PC)\",\n        \"Instruction Register (IR)\",\n        \"Memory Address Register (MAR)\",\n        \"Accumulator (AC)\"\n      ],\n      correct: 1,\n      explanation: \"The Instruction Register (IR) contains the 8-bit opcode instruction being executed.\"\n    },\n    {\n      question: \"What is the function of the Memory Address Register (MAR)?\",\n      options: [\n        \"Contains the instruction being executed\",\n        \"Stores temporary data for ALU operations\",\n        \"Specifies the address in memory of the word to be written or read\",\n        \"Controls the sequence of operations\"\n      ],\n      correct: 2,\n      explanation: \"The Memory Address Register (MAR) specifies the address in memory of the word to be written from or read into the MBR.\"\n    },\n    {\n      question: \"In embedded systems, what characterizes 'deeply embedded systems'?\",\n      options: [\n        \"They run complex operating systems\",\n        \"They are programmable after deployment\",\n        \"They are dedicated to specific tasks with extreme resource constraints\",\n        \"They always have user interfaces\"\n      ],\n      correct: 2,\n      explanation: \"Deeply embedded systems are dedicated, single-purpose devices with extreme resource constraints in terms of memory, processor size, time, and power consumption.\"\n    },\n    {\n      question: \"What are the four main structural components of a computer?\",\n      options: [\n        \"CPU, RAM, ROM, Hard Drive\",\n        \"CPU, Main Memory, I/O, System Interconnection\",\n        \"Control Unit, ALU, Registers, Cache\",\n        \"Processor, Memory, Storage, Network\"\n      ],\n      correct: 1,\n      explanation: \"The four main structural components are: CPU (controls operation and data processing), Main Memory (stores data), I/O (moves data with external environment), and System Interconnection (communication mechanism).\"\n    },\n    {\n      question: \"What is the difference between response time and throughput?\",\n      options: [\n        \"They are the same metric\",\n        \"Response time is speed, throughput is accuracy\",\n        \"Response time is time for one task, throughput is tasks per unit time\",\n        \"Response time is for CPU, throughput is for memory\"\n      ],\n      correct: 2,\n      explanation: \"Response time is the time between start and completion of a task, while throughput is the total amount of tasks done in a given time period. There is generally no relationship between these metrics.\"\n    },\n    {\n      question: \"What does the Memory Buffer Register (MBR) contain?\",\n      options: [\n        \"The address of the next instruction\",\n        \"A word to be stored in memory or received from memory/I/O\",\n        \"The current instruction being decoded\",\n        \"Control signals for the ALU\"\n      ],\n      correct: 1,\n      explanation: \"The Memory Buffer Register (MBR) contains a word to be stored in memory or sent to the I/O unit, or is used to receive a word from memory or from the I/O unit.\"\n    },\n    {\n      question: \"Which generation of IoT deployment is characterized by billions of embedded devices?\",\n      options: [\n        \"Information Technology (IT)\",\n        \"Operational Technology (OT)\",\n        \"Personal Technology\",\n        \"Sensor/Actuator Technology\"\n      ],\n      correct: 3,\n      explanation: \"The fourth generation, Sensor/Actuator Technology, is usually thought of as the IoT and is marked by the use of billions of embedded devices using wireless connectivity.\"\n    },\n    {\n      question: \"What is the primary function of the Instruction Buffer Register (IBR)?\",\n      options: [\n        \"To store the program counter value\",\n        \"To temporarily hold the right-hand instruction from memory\",\n        \"To contain the address of data in memory\",\n        \"To store the result of arithmetic operations\"\n      ],\n      correct: 1,\n      explanation: \"The Instruction Buffer Register (IBR) is employed to temporarily hold the right-hand instruction from a word in memory.\"\n    },\n    {\n      question: \"In the context of data movement, what distinguishes I/O from data communications?\",\n      options: [\n        \"Speed of data transfer\",\n        \"Type of data being moved\",\n        \"Distance - I/O is direct connection, data communications is over longer distances\",\n        \"Security requirements\"\n      ],\n      correct: 2,\n      explanation: \"I/O occurs when data are received from or delivered to a device directly connected to the computer, while data communications involves moving data over longer distances to or from remote devices.\"\n    },\n    {\n      question: \"What is the key difference between application processors and dedicated processors in embedded systems?\",\n      options: [\n        \"Power consumption levels\",\n        \"Manufacturing cost\",\n        \"Application processors execute complex OS, dedicated processors serve specific tasks\",\n        \"Physical size differences\"\n      ],\n      correct: 2,\n      explanation: \"Application processors are defined by their ability to execute complex operating systems and are general-purpose, while dedicated processors are dedicated to one or a small number of specific tasks.\"\n    },\n    {\n      question: \"Which components provide the four basic functions of integrated circuits?\",\n      options: [\n        \"Transistors, resistors, capacitors, inductors\",\n        \"Gates (processing), memory cells (storage), paths (movement), control signals (control)\",\n        \"CPU, memory, I/O, interconnection\",\n        \"Hardware, software, firmware, middleware\"\n      ],\n      correct: 1,\n      explanation: \"In integrated circuits: gates provide data processing, memory cells provide data storage, paths provide data movement, and control signals provide control functions.\"\n    },\n    {\n      question: \"What advantage do Intel x86 and IBM System/370 families demonstrate?\",\n      options: [\n        \"Higher performance than competitors\",\n        \"Lower manufacturing costs\",\n        \"Code compatibility through shared basic architecture\",\n        \"Better power efficiency\"\n      ],\n      correct: 2,\n      explanation: \"All Intel x86 family and IBM System/370 family share the same basic architecture, which gives code compatibility (at least backwards), even though organization differs between versions.\"\n    },\n    {\n      question: \"In deeply embedded systems, what type of processor is typically used?\",\n      options: [\n        \"Microprocessor\",\n        \"Microcontroller\",\n        \"Graphics processor\",\n        \"Digital signal processor\"\n      ],\n      correct: 1,\n      explanation: \"Deeply embedded systems use a microcontroller rather than a microprocessor, are not programmable once the program logic has been burned into ROM, and have no interaction with a user.\"\n    },\n    {\n      question: \"What are the major structural components of a CPU?\",\n      options: [\n        \"Cache, registers, bus, clock\",\n        \"Control Unit, ALU, Registers, CPU Interconnection\",\n        \"Fetch unit, decode unit, execute unit, write-back unit\",\n        \"L1 cache, L2 cache, L3 cache, main memory interface\"\n      ],\n      correct: 1,\n      explanation: \"The CPU's major structural components are: Control Unit (controls CPU operation), ALU (performs data processing), Registers (provide internal storage), and CPU Interconnection (provides communication among components).\"\n    },\n    {\n      question: \"What characterizes embedded systems' interaction with their environment?\",\n      options: [\n        \"They operate independently of external factors\",\n        \"They are tightly coupled with real-time constraints\",\n        \"They only process stored data\",\n        \"They communicate only through network interfaces\"\n      ],\n      correct: 1,\n      explanation: \"Embedded systems are often tightly coupled to their environment, giving rise to real-time constraints imposed by the need to interact with the environment, such as required speeds, precision, and timing.\"\n    }\n  ],\n  'Chapter 2: Storage Environment and RAID': [\n  {\n    question: \"What is the main difference between memory modules and storage devices?\",\n    options: [\n      \"Memory modules are cheaper than storage devices\",\n      \"Memory modules use semiconductor chips while storage devices use magnetic or optical media\",\n      \"Storage devices are faster than memory modules\",\n      \"Memory modules are non-volatile while storage devices are volatile\"\n    ],\n    correct: 1,\n    explanation: \"Memory modules are implemented using semiconductor chips, whereas storage devices use either magnetic or optical media. Memory modules also enable data access at higher speed than storage media.\"\n  },\n  {\n    question: \"Which type of memory is volatile and requires constant power supply?\",\n    options: [\n      \"ROM (Read-Only Memory)\",\n      \"RAM (Random Access Memory)\", \n      \"Hard disk storage\",\n      \"CD-ROM storage\"\n    ],\n    correct: 1,\n    explanation: \"RAM is volatile and requires a constant supply of power to maintain memory cell content. Data is erased when the system's power is turned off or interrupted.\"\n  },\n  {\n    question: \"What does DAS stand for and how does it connect to servers?\",\n    options: [\n      \"Direct Access Storage - connects via network protocols\",\n      \"Distributed Array Storage - connects via fiber optic cables\",\n      \"Direct Attached Storage - connects directly through Host Bus Adapter (HBA)\",\n      \"Dynamic Allocation Storage - connects via USB only\"\n    ],\n    correct: 2,\n    explanation: \"DAS stands for Direct Attached Storage. It connects directly to a server through Host Bus Adapter (HBA), with no network between storage and host servers.\"\n  },\n  {\n    question: \"What is the main advantage of DAS over other storage environments?\",\n    options: [\n      \"Accessibility from multiple devices\",\n      \"Fast performance and simple setup\",\n      \"Network sharing capabilities\",\n      \"Lowest cost among all options\"\n    ],\n    correct: 1,\n    explanation: \"DAS offers fast performance, high capacity options, and simple setup as its main advantages.\"\n  },\n  {\n    question: \"What is the primary disadvantage of DAS?\",\n    options: [\n      \"Slow performance\",\n      \"High cost\",\n      \"Not accessible from other devices and prone to data loss if connected computer fails\",\n      \"Complex setup requirements\"\n    ],\n    correct: 2,\n    explanation: \"DAS is not accessible from other devices and is prone to data loss if the connected computer fails.\"\n  },\n  {\n    question: \"What does SAN stand for and what is its primary characteristic?\",\n    options: [\n      \"Storage Access Network - a wireless storage solution\",\n      \"System Area Network - connects only servers\",\n      \"Storage Area Networks - a dedicated data storage network accessible by multiple servers\",\n      \"Secure Access Network - provides encrypted storage\"\n    ],\n    correct: 2,\n    explanation: \"SAN stands for Storage Area Networks. It is a dedicated data storage network which can be accessed by multiple servers.\"\n  },\n  {\n    question: \"Which storage environment offers the fastest performance?\",\n    options: [\n      \"DAS\",\n      \"SAN\",\n      \"NAS\",\n      \"RAID\"\n    ],\n    correct: 1,\n    explanation: \"SAN offers the fastest performance among the options due to its dedicated network specifically designed for high-performance connections.\"\n  },\n  {\n    question: \"What are the main protocols used in SAN?\",\n    options: [\n      \"TCP/IP and HTTP\",\n      \"SCSI and SATA\",\n      \"USB and FireWire\",\n      \"Ethernet and WiFi\"\n    ],\n    correct: 1,\n    explanation: \"The protocols that are used in SAN are SCSI and SATA.\"\n  },\n  {\n    question: \"What is the main weakness of SAN mentioned in the document?\",\n    options: [\n      \"Speed and Latency\",\n      \"Security\",\n      \"Cost\",\n      \"Complexity\"\n    ],\n    correct: 1,\n    explanation: \"According to the document, the weakness of SAN is Security, while Speed and Latency are listed as disadvantages.\"\n  },\n  {\n    question: \"What does NAS stand for and at what level does it operate?\",\n    options: [\n      \"Network Access Storage - operates at block level\",\n      \"Network Attached Storage - operates at file level\",\n      \"Network Array Storage - operates at bit level\",\n      \"Network Administration Storage - operates at system level\"\n    ],\n    correct: 1,\n    explanation: \"NAS stands for Network Attached Storage. It is a file level computer data storage that connects to other devices on TCP/IP network.\"\n  },\n  {\n    question: \"Which component is NOT part of NAS architecture?\",\n    options: [\n      \"Head unit (CPU, Memory)\",\n      \"Network Interface Card (NIC)\",\n      \"Host Bus Adapter (HBA)\",\n      \"Optimized operating system\"\n    ],\n    correct: 2,\n    explanation: \"Host Bus Adapter (HBA) is a component of DAS, not NAS. NAS components include Head unit, NIC, optimized OS, protocols, and storage protocols.\"\n  },\n  {\n    question: \"What does RAID stand for?\",\n    options: [\n      \"Random Array of Independent Disks\",\n      \"Redundant Array of Independent Disks\",\n      \"Reliable Array of Integrated Disks\",\n      \"Rapid Access of Internal Disks\"\n    ],\n    correct: 1,\n    explanation: \"RAID stands for Redundant Array of Independent Disks.\"\n  },\n  {\n    question: \"Which RAID function writes consecutive logical blocks on consecutive physical disks?\",\n    options: [\n      \"Mirroring\",\n      \"Striping\",\n      \"Parity Calculation\",\n      \"Synchronization\"\n    ],\n    correct: 1,\n    explanation: \"Striping writes consecutive logical byte/blocks on consecutive physical disks.\"\n  },\n  {\n    question: \"Which RAID level provides striping with no parity or redundancy?\",\n    options: [\n      \"RAID 1\",\n      \"RAID 0\",\n      \"RAID 5\",\n      \"RAID 10\"\n    ],\n    correct: 1,\n    explanation: \"RAID 0 provides stripe with no parity, offering excellent performance but no redundancy.\"\n  },\n  {\n    question: \"What is the minimum number of disks required for RAID 1?\",\n    options: [\n      \"1 disk\",\n      \"2 disks\",\n      \"3 disks\",\n      \"4 disks\"\n    ],\n    correct: 1,\n    explanation: \"RAID 1 requires a minimum of 2 disks and provides excellent redundancy as blocks are mirrored.\"\n  },\n  {\n    question: \"Which RAID level is described as 'stripe of mirrors'?\",\n    options: [\n      \"RAID 0+1\",\n      \"RAID 5\",\n      \"RAID 10\",\n      \"RAID 6\"\n    ],\n    correct: 2,\n    explanation: \"RAID 10 is also called 'stripe of mirrors' and requires a minimum of 4 disks.\"\n  },\n  {\n    question: \"What is the minimum number of disks required for RAID 5?\",\n    options: [\n      \"2 disks\",\n      \"3 disks\",\n      \"4 disks\",\n      \"5 disks\"\n    ],\n    correct: 1,\n    explanation: \"RAID 5 requires a minimum of 3 disks and provides good performance with distributed parity.\"\n  },\n  {\n    question: \"Which RAID level uses byte-level striping?\",\n    options: [\n      \"RAID 3\",\n      \"RAID 4\",\n      \"RAID 5\",\n      \"RAID 6\"\n    ],\n    correct: 0,\n    explanation: \"RAID 3 uses byte level striping, while RAID 4 uses block level striping.\"\n  },\n  {\n    question: \"What makes RAID 6 different from RAID 5?\",\n    options: [\n      \"It uses striping instead of mirroring\",\n      \"It has double parity blocks and requires 6 disks\",\n      \"It provides better performance\",\n      \"It uses fewer disks\"\n    ],\n    correct: 1,\n    explanation: \"RAID 6 is similar to RAID 5 except it has double parity blocks and requires 6 disks.\"\n  },\n  {\n    question: \"Which RAID level is recommended for heavily read-oriented databases?\",\n    options: [\n      \"RAID 0\",\n      \"RAID 1\",\n      \"RAID 5\",\n      \"RAID 10\"\n    ],\n    correct: 2,\n    explanation: \"RAID 5 is the best cost effective option providing both performance and redundancy, recommended for databases that are heavily read oriented, though write operations will be slow.\"\n  },\n  {\n    question: \"Which RAID level is considered the BEST option for mission critical applications?\",\n    options: [\n      \"RAID 0\",\n      \"RAID 5\",\n      \"RAID 6\",\n      \"RAID 10\"\n    ],\n    correct: 3,\n    explanation: \"RAID 10 provides excellent redundancy and excellent performance. If you can afford it, this is the BEST option for any mission critical applications, especially databases.\"\n  },\n  {\n    question: \"Which storage environment would be best for a single user storing personal files?\",\n    options: [\n      \"DAS\",\n      \"SAN\",\n      \"NAS\",\n      \"RAID\"\n    ],\n    correct: 0,\n    explanation: \"DAS is best for individual workstations and storing personal data due to its fast performance and simple setup.\"\n  },\n  {\n    question: \"Which storage environment is most suitable for small businesses with multiple employees sharing files?\",\n    options: [\n      \"DAS\",\n      \"SAN\", \n      \"NAS\",\n      \"RAID\"\n    ],\n    correct: 2,\n    explanation: \"NAS is best for small businesses and workgroups as it provides shared storage accessible from multiple devices on the network.\"\n  },\n  {\n    question: \"Which storage environment requires the most technical expertise to manage?\",\n    options: [\n      \"DAS\",\n      \"SAN\",\n      \"NAS\", \n      \"RAID\"\n    ],\n    correct: 1,\n    explanation: \"SAN requires significant technical expertise to manage due to its specialized hardware and complex configuration.\"\n  },\n  {\n    question: \"In terms of cost ranking from lowest to highest, what is the correct order?\",\n    options: [\n      \"SAN, NAS, DAS\",\n      \"DAS, NAS, SAN\",\n      \"NAS, DAS, SAN\",\n      \"DAS, SAN, NAS\"\n    ],\n    correct: 1,\n    explanation: \"DAS is generally the cheapest, followed by NAS, then SAN is the most expensive due to specialized hardware and configuration.\"\n  },\n  {\n    question: \"Which statement about RAID is TRUE?\",\n    options: [\n      \"RAID guarantees complete data protection against any failure\",\n      \"All RAID levels offer the same level of performance and redundancy\",\n      \"RAID can be implemented on both DAS and NAS systems\",\n      \"Using RAID eliminates the need for backups\"\n    ],\n    correct: 2,\n    explanation: \"RAID can be implemented on both DAS and NAS systems for added benefits. RAID does not guarantee complete protection, levels differ in performance/redundancy, and backups are still needed.\"\n  },\n  {\n    question: \"What type of data access does SAN provide?\",\n    options: [\n      \"File level data access\",\n      \"Block level data storage\",\n      \"Byte level data access\",\n      \"Application level data access\"\n    ],\n    correct: 1,\n    explanation: \"SAN provides block level data storage, allowing multiple clients to access files at the same time with very high performance.\"\n  },\n  {\n    question: \"Which benefit is NOT associated with NAS?\",\n    options: [\n      \"Relatively inexpensive\",\n      \"24/7 and remote data availability\",\n      \"Fastest performance among storage options\",\n      \"Automatic backups to other devices and cloud\"\n    ],\n    correct: 2,\n    explanation: \"NAS has slower performance compared to DAS due to network overhead. The fastest performance is provided by SAN.\"\n  },\n  {\n    question: \"What happens to RAM data when power is interrupted?\",\n    options: [\n      \"Data is automatically backed up\",\n      \"Data remains intact\",\n      \"Data is erased\",\n      \"Data is transferred to ROM\"\n    ],\n    correct: 2,\n    explanation: \"RAM is volatile and requires constant power supply. Data is erased when the system's power is turned off or interrupted.\"\n  },\n  {\n    question: \"Which RAID level should NOT be used for critical systems?\",\n    options: [\n      \"RAID 0\",\n      \"RAID 1\", \n      \"RAID 5\",\n      \"RAID 10\"\n    ],\n    correct: 0,\n    explanation: \"RAID 0 has no redundancy (no mirror, no parity), so it should not be used for any critical system despite its excellent performance.\"\n  }\n],\n'Chapter 3: Computer Architecture Introduction and Basics': [\n  {\n    question: \"What is the main purpose of computing according to Richard Hamming?\",\n    options: [\n      \"To generate numbers and data\",\n      \"To provide insight, not just numbers\",\n      \"To execute instructions efficiently\",\n      \"To solve mathematical equations\"\n    ],\n    correct: 1,\n    explanation: \"According to Richard Hamming, 'The purpose of computing is insight, not numbers.' The true value of computing lies in using data to gain understanding and knowledge (insight).\"\n  },\n  {\n    question: \"Which transformation level is directly above Logic in the hierarchy?\",\n    options: [\n      \"Circuits\",\n      \"Microarchitecture\", \n      \"ISA (Architecture)\",\n      \"Runtime System\"\n    ],\n    correct: 1,\n    explanation: \"In the levels of transformation hierarchy, Microarchitecture is directly above Logic, which is above Circuits.\"\n  },\n  {\n    question: \"What is abstraction in the context of computer systems?\",\n    options: [\n      \"A method to hide implementation details from users\",\n      \"A higher level only needs to know the interface to the lower level, not how it's implemented\",\n      \"A way to make programs run faster\",\n      \"A technique for optimizing hardware design\"\n    ],\n    correct: 1,\n    explanation: \"Abstraction means a higher level only needs to know about the interface to the lower level, not how the lower level is implemented.\"\n  },\n  {\n    question: \"Why might you need to understand what happens in underlying abstraction levels?\",\n    options: [\n      \"Only for academic purposes\",\n      \"When programs run slow, consume too much energy, or don't run correctly\",\n      \"To impress colleagues with technical knowledge\",\n      \"It's never necessary in modern computing\"\n    ],\n    correct: 1,\n    explanation: \"You need to understand underlying levels when programs run slow, consume too much energy, don't run correctly, or when designing more efficient systems.\"\n  },\n  {\n    question: \"What are the two key goals of the computer architecture course mentioned?\",\n    options: [\n      \"Learn programming and hardware design\",\n      \"Understand processor internals and make cross-layer optimization decisions\",\n      \"Master assembly language and digital logic\",\n      \"Study algorithms and data structures\"\n    ],\n    correct: 1,\n    explanation: \"The two key goals are: understand how a processor works underneath the software layer and how hardware decisions affect software/programmers, and enable making design decisions that cross boundaries of different layers.\"\n  },\n  {\n    question: \"In the multi-core system slowdown example, what causes the disparity in performance between applications?\",\n    options: [\n      \"CPU scheduling policies\",\n      \"Cache miss rates\",\n      \"DRAM controller scheduling unfairness\",\n      \"Network latency\"\n    ],\n    correct: 2,\n    explanation: \"The disparity is caused by DRAM controller scheduling policies that are unfair to some applications, particularly the row-hit first and oldest-first policies.\"\n  },\n  {\n    question: \"What does a row-conflict memory access result in compared to a row-hit access?\",\n    options: [\n      \"Faster access time\",\n      \"Same access time\",\n      \"Significantly longer access time\",\n      \"Slightly longer access time\"\n    ],\n    correct: 2,\n    explanation: \"A row-conflict memory access takes significantly longer than a row-hit access.\"\n  },\n  {\n    question: \"What does FR-FCFS stand for in DRAM controller scheduling?\",\n    options: [\n      \"Fast-Ready, First-Come-First-Service\",\n      \"First-Ready, First-Come-First-Service\", \n      \"First-Row, First-Column-First-Service\",\n      \"Fast-Row, First-Cache-First-Service\"\n    ],\n    correct: 1,\n    explanation: \"FR-FCFS stands for First-Ready, First-Come-First-Service, which prioritizes row-hit accesses first, then older accesses first.\"\n  },\n  {\n    question: \"Which application type does the row-hit first policy unfairly prioritize?\",\n    options: [\n      \"CPU-intensive applications\",\n      \"Applications with high row buffer locality\",\n      \"Applications with random memory access\",\n      \"Applications with low memory usage\"\n    ],\n    correct: 1,\n    explanation: \"Row-hit first policy unfairly prioritizes applications with high row buffer locality - threads that keep accessing the same row.\"\n  },\n  {\n    question: \"What is the difference between STREAM and RANDOM memory access patterns?\",\n    options: [\n      \"STREAM is faster, RANDOM is slower\",\n      \"STREAM has sequential access with high row buffer locality, RANDOM has random access with low row buffer locality\",\n      \"STREAM uses more memory, RANDOM uses less\",\n      \"STREAM is for reading, RANDOM is for writing\"\n    ],\n    correct: 1,\n    explanation: \"STREAM has sequential memory access with very high row buffer locality (96% hit rate), while RANDOM has random memory access with very low row buffer locality (3% hit rate).\"\n  },\n  {\n    question: \"What does a DRAM cell consist of?\",\n    options: [\n      \"Two transistors and a resistor\",\n      \"A capacitor and an access transistor\",\n      \"A flip-flop circuit\",\n      \"Multiple logic gates\"\n    ],\n    correct: 1,\n    explanation: \"A DRAM cell consists of a capacitor and an access transistor. It stores data in terms of charge in the capacitor.\"\n  },\n  {\n    question: \"Why does DRAM need to be refreshed periodically?\",\n    options: [\n      \"To prevent data corruption from electromagnetic interference\",\n      \"Because the capacitor charge leaks over time\",\n      \"To maintain synchronization with the CPU clock\",\n      \"To update the stored data\"\n    ],\n    correct: 1,\n    explanation: \"DRAM capacitor charge leaks over time, so the memory controller needs to refresh each row periodically to restore charge.\"\n  },\n  {\n    question: \"What is the typical refresh period for DRAM?\",\n    options: [\n      \"64 microseconds\",\n      \"64 milliseconds\",\n      \"64 seconds\", \n      \"64 nanoseconds\"\n    ],\n    correct: 1,\n    explanation: \"The typical refresh period is 64 ms - each row needs to be activated every 64 milliseconds.\"\n  },\n  {\n    question: \"What are the downsides of DRAM refresh mentioned in the document?\",\n    options: [\n      \"Only energy consumption\",\n      \"Energy consumption, performance degradation, QoS impact, and capacity scaling limits\",\n      \"Only performance degradation\",\n      \"Only capacity limitations\"\n    ],\n    correct: 1,\n    explanation: \"DRAM refresh downsides include: energy consumption, performance degradation (DRAM unavailable during refresh), QoS/predictability impact (pause times), and refresh rate limits DRAM capacity scaling.\"\n  },\n  {\n    question: \"According to the RAIDR research, what percentage of refresh reduction was achieved?\",\n    options: [\n      \"46.8%\",\n      \"74.6%\",\n      \"15.2%\",\n      \"84.3%\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR achieved 74.6% refresh reduction with only 1.25KB storage overhead for 32GB memory.\"\n  },\n  {\n    question: \"What is the key observation behind the RAIDR approach?\",\n    options: [\n      \"All DRAM rows need frequent refresh\",\n      \"Most DRAM rows can be refreshed much less often without losing data\",\n      \"DRAM refresh is unnecessary\",\n      \"Refresh frequency should be increased\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR's key observation is that most DRAM rows can be refreshed much less often without losing data, allowing for different refresh rates for different rows.\"\n  },\n  {\n    question: \"What are the three main steps in the RAIDR approach?\",\n    options: [\n      \"Reading, Writing, Refreshing\",\n      \"Profiling, Binning, Refreshing\",\n      \"Measuring, Sorting, Optimizing\",\n      \"Testing, Grouping, Scheduling\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR uses three steps: 1) Profiling retention time of all rows, 2) Binning rows by retention time using Bloom Filters, 3) Refreshing rows in different bins at different rates.\"\n  },\n  {\n    question: \"How much storage overhead does RAIDR require for 32GB memory?\",\n    options: [\n      \"1.25MB\",\n      \"1.25KB\",\n      \"12.5KB\",\n      \"125KB\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR requires only 1.25KB storage for 32GB memory using efficient storage with Bloom Filters.\"\n  },\n  {\n    question: \"What performance improvement did RAIDR achieve?\",\n    options: [\n      \"~5%\",\n      \"~9%\",\n      \"~16%\",\n      \"~20%\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR achieved approximately 9% performance improvement along with 16%/20% DRAM dynamic/idle power reduction.\"\n  },\n  {\n    question: \"In the memory hog example, what happens when T0 (STREAM) and T1 (RANDOM) compete for memory access?\",\n    options: [\n      \"They get equal access\",\n      \"T1 gets prioritized due to oldest-first policy\",\n      \"128 requests of T0 are serviced before T1 due to row buffer locality\",\n      \"Random scheduling occurs\"\n    ],\n    correct: 2,\n    explanation: \"Due to row buffer locality, 128 requests of T0 (STREAM) are serviced before T1 (RANDOM) gets access, since T0 keeps hitting the same row while T1 causes row conflicts.\"\n  },\n  {\n    question: \"What is the main takeaway about abstraction layers from this chapter?\",\n    options: [\n      \"Abstraction layers should never be broken\",\n      \"Breaking abstraction layers and knowing what's underneath enables problem solving and better system design\",\n      \"Only hardware designers need to understand multiple layers\",\n      \"Abstraction layers are only important for software development\"\n    ],\n    correct: 1,\n    explanation: \"The main takeaway is that breaking abstraction layers and knowing what happens underneath enables you to solve problems and design better future systems.\"\n  },\n  {\n    question: \"Which component in a multi-core system is shared among all cores?\",\n    options: [\n      \"L2 Cache\",\n      \"L3 Cache and DRAM Memory Controller\",\n      \"CPU registers\",\n      \"Instruction decoder\"\n    ],\n    correct: 1,\n    explanation: \"In the multi-core system diagram, the Shared L3 Cache and DRAM Memory Controller are shared among all cores, while each core has its own L2 cache.\"\n  },\n  {\n    question: \"What makes the DRAM controller vulnerable to denial of service attacks?\",\n    options: [\n      \"Poor encryption mechanisms\",\n      \"Unfair scheduling policies that can be exploited by specially written programs\",\n      \"Insufficient bandwidth\",\n      \"Hardware design flaws\"\n    ],\n    correct: 1,\n    explanation: \"DRAM scheduling policies are unfair to some applications, and programs can be written to exploit this unfairness, making the controller vulnerable to denial of service attacks.\"\n  },\n  {\n    question: \"What is the row size mentioned in the memory hog example?\",\n    options: [\n      \"4KB\",\n      \"8KB\",\n      \"16KB\",\n      \"32KB\"\n    ],\n    correct: 1,\n    explanation: \"In the memory hog example, the row size is 8KB and cache block size is 64B, resulting in 128 (8KB/64B) requests.\"\n  },\n  {\n    question: \"According to the refresh overhead graphs, what percentage of performance overhead can refresh cause?\",\n    options: [\n      \"Up to 8%\",\n      \"Up to 46%\",\n      \"Up to 15%\",\n      \"Up to 47%\"\n    ],\n    correct: 1,\n    explanation: \"According to the refresh overhead performance graph, DRAM refresh can cause up to 46% performance overhead.\"\n  },\n  {\n    question: \"What cooperation approach does the chapter suggest for solving complex system problems?\",\n    options: [\n      \"Hardware-only solutions\",\n      \"Software-only solutions\",\n      \"Cooperation between multiple components and layers\",\n      \"Operating system level solutions only\"\n    ],\n    correct: 2,\n    explanation: \"The chapter emphasizes that cooperation between multiple components and layers can enable more effective solutions and systems.\"\n  },\n  {\n    question: \"In the levels of transformation, what is at the bottom of the hierarchy?\",\n    options: [\n      \"Logic\",\n      \"Circuits\",\n      \"Electrons\",\n      \"Microarchitecture\"\n    ],\n    correct: 2,\n    explanation: \"In the levels of transformation hierarchy, Electrons is at the bottom, representing the most fundamental physical level.\"\n  },\n  {\n    question: \"What does the course aim to enable students to do regarding design decisions?\",\n    options: [\n      \"Make decisions within single layers only\",\n      \"Focus only on software optimization\",\n      \"Make design and optimization decisions that cross boundaries of different layers\",\n      \"Specialize in one specific layer\"\n    ],\n    correct: 2,\n    explanation: \"The course aims to enable students to be comfortable making design and optimization decisions that cross the boundaries of different layers and system components.\"\n  },\n  {\n    question: \"What information does RAIDR expose to solve the refresh problem?\",\n    options: [\n      \"CPU utilization patterns\",\n      \"Retention time profile information of DRAM rows\",\n      \"Cache miss rates\",\n      \"Network traffic patterns\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR exposes retention time profile information of DRAM rows to the memory controller, enabling different refresh rates for different rows based on their retention characteristics.\"\n  },\n  {\n    question: \"What is the relationship between the programmer's view and hardware designer's view in computer systems?\",\n    options: [\n      \"They are completely independent\",\n      \"Only the programmer's view matters\",\n      \"The architect/microarchitect's choices critically affect both views\",\n      \"Only the hardware designer's view is important\"\n    ],\n    correct: 2,\n    explanation: \"The architect/microarchitect's view involves designing computers that meet system design goals, and these choices critically affect both the software programmer and the hardware designer.\"\n  }\n],\n'Chapter 4: Introduction and Basics': [\n  {\n    question: \"According to Richard Hamming, what is the purpose of computing?\",\n    options: [\n      \"To generate numbers and data\",\n      \"To solve mathematical equations\",\n      \"To gain insight, not numbers\",\n      \"To process information quickly\"\n    ],\n    correct: 2,\n    explanation: \"Richard Hamming stated that 'The purpose of computing is insight, not numbers'. The true value of computing lies not just in generating numbers (data), but in using that data to gain understanding and knowledge (insight).\"\n  },\n  {\n    question: \"What are the levels of transformation in computer systems from top to bottom?\",\n    options: [\n      \"Problem → Algorithm → Program → ISA → Microarchitecture → Logic → Circuits → Electrons\",\n      \"Algorithm → Problem → Program → ISA → Logic → Microarchitecture → Circuits → Electrons\",\n      \"Problem → Program → Algorithm → ISA → Microarchitecture → Logic → Circuits → Electrons\",\n      \"Problem → Algorithm → ISA → Program → Microarchitecture → Logic → Circuits → Electrons\"\n    ],\n    correct: 0,\n    explanation: \"The correct hierarchy is: Problem → Algorithm → Program/Language → Runtime System → ISA (Architecture) → Microarchitecture → Logic → Circuits → Electrons, representing the transformation from high-level problems to physical implementation.\"\n  },\n  {\n    question: \"What is abstraction in the context of computer systems?\",\n    options: [\n      \"A method to make systems more complex\",\n      \"A higher level only needs to know about the interface to the lower level, not how it's implemented\",\n      \"A way to combine multiple levels into one\",\n      \"A technique to eliminate unnecessary components\"\n    ],\n    correct: 1,\n    explanation: \"Abstraction means that a higher level only needs to know about the interface to the lower level, not how the lower level is implemented. For example, a high-level language programmer doesn't need to know what the ISA is or how a computer executes instructions.\"\n  },\n  {\n    question: \"Why might you need to understand what happens in underlying abstraction layers?\",\n    options: [\n      \"Only for academic purposes\",\n      \"When programs run slow, incorrectly, or consume too much energy\",\n      \"To make programming more difficult\",\n      \"It's never necessary to understand underlying layers\"\n    ],\n    correct: 1,\n    explanation: \"Understanding underlying layers becomes crucial when: the program runs slow, doesn't run correctly, consumes too much energy, or when designing more efficient and higher performance systems.\"\n  },\n  {\n    question: \"In the multi-core system memory performance attack example, what causes the disparity in slowdowns between applications?\",\n    options: [\n      \"Different CPU speeds\",\n      \"Cache size differences\",\n      \"DRAM scheduling policy unfairness due to row buffer locality\",\n      \"Operating system scheduling\"\n    ],\n    correct: 2,\n    explanation: \"The disparity is caused by DRAM scheduling policies being unfair to some applications. Row-hit first policy unfairly prioritizes apps with high row buffer locality, while oldest-first unfairly prioritizes memory-intensive applications.\"\n  },\n  {\n    question: \"What is the FR-FCFS scheduling policy in DRAM controllers?\",\n    options: [\n      \"First-Request, First-Come-First-Service\",\n      \"First-Ready, First-Come-First-Service\",\n      \"First-Row, First-Column-First-Service\",\n      \"Fast-Response, First-Come-First-Service\"\n    ],\n    correct: 1,\n    explanation: \"FR-FCFS stands for First-Ready, First-Come-First-Service. It has two rules: (1) Row-hit first: Service row-hit memory accesses first, (2) Oldest-first: Then service older accesses first.\"\n  },\n  {\n    question: \"What makes a DRAM row-conflict access significantly slower than a row-hit access?\",\n    options: [\n      \"CPU processing delays\",\n      \"Cache miss penalties\",\n      \"Need to close current row and open new row in DRAM\",\n      \"Network latency\"\n    ],\n    correct: 2,\n    explanation: \"A row-conflict access requires closing the currently open row and opening a new row in DRAM, which takes significantly longer than accessing data from an already open row (row-hit).\"\n  },\n  {\n    question: \"In the memory performance hog example, what characterizes the STREAM access pattern?\",\n    options: [\n      \"Random memory access with low row buffer locality\",\n      \"Sequential memory access with very high row buffer locality (96% hit rate)\",\n      \"Scattered memory access with medium locality\",\n      \"Circular memory access pattern\"\n    ],\n    correct: 1,\n    explanation: \"STREAM is characterized by sequential memory access with very high row buffer locality (96% hit rate) and is memory intensive, making it a memory performance hog.\"\n  },\n  {\n    question: \"What characterizes the RANDOM access pattern in the memory performance example?\",\n    options: [\n      \"Sequential access with high locality\",\n      \"Random memory access with very low row buffer locality (3% hit rate)\",\n      \"Structured access with medium locality\",\n      \"Predictable access pattern\"\n    ],\n    correct: 1,\n    explanation: \"RANDOM is characterized by random memory access with very low row buffer locality (3% hit rate) and is similarly memory intensive compared to STREAM.\"\n  },\n  {\n    question: \"What does a DRAM cell consist of?\",\n    options: [\n      \"Two transistors and a resistor\",\n      \"A capacitor and an access transistor\",\n      \"Three capacitors in series\",\n      \"A flip-flop circuit\"\n    ],\n    correct: 1,\n    explanation: \"A DRAM cell consists of a capacitor and an access transistor. It stores data in terms of charge in the capacitor.\"\n  },\n  {\n    question: \"Why does DRAM need to be refreshed?\",\n    options: [\n      \"To improve performance\",\n      \"Because capacitor charge leaks over time\",\n      \"To reduce power consumption\",\n      \"To increase storage capacity\"\n    ],\n    correct: 1,\n    explanation: \"DRAM capacitor charge leaks over time, so the memory controller needs to refresh each row periodically to restore charge. Typically each row must be refreshed every 64ms.\"\n  },\n  {\n    question: \"What are the main downsides of DRAM refresh?\",\n    options: [\n      \"Only increased cost\",\n      \"Only performance degradation\",\n      \"Energy consumption, performance degradation, QoS impact, and capacity scaling limits\",\n      \"Only energy consumption\"\n    ],\n    correct: 2,\n    explanation: \"DRAM refresh has multiple downsides: energy consumption (each refresh consumes energy), performance degradation (DRAM unavailable while refreshed), QoS/predictability impact (long pause times), and refresh rate limits DRAM capacity scaling.\"\n  },\n  {\n    question: \"What is the typical refresh period for DRAM rows?\",\n    options: [\n      \"64 microseconds\",\n      \"64 milliseconds\",\n      \"64 seconds\",\n      \"64 nanoseconds\"\n    ],\n    correct: 1,\n    explanation: \"The typical refresh period is 64 milliseconds (64 ms). Each row must be activated (refreshed) every 64 ms to restore the charge in the capacitors.\"\n  },\n  {\n    question: \"What key observation does RAIDR make about DRAM refresh?\",\n    options: [\n      \"All rows need frequent refresh\",\n      \"Most DRAM rows can be refreshed much less often without losing data\",\n      \"Refresh is unnecessary\",\n      \"Only some rows need any refresh\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR observes that most DRAM rows can be refreshed much less often without losing data, leading to the idea of refreshing rows containing weak cells more frequently and other rows less frequently.\"\n  },\n  {\n    question: \"How does RAIDR achieve refresh reduction?\",\n    options: [\n      \"By eliminating refresh entirely\",\n      \"By profiling retention times, binning rows, and refreshing different bins at different rates\",\n      \"By using different DRAM technology\",\n      \"By increasing refresh frequency for all rows\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR works in three steps: (1) Profiling retention time of all rows, (2) Binning rows by retention time in memory controller using Bloom Filters, (3) Refreshing rows in different bins at different rates.\"\n  },\n  {\n    question: \"What are the benefits achieved by RAIDR?\",\n    options: [\n      \"Only performance improvement\",\n      \"74.6% refresh reduction, ~16%/20% DRAM power reduction, ~9% performance improvement\",\n      \"Only power reduction\",\n      \"Only refresh reduction\"\n    ],\n    correct: 1,\n    explanation: \"RAIDR achieves multiple benefits: 74.6% refresh reduction with only 1.25KB storage overhead, ~16%/20% DRAM dynamic/idle power reduction, and ~9% performance improvement, with benefits increasing with DRAM capacity.\"\n  },\n  {\n    question: \"What is one of the two key goals of the computer architecture course mentioned in the lecture?\",\n    options: [\n      \"To learn programming languages\",\n      \"To understand how a processor works underneath the software layer\",\n      \"To design operating systems\",\n      \"To build hardware components\"\n    ],\n    correct: 1,\n    explanation: \"One key goal is to understand how a processor works underneath the software layer and how decisions made in hardware affect the software/programmer.\"\n  },\n  {\n    question: \"What is the second key goal of the computer architecture course?\",\n    options: [\n      \"To memorize instruction sets\",\n      \"To enable making design and optimization decisions that cross boundaries of different layers\",\n      \"To focus only on hardware design\",\n      \"To specialize in one abstraction layer\"\n    ],\n    correct: 1,\n    explanation: \"The second key goal is to enable students to be comfortable in making design and optimization decisions that cross the boundaries of different layers and system components.\"\n  },\n  {\n    question: \"In the memory performance hog scenario, approximately how many requests of the STREAM application (T0) are serviced before the RANDOM application (T1) gets served?\",\n    options: [\n      \"64 requests\",\n      \"96 requests\",\n      \"128 requests\",\n      \"256 requests\"\n    ],\n    correct: 2,\n    explanation: \"With a row size of 8KB and cache block size of 64B, there are 128 (8KB/64B) requests of T0 (STREAM) serviced before T1 (RANDOM) gets a chance, demonstrating the unfairness of the row-hit first policy.\"\n  },\n  {\n    question: \"What is the main takeaway about abstraction layers from this lecture?\",\n    options: [\n      \"Abstraction layers should never be crossed\",\n      \"Breaking abstraction layers and knowing what is underneath enables problem solving\",\n      \"Only hardware designers need to understand multiple layers\",\n      \"Abstraction layers are only theoretical concepts\"\n    ],\n    correct: 1,\n    explanation: \"The main takeaway is that breaking the abstraction layers (between components and transformation hierarchy levels) and knowing what is underneath enables you to solve problems and design better future systems. Cooperation between multiple components and layers can enable more effective solutions.\"\n  }\n],\n'Chapter 5: What is A Computer and Von Neumann Model': [\n  {\n    question: \"What are the three key components that define a computer?\",\n    options: [\n      \"Hardware, software, and users\",\n      \"Computation, communication, and storage (memory)\",\n      \"Input, processing, and output\",\n      \"CPU, RAM, and hard drive\"\n    ],\n    correct: 1,\n    explanation: \"A computer is defined by three key components: Computation (processing), Communication (I/O), and Storage (memory). These components work together to form a complete computing system.\"\n  },\n  {\n    question: \"What are the two key properties of the Von Neumann model?\",\n    options: [\n      \"Fast processing and large memory\",\n      \"Stored program and sequential instruction processing\",\n      \"Multiple cores and parallel processing\",\n      \"Input/output capabilities and user interface\"\n    ],\n    correct: 1,\n    explanation: \"The Von Neumann model has two key properties: (1) Stored program - instructions stored in linear memory array with unified memory for instructions and data, (2) Sequential instruction processing - one instruction processed at a time with Program Counter identifying current instruction.\"\n  },\n  {\n    question: \"In the Von Neumann model, what determines whether a stored value is interpreted as an instruction?\",\n    options: [\n      \"The value itself\",\n      \"The memory location\",\n      \"The control signals\",\n      \"The data type\"\n    ],\n    correct: 2,\n    explanation: \"In the Von Neumann model, the interpretation of a stored value depends on the control signals. The same bit pattern can be interpreted as data or as an instruction depending on how the control unit processes it.\"\n  },\n  {\n    question: \"What is another name for the Von Neumann architecture?\",\n    options: [\n      \"Parallel processing computer\",\n      \"Stored program computer\",\n      \"Data flow computer\",\n      \"Multi-core computer\"\n    ],\n    correct: 1,\n    explanation: \"The Von Neumann architecture is also called a 'stored program computer' because instructions are stored in memory along with data, rather than being hardwired into the machine.\"\n  },\n  {\n    question: \"In the Von Neumann model, how is the Program Counter (instruction pointer) advanced?\",\n    options: [\n      \"Randomly based on available instructions\",\n      \"Based on data availability\",\n      \"Sequentially except for control transfer instructions\",\n      \"In parallel for multiple instructions\"\n    ],\n    correct: 2,\n    explanation: \"The Program Counter is advanced sequentially except for control transfer instructions (like jumps, branches, calls). This sequential advancement is a fundamental characteristic of Von Neumann execution.\"\n  },\n  {\n    question: \"In the dataflow model, when is an instruction executed?\",\n    options: [\n      \"When the instruction pointer points to it\",\n      \"When all its operands are ready\",\n      \"In sequential order\",\n      \"When the CPU is idle\"\n    ],\n    correct: 1,\n    explanation: \"In the dataflow model, an instruction is executed when all its operands are ready (i.e., when all inputs have tokens). There is no instruction pointer - execution is driven by data availability.\"\n  },\n  {\n    question: \"What is the main difference between Von Neumann and dataflow execution models?\",\n    options: [\n      \"Von Neumann uses more memory\",\n      \"Von Neumann is control-driven/sequential, dataflow is data-driven/parallel\",\n      \"Dataflow is slower than Von Neumann\",\n      \"Von Neumann requires special hardware\"\n    ],\n    correct: 1,\n    explanation: \"Von Neumann model is control-driven with sequential execution (instruction pointer controls order), while dataflow model is data-driven with potentially parallel execution (data availability controls order).\"\n  },\n  {\n    question: \"Which execution model is inherently more parallel?\",\n    options: [\n      \"Von Neumann model\",\n      \"Dataflow model\",\n      \"Both are equally parallel\",\n      \"Neither supports parallelism\"\n    ],\n    correct: 1,\n    explanation: \"The dataflow model is inherently more parallel because multiple instructions can 'fire' (execute) simultaneously when their operands are ready, unlike Von Neumann's sequential execution model.\"\n  },\n  {\n    question: \"In a dataflow machine, what causes a data flow node to 'fire'?\",\n    options: [\n      \"A clock signal\",\n      \"The instruction pointer\",\n      \"When all its inputs have tokens (are ready)\",\n      \"A random trigger\"\n    ],\n    correct: 2,\n    explanation: \"A data flow node fires (is fetched and executed) when all its inputs are ready, i.e., when all inputs have tokens. This is the fundamental execution principle of dataflow computing.\"\n  },\n  {\n    question: \"What major instruction set architectures use the Von Neumann model today?\",\n    options: [\n      \"Only x86\",\n      \"x86, ARM, MIPS, SPARC, Alpha, POWER\",\n      \"Only ARM and x86\",\n      \"Only older architectures\"\n    ],\n    correct: 1,\n    explanation: \"All major instruction set architectures today use the Von Neumann model, including x86, ARM, MIPS, SPARC, Alpha, and POWER architectures.\"\n  },\n  {\n    question: \"At the microarchitecture level, how do modern processors actually execute instructions?\",\n    options: [\n      \"Exactly as specified by Von Neumann model\",\n      \"Very differently from Von Neumann model (pipelined, out-of-order, etc.)\",\n      \"Only in sequential order\",\n      \"Without any optimization\"\n    ],\n    correct: 1,\n    explanation: \"Modern microarchitectures execute very differently from the Von Neumann model - using pipelined execution, multiple instructions at a time, out-of-order execution, and separate instruction/data caches, but this is not exposed to software.\"\n  },\n  {\n    question: \"What is the key difference between ISA and microarchitecture?\",\n    options: [\n      \"ISA is hardware, microarchitecture is software\",\n      \"ISA is the agreed interface between SW/HW, microarchitecture is the specific implementation\",\n      \"They are the same thing\",\n      \"ISA is old, microarchitecture is new\"\n    ],\n    correct: 1,\n    explanation: \"ISA is the agreed upon interface between software and hardware (what software writer needs to know), while microarchitecture is the specific implementation of an ISA (not visible to software).\"\n  },\n  {\n    question: \"Using the car analogy, what represents ISA vs. microarchitecture?\",\n    options: [\n      \"Engine vs. wheels\",\n      \"Gas pedal (interface) vs. engine internals (implementation)\",\n      \"Steering wheel vs. brakes\",\n      \"Exterior vs. interior\"\n    ],\n    correct: 1,\n    explanation: \"The gas pedal represents ISA (interface for 'acceleration' that driver uses), while the internals of the engine represent microarchitecture (how 'acceleration' is actually implemented).\"\n  },\n  {\n    question: \"Which changes faster: ISA or microarchitecture?\",\n    options: [\n      \"ISA changes faster\",\n      \"Microarchitecture changes faster\",\n      \"They change at the same rate\",\n      \"Neither changes\"\n    ],\n    correct: 1,\n    explanation: \"Microarchitecture usually changes faster than ISA. There are few ISAs (x86, ARM, SPARC, MIPS, Alpha) but many microarchitectures. For example, x86 ISA has many implementations: 286, 386, 486, Pentium, Pentium Pro, Pentium 4, Core, etc.\"\n  },\n  {\n    question: \"What does superscalar processing refer to?\",\n    options: [\n      \"Using multiple CPU cores\",\n      \"A technique to execute multiple instructions in parallel within the same processor core\",\n      \"Increasing clock frequency\",\n      \"Adding more memory\"\n    ],\n    correct: 1,\n    explanation: \"Superscalar processing is a technique used in modern microprocessor design to increase instruction throughput by executing multiple instructions in parallel within the same processor core, allowing more than one instruction per clock cycle.\"\n  },\n  {\n    question: \"Which of the following is part of the ISA?\",\n    options: [\n      \"Number of ports to the register file\",\n      \"ADD instruction's opcode\",\n      \"Whether machine employs pipelined execution\",\n      \"Number of cycles to execute MUL instruction\"\n    ],\n    correct: 1,\n    explanation: \"ADD instruction's opcode is part of the ISA as it defines the instruction interface. Number of register file ports, pipelining, and execution cycles are microarchitecture implementation details not visible to software.\"\n  },\n  {\n    question: \"Which of the following is part of microarchitecture?\",\n    options: [\n      \"Number of general purpose registers\",\n      \"Instruction opcodes\",\n      \"Number of ports to the register file\",\n      \"Memory addressing modes\"\n    ],\n    correct: 2,\n    explanation: \"Number of ports to the register file is a microarchitecture detail (implementation choice for performance). Number of registers, opcodes, and addressing modes are ISA specifications visible to programmers.\"\n  },\n  {\n    question: \"What does ISA specify regarding instructions?\",\n    options: [\n      \"Only the instruction format\",\n      \"Opcodes, addressing modes, data types, instruction types and formats, registers, condition codes\",\n      \"Only the execution time\",\n      \"Only the memory requirements\"\n    ],\n    correct: 1,\n    explanation: \"ISA specifies comprehensive instruction-related elements: opcodes, addressing modes, data types, instruction types and formats, registers, and condition codes - everything a programmer needs to know to write programs.\"\n  },\n  {\n    question: \"Which of the following are microarchitecture implementation choices?\",\n    options: [\n      \"Virtual memory management\",\n      \"Pipelining, out-of-order execution, caching policies, superscalar processing\",\n      \"Instruction set definition\",\n      \"Memory addressing modes\"\n    ],\n    correct: 1,\n    explanation: \"Microarchitecture includes implementation choices like pipelining, in-order vs out-of-order execution, memory access scheduling, superscalar processing, caching policies, prefetching, etc. - all done without exposure to software.\"\n  },\n  {\n    question: \"In the out-of-order execution example with instructions (1) mov eax,0 (2) mov edx,1 (3) mov edx,3 (4) inc edx (5) mov ecx,3, what determines the execution order?\",\n    options: [\n      \"The original program order must be maintained\",\n      \"The transistors/hardware decides based on dependencies and available resources\",\n      \"Random selection\",\n      \"Always execute in reverse order\"\n    ],\n    correct: 1,\n    explanation: \"In out-of-order execution, the transistors (hardware) decide which instructions to execute based on data dependencies and available execution resources, while maintaining the correct program semantics.\"\n  }\n],\n'Chapter 6: Introduction to ISA Tradeoffs': [\n  {\n    question: \"What is a design point in computer architecture?\",\n    options: [\n      \"A specific location on the processor chip\",\n      \"A set of design considerations and their importance that leads to tradeoffs\",\n      \"The final stage of processor design\",\n      \"A testing methodology for processors\"\n    ],\n    correct: 1,\n    explanation: \"A design point is a set of design considerations and their importance that leads to tradeoffs in both ISA and microarchitecture. It's determined by the application space and intended users/market.\"\n  },\n  {\n    question: \"Which of the following are key design considerations mentioned in the lecture?\",\n    options: [\n      \"Only cost and performance\",\n      \"Cost, performance, power consumption, energy consumption, availability, reliability, time to market\",\n      \"Only performance and reliability\",\n      \"Hardware complexity and software compatibility\"\n    ],\n    correct: 1,\n    explanation: \"The key design considerations include: Cost, Performance, Maximum power consumption, Energy consumption (battery life), Availability, Reliability and Correctness, and Time to Market.\"\n  },\n  {\n    question: \"What determines the design point of a computer system?\",\n    options: [\n      \"The available technology\",\n      \"The manufacturing cost\",\n      \"The 'Problem' space (application space) and intended users/market\",\n      \"Government regulations\"\n    ],\n    correct: 2,\n    explanation: \"The design point is determined by the 'Problem' space (application space) and the intended users/market, which influences the relative importance of different design considerations.\"\n  },\n  {\n    question: \"What are the two main components of an instruction?\",\n    options: [\n      \"Address and data\",\n      \"Opcode and operands\",\n      \"Source and destination\",\n      \"Input and output\"\n    ],\n    correct: 1,\n    explanation: \"An instruction consists of: (1) opcode - what the instruction does, and (2) operands - who it is to do it to. This is the basic element of the HW/SW interface.\"\n  },\n  {\n    question: \"What is the concept of 'bit steering' in instruction encoding?\",\n    options: [\n      \"Using bits to control data flow direction\",\n      \"A bit in the instruction determines the interpretation of other bits\",\n      \"Steering bits toward the ALU\",\n      \"Managing bit-level operations\"\n    ],\n    correct: 1,\n    explanation: \"Bit steering is a concept where a bit in the instruction determines the interpretation of other bits, allowing for more efficient use of the instruction encoding space.\"\n  },\n  {\n    question: \"In a 0-address (stack) machine, how are operations performed?\",\n    options: [\n      \"Using registers only\",\n      \"Operations work on top elements of the stack (push/pop)\",\n      \"Direct memory addressing\",\n      \"Using accumulator register\"\n    ],\n    correct: 1,\n    explanation: \"In a 0-address stack machine, operations work on the top elements of the stack. Operands are pushed onto the stack, operations are performed on stack top elements, and results are popped off.\"\n  },\n  {\n    question: \"What characterizes a 1-address (accumulator) machine?\",\n    options: [\n      \"All operations use stack\",\n      \"Operations use accumulator register (op ACC, ld A, st A)\",\n      \"Two operands per instruction\",\n      \"Three separate operands\"\n    ],\n    correct: 1,\n    explanation: \"In a 1-address accumulator machine, operations typically involve the accumulator register (ACC). Instructions like 'op ACC', 'ld A' (load into ACC), 'st A' (store from ACC) are characteristic.\"\n  },\n  {\n    question: \"In a 2-address machine, what happens to one of the operands?\",\n    options: [\n      \"It remains unchanged\",\n      \"One operand is both source and destination (gets clobbered)\",\n      \"It gets copied to memory\",\n      \"It gets pushed to stack\"\n    ],\n    correct: 1,\n    explanation: \"In a 2-address machine (op S,D), one operand serves as both source and destination, meaning the original value gets overwritten (clobbered) with the operation result.\"\n  },\n  {\n    question: \"What is the main advantage of a 3-address machine?\",\n    options: [\n      \"Smaller instruction size\",\n      \"Source and destination are separate (op S1,S2,D)\",\n      \"Faster execution\",\n      \"Lower power consumption\"\n    ],\n    correct: 1,\n    explanation: \"In a 3-address machine (op S1,S2,D), the source operands and destination are separate, which means source values are preserved and not clobbered during operations.\"\n  },\n  {\n    question: \"What are the main advantages of stack machines?\",\n    options: [\n      \"Large instruction size and complex logic\",\n      \"Small instruction size, simpler logic, compact code, efficient procedure calls\",\n      \"High flexibility and parallel operations\",\n      \"Complex data type support\"\n    ],\n    correct: 1,\n    explanation: \"Stack machines have: small instruction size (no operands needed for operate instructions), simpler logic, compact code, and efficient procedure calls (all parameters on stack with no additional cycles for parameter passing).\"\n  },\n  {\n    question: \"What are the main disadvantages of stack machines?\",\n    options: [\n      \"Large code size and slow execution\",\n      \"Computations not easily expressible in postfix notation are difficult; limited flexibility\",\n      \"High power consumption\",\n      \"Complex instruction decoding\"\n    ],\n    correct: 1,\n    explanation: \"Stack machines have disadvantages: computations not easily expressible with postfix notation are difficult to map, cannot perform operations on many values simultaneously (only top N values), and lack flexibility.\"\n  },\n  {\n    question: \"The PDP-11 is an example of which type of machine?\",\n    options: [\n      \"0-address (stack) machine\",\n      \"1-address (accumulator) machine\",\n      \"2-address machine\",\n      \"3-address machine\"\n    ],\n    correct: 2,\n    explanation: \"The PDP-11 is a 2-address machine. Its ADD instruction has a 4-bit opcode and 2 6-bit operand specifiers, with limited bits to specify an instruction.\"\n  },\n  {\n    question: \"What is the main disadvantage of the PDP-11's 2-address design?\",\n    options: [\n      \"Too many operands\",\n      \"One source operand is always clobbered with the result\",\n      \"Instructions are too long\",\n      \"Cannot access memory\"\n    ],\n    correct: 1,\n    explanation: \"In PDP-11's 2-address design, one source operand is always clobbered (overwritten) with the result of the instruction, requiring additional steps to preserve original values when needed.\"\n  },\n  {\n    question: \"What type of machine is the Alpha architecture?\",\n    options: [\n      \"2-address memory/memory machine\",\n      \"Stack machine\",\n      \"3-address load/store machine\",\n      \"1-address accumulator machine\"\n    ],\n    correct: 2,\n    explanation: \"Alpha is a 3-address load/store machine, meaning it has separate source and destination operands, and memory access is only through explicit load and store instructions.\"\n  },\n  {\n    question: \"What type of machine is x86?\",\n    options: [\n      \"3-address load/store machine\",\n      \"2-address memory/memory machine\",\n      \"Stack machine only\",\n      \"1-address accumulator machine\"\n    ],\n    correct: 1,\n    explanation: \"x86 is a 2-address memory/memory machine, meaning it can perform operations directly between memory locations and registers, with one operand serving as both source and destination.\"\n  },\n  {\n    question: \"How is a data type defined in ISA context?\",\n    options: [\n      \"Any binary representation\",\n      \"Representation of information for which there are instructions that operate on the representation\",\n      \"Only primitive types like integers\",\n      \"Memory storage format only\"\n    ],\n    correct: 1,\n    explanation: \"A data type is defined as a representation of information for which there are instructions that operate on that representation. It's not just about storage format, but about having instruction support.\"\n  },\n  {\n    question: \"Which of the following are examples of data types mentioned?\",\n    options: [\n      \"Only integer and floating point\",\n      \"Integer, floating point, character, binary, decimal, BCD, doubly linked list, queue, string, bit vector, stack\",\n      \"Only primitive data types\",\n      \"Only numeric types\"\n    ],\n    correct: 1,\n    explanation: \"The lecture mentions various data types: Integer, floating point, character, binary, decimal, BCD, doubly linked list, queue, string, bit vector, and stack - ranging from primitive to complex structured types.\"\n  },\n  {\n    question: \"What is an example of a high-level data type instruction from VAX?\",\n    options: [\n      \"ADD and SUB only\",\n      \"INSQUEUE (Insert Queue) and REMQUEUE (Remove Queue) on doubly linked lists\",\n      \"Only load and store\",\n      \"Basic arithmetic operations\"\n    ],\n    correct: 1,\n    explanation: \"VAX provided high-level instructions like INSQUEUE (Insert Queue) and REMQUEUE (Remove Queue) that operated on doubly linked lists or queues, and FINDFIRST for complex data structure operations.\"\n  },\n  {\n    question: \"What does the 'semantic gap' refer to in computer architecture?\",\n    options: [\n      \"Physical distance between components\",\n      \"The disparity between high-level software concepts and low-level hardware operations\",\n      \"Time delay in instruction execution\",\n      \"Memory access latency\"\n    ],\n    correct: 1,\n    explanation: \"The semantic gap refers to the disparity between high-level concepts and abstractions used in software programming and the low-level operations and mechanisms implemented in hardware.\"\n  },\n  {\n    question: \"How do Early RISC architectures and Intel 432 differ in terms of semantic gap?\",\n    options: [\n      \"Both have the same approach\",\n      \"Early RISC: only integer data type (large gap); Intel 432: object data type, capability-based (small gap)\",\n      \"Both focus on complex data types\",\n      \"Both use only primitive types\"\n    ],\n    correct: 1,\n    explanation: \"Early RISC architectures had only integer data types (creating a large semantic gap), while Intel 432 supported object data types and was capability-based (attempting to close the semantic gap with high-level features).\"\n  }\n],\n  'Chapter 7: ISA Tradeoffs': [\n    // Data Types (Pages 3-5)\n    {\n      question: \"Which ISA introduced dedicated instructions for doubly linked list operations like INSQUEUE?\",\n      options: [\"x86\", \"VAX\", \"MIPS\", \"ARM\"],\n      correct: 1,\n      explanation: \"VAX had specialized instructions for queue/list operations, reflecting its CISC design philosophy.\"\n    },\n    {\n      question: \"What was the primary data type supported in early RISC architectures?\",\n      options: [\"Floating point\", \"Integer only\", \"Object references\", \"Binary-coded decimal\"],\n      correct: 1,\n      explanation: \"Early RISC designs like MIPS supported only integers to maintain simplicity.\"\n    },\n\n    // Semantic Gap (Pages 5,25)\n    {\n      question: \"The Intel 432's object data types illustrate what kind of semantic gap approach?\",\n      options: [\"Maximized gap\", \"Minimized gap\", \"No gap\", \"Variable gap\"],\n      correct: 1,\n      explanation: \"Intel 432 aimed to minimize the gap by supporting high-level constructs directly in hardware.\"\n    },\n\n    // Memory Organization (Pages 6-8)\n    {\n      question: \"In a 32-bit addressable system like the first Alpha, how would you add two 32-bit numbers?\",\n      options: [\n        \"Using two 32-bit load/store instructions\",\n        \"With a single 64-bit ADD instruction\",\n        \"Through memory-memory operations\",\n        \"Using bit-addressable operations\"\n      ],\n      correct: 0,\n      explanation: \"Required multiple operations due to 32-bit addressability constraints.\"\n    },\n    {\n      question: \"Which supercomputer architecture used 64-bit addressability?\",\n      options: [\"Burroughs 1700\", \"Cray-1\", \"Intel 432\", \"VAX-11\"],\n      correct: 1,\n      explanation: \"Cray supercomputers pioneered 64-bit addressability for scientific computing.\"\n    },\n\n    // Endianness (Pages 7-8)\n    {\n      question: \"Which architecture uses big-endian byte ordering?\",\n      options: [\"x86\", \"PowerPC\", \"ARM (little-endian mode)\", \"Original PCI bus\"],\n      correct: 1,\n      explanation: \"PowerPC and SPARC are notable big-endian architectures.\"\n    },\n    {\n      question: \"In little-endian systems, how is the value 0x12345678 stored at address A?\",\n      options: [\n        \"A:12 A+1:34 A+2:56 A+3:78\",\n        \"A:78 A+1:56 A+2:34 A+3:12\",\n        \"A:56 A+1:78 A+2:12 A+3:34\",\n        \"Split across cache lines\"\n      ],\n      correct: 1,\n      explanation: \"Little-endian stores least significant byte at lowest address.\"\n    },\n\n    // Registers (Pages 9-12)\n    {\n      question: \"What characteristic of programs justifies having registers in an ISA?\",\n      options: [\n        \"Spatial locality\",\n        \"Data locality (temporal and spatial)\",\n        \"Memory wall effect\",\n        \"Von Neumann bottleneck\"\n      ],\n      correct: 1,\n      explanation: \"Registers exploit temporal locality (reused data) and spatial locality (nearby data).\"\n    },\n    {\n      question: \"How many general-purpose registers did IA-64 (Itanium) introduce?\",\n      options: [\"8\", \"16\", \"32\", \"128\"],\n      correct: 3,\n      explanation: \"IA-64 expanded to 128 registers for explicit parallelism.\"\n    },\n\n    // Programmer Invisible State (Pages 10-11)\n    {\n      question: \"Why can't programmers directly access pipeline registers?\",\n      options: [\n        \"They are protected by the OS\",\n        \"They represent microarchitectural state\",\n        \"They are physically inaccessible\",\n        \"They violate memory protection\"\n      ],\n      correct: 1,\n      explanation: \"Pipeline registers are part of implementation-specific microarchitecture.\"\n    },\n\n    // Instruction Classes (Page 13)\n    {\n      question: \"Which instruction class changes the sequence of execution?\",\n      options: [\n        \"Operate instructions\",\n        \"Data movement instructions\",\n        \"Control flow instructions\",\n        \"Floating-point instructions\"\n      ],\n      correct: 2,\n      explanation: \"Control flow instructions (branches/jumps) alter the PC.\"\n    },\n\n    // Addressing Modes (Pages 14-19)\n    {\n      question: \"Which addressing mode combines a base register and index register?\",\n      options: [\n        \"Displacement\",\n        \"Register indirect\",\n        \"Indexed addressing\",\n        \"Memory indirect\"\n      ],\n      correct: 2,\n      explanation: \"Indexed addressing uses base + index calculation.\"\n    },\n    {\n      question: \"What does 'orthogonal ISA' mean?\",\n      options: [\n        \"Instructions use only right angles\",\n        \"All instructions can use all addressing modes\",\n        \"Fixed 90-degree instruction alignment\",\n        \"Separate integer/floating-point pipelines\"\n      ],\n      correct: 1,\n      explanation: \"Orthogonality means uniform combination of operations and addressing modes.\"\n    },\n\n    {\n      question: \"What is a key advantage of variable-length instructions?\",\n      options: [\n        \"Simpler hardware decoding\",\n        \"Better code density\",\n        \"Faster clock speeds\",\n        \"More registers\"\n      ],\n      correct: 1,\n      explanation: \"Variable-length enables compact encoding (e.g., x86).\"\n    },\n    {\n      question: \"Which field in MIPS I-type instructions holds the immediate value?\",\n      options: [\"rs\", \"rt\", \"opcode\", \"16-bit immediate field\"],\n      correct: 3,\n      explanation: \"I-type uses 16-bit immediate for constants/offsets.\"\n    },\n\n    {\n      question: \"What was a major disadvantage of complex CISC instructions?\",\n      options: [\n        \"Limited compiler optimization opportunities\",\n        \"Too many registers\",\n        \"Fixed-length encoding\",\n        \"Lack of virtual memory support\"\n      ],\n      correct: 0,\n      explanation: \"Complex instructions created coarse-grained operations that constrained optimizations.\"\n    },\n    {\n      question: \"Which VAX instruction provided array access with bounds checking?\",\n      options: [\"MOV\", \"INDEX\", \"BOUNDS\", \"ARRAY\"],\n      correct: 1,\n      explanation: \"VAX INDEX instruction exemplified high-level language support.\"\n    },\n\n    {\n      question: \"Which characteristic is NOT typical of RISC designs?\",\n      options: [\n        \"Many addressing modes\",\n        \"Uniform decode\",\n        \"Fixed-length instructions\",\n        \"Load/store architecture\"\n      ],\n      correct: 0,\n      explanation: \"RISC minimizes addressing modes for simplicity.\"\n    },\n    {\n      question: \"What motivated the x86's instruction prefixes?\",\n      options: [\n        \"Backward compatibility\",\n        \"Faster decoding\",\n        \"Fewer registers\",\n        \"Big-endian support\"\n      ],\n      correct: 0,\n      explanation: \"Prefixes allowed extending the ISA while maintaining compatibility.\"\n    },\n\n    {\n      question: \"What drove ISA evolution according to the chapter?\",\n      options: [\n        \"Compiler limitations\",\n        \"Memory constraints\",\n        \"Specialization needs\",\n        \"All of the above\"\n      ],\n      correct: 3,\n      explanation: \"All these factors historically influenced ISA design.\"\n    },\n\n    {\n      question: \"How many bytes can x86 instruction prefixes occupy?\",\n      options: [\"0\", \"1\", \"Up to 4\", \"Exactly 2\"],\n      correct: 2,\n      explanation: \"x86 allows up to four 1-byte prefixes.\"\n    },\n    {\n      question: \"What MIPS instruction format has a 26-bit immediate?\",\n      options: [\"R-type\", \"I-type\", \"J-type\", \"U-type\"],\n      correct: 2,\n      explanation: \"J-type (jump) uses 26-bit immediates for address targets.\"\n    }\n  ],\n  'Chapter 8: Single-Cycle Microarchitecture': [\n{\nquestion: \"What is the primary purpose of cache memory?\",\noptions: [\n\"To permanently store all program instructions\",\n\"To store active/commonly used instructions and speed up processing\",\n\"To replace the main memory entirely\",\n\"To store only the results of arithmetic operations\"\n],\ncorrect: 1,\nexplanation: \"Cache memory temporarily stores active or frequently used instructions to speed up processing and reduce bottlenecks between RAM and the CPU.\"\n},\n{\nquestion: \"During the fetch part of the instruction cycle, what is the role of the address bus?\",\noptions: [\n\"It carries the instruction's opcode to the ALU\",\n\"It carries the address of the instruction to main memory\",\n\"It stores the result of the executed instruction\",\n\"It decodes the instruction for the control unit\"\n],\ncorrect: 1,\nexplanation: \"The address bus carries the memory address of the instruction to be fetched from main memory to the CPU.\"\n},\n{\nquestion: \"Which of the following is a drawback of higher clock speeds in CPUs?\",\noptions: [\n\"Fewer instructions can be executed per second\",\n\"The CPU may overheat and require more cooling\",\n\"Programs run slower due to increased complexity\",\n\"The data bus width is reduced\"\n],\ncorrect: 1,\nexplanation: \"Higher clock speeds increase power consumption and heat generation, potentially causing overheating and requiring additional cooling solutions.\"\n},\n{\nquestion: \"In a single-cycle microarchitecture, how many clock cycles does each instruction take to execute?\",\noptions: [\n\"One cycle\",\n\"Two cycles\",\n\"Variable cycles depending on the instruction\",\n\"Six cycles (one per phase)\"\n],\ncorrect: 0,\nexplanation: \"In a single-cycle microarchitecture, all phases of an instruction (fetch, decode, execute, etc.) are completed within a single clock cycle.\"\n},\n{\nquestion: \"What determines the clock cycle time in a single-cycle microarchitecture?\",\noptions: [\n\"The fastest instruction\",\n\"The average instruction latency\",\n\"The slowest instruction\",\n\"The number of functional units\"\n],\ncorrect: 2,\nexplanation: \"The slowest instruction dictates the clock cycle time because all instructions must complete within one cycle.\"\n} \n],  \n'Chapter 9: Multi-Cycle and Pipelined Microarchitecture' : [\n{\nquestion: \"How does a multi-cycle microarchitecture differ from a single-cycle design?\",\noptions: [\n\"Instructions always take fewer cycles to complete\",\n\"Each phase of the instruction cycle may span multiple clock cycles\",\n\"It eliminates the need for a control unit\",\n\"It uses a smaller data bus\"\n],\ncorrect: 1,\nexplanation: \"In a multi-cycle microarchitecture, each phase (fetch, decode, etc.) can take multiple clock cycles, allowing for shorter cycle times.\"\n},\n{\nquestion: \"What is a key advantage of multi-cycle machines over single-cycle machines?\",\noptions: [\n\"The slowest instruction determines the cycle time\",\n\"Clock cycle time is shorter as it depends on the slowest stage, not instruction\",\n\"They require no control signals\",\n\"All instructions execute in parallel\"\n],\ncorrect: 1,\nexplanation: \"Multi-cycle machines break instructions into stages, allowing the clock cycle time to be determined by the slowest stage rather than the slowest instruction.\"\n},\n{\nquestion: \"Which component generates control signals to coordinate the datapath in instruction processing?\",\noptions: [\n\"ALU\",\n\"Cache memory\",\n\"Control logic\",\n\"Address bus\"\n],\ncorrect: 2,\nexplanation: \"The control logic decodes instructions and generates signals to direct the datapath (e.g., ALU, registers) on how to process data.\"\n},\n{\nquestion: \"What happens to the program counter (PC) during the fetch stage?\",\noptions: [\n\"It is reset to zero\",\n\"It is incremented to point to the next instruction\",\n\"It stores the result of the ALU operation\",\n\"It holds the opcode for decoding\"\n],\ncorrect: 1,\nexplanation: \"After fetching an instruction, the PC is incremented to point to the next instruction in memory.\"\n},\n{\nquestion: \"Which of the following is true about the execute stage?\",\noptions: [\n\"It retrieves the instruction from main memory\",\n\"It decodes the opcode into control signals\",\n\"It performs the actual operation (e.g., ALU computation)\",\n\"It stores the result in the instruction register\"\n],\ncorrect: 2,\nexplanation: \"The execute stage carries out the operation specified by the instruction, such as arithmetic in the ALU or data transfer.\"\n}\n],\n'Chapter 10: Introduction to Microarchitecture' : [\n{\nquestion: \"What is the key characteristic of a single-cycle microarchitecture?\",\noptions: [\n\"All instructions complete execution in one clock cycle\",\n\"Instructions are pipelined across multiple cycles\",\n\"Only arithmetic instructions use a single cycle\",\n\"Memory access takes variable cycles depending on latency\"\n],\ncorrect: 0,\nexplanation: \"In a single-cycle microarchitecture, every instruction (e.g., ALU, load/store) completes all stages (fetch, decode, execute, etc.) within one clock cycle.\"\n},\n\n{\nquestion: \"Which component is responsible for holding the current instruction address in the single-cycle datapath?\",\noptions: [\n\"Register file\",\n\"Program counter (PC)\",\n\"ALU\",\n\"Data memory\"\n],\ncorrect: 1,\nexplanation: \"The program counter (PC) stores the address of the current instruction being executed and increments by 4 (for MIPS) after each fetch.\"\n},\n\n{\nquestion: \"What is the role of the 'sign-extend' unit in the datapath?\",\noptions: [\n\"To convert 16-bit immediate values to 32-bit signed values\",\n\"To perform arithmetic operations\",\n\"To select between register or immediate operands\",\n\"To manage memory addresses\"\n],\ncorrect: 0,\nexplanation: \"The sign-extend unit expands 16-bit immediate values (e.g., in I-type instructions) to 32 bits while preserving the sign for correct arithmetic operations.\"\n},\n\n{\nquestion: \"Which control signal determines whether the ALU uses a register value or an immediate value as its second operand?\",\noptions: [\n\"RegWrite\",\n\"ALUSrc\",\n\"MemtoReg\",\n\"Branch\"\n],\ncorrect: 1,\nexplanation: \"ALUSrc selects between the second register operand (e.g., for R-type) or a sign-extended immediate (e.g., for ADDI/LW/SW).\"\n},\n\n{\nquestion: \"What happens during the 'MEM' stage of the LW instruction?\",\noptions: [\n\"The ALU computes the effective memory address\",\n\"Data is read from memory and written to a register\",\n\"The instruction is fetched from memory\",\n\"The PC is updated\"\n],\ncorrect: 1,\nexplanation: \"In the MEM stage, the data memory is accessed using the address computed in EX, and the result is later written back to a register in WB.\"\n},\n\n{\nquestion: \"Which instruction type requires the 'RegDst' control signal to select the destination register from bits [15:11]?\",\noptions: [\n\"I-type (e.g., ADDI)\",\n\"R-type (e.g., ADD)\",\n\"Load (e.g., LW)\",\n\"Store (e.g., SW)\"\n],\ncorrect: 1,\nexplanation: \"R-type instructions use bits [15:11] for the destination register (rd), while I-type (e.g., ADDI/LW) use bits [20:16] (rt).\"\n},\n\n{\nquestion: \"Why is the single-cycle design inefficient for real-world implementations?\",\noptions: [\n\"It cannot handle branch instructions\",\n\"The clock cycle must accommodate the slowest instruction (e.g., LW)\",\n\"It lacks a register file\",\n\"Memory accesses are asynchronous\"\n],\ncorrect: 1,\nexplanation: \"The clock cycle length is determined by the slowest instruction (e.g., LW, which uses memory access), making faster instructions (e.g., ADD) unnecessarily slow.\"\n},\n\n{\nquestion: \"What is the purpose of the 'MemtoReg' multiplexer in the datapath?\",\noptions: [\n\"To select between ALU result or memory data for register writeback\",\n\"To choose between register operands\",\n\"To extend immediate values\",\n\"To compute branch targets\"\n],\ncorrect: 0,\nexplanation: \"MemtoReg selects whether the writeback data comes from the ALU result (e.g., for ADD) or memory (e.g., for LW).\"\n},\n]\n\n};\n\n\nconst quizDataArabic = {\n  'الفصل 1: مقدمة': [\n    {\n      question: \"ما هو التمييز الرئيسي بين بنية الكمبيوتر وتنظيم الكمبيوتر؟\",\n      options: [\n        \"البنية تتعامل مع الأجهزة، التنظيم يتعامل مع البرامج\",\n        \"البنية تشير إلى السمات المرئية للمبرمج، التنظيم يشير إلى كيفية تنفيذ الميزات\",\n        \"البنية تتعلق بالأداء، التنظيم يتعلق بالتكلفة\",\n        \"لا يوجد فرق بينهما\"\n      ],\n      correct: 1,\n      explanation: \"تتضمن البنية مجموعة التعليمات، تمثيل البيانات، آليات الإدخال/الإخراج - ما هو مرئي للمبرمجين. يغطي التنظيم إشارات التحكم، الواجهات، تقنية الذاكرة - تفاصيل التنفيذ.\"\n    },\n    {\n      question: \"أي مما يلي ليس أحد وظائف الكمبيوتر الأربع الأساسية؟\",\n      options: [\n        \"معالجة البيانات\",\n        \"تخزين البيانات\",\n        \"تجميع البيانات\",\n        \"نقل البيانات\"\n      ],\n      correct: 2,\n      explanation: \"الوظائف الأساسية الأربع هي: معالجة البيانات، تخزين البيانات، نقل البيانات، والتحكم. تجميع البيانات هي عملية برمجية، وليست وظيفة حاسوب أساسية.\"\n    },\n    {\n      question: \"ماذا يحتوي سجل عداد البرنامج (PC)؟\",\n      options: [\n        \"التعليمات الحالية التي يتم تنفيذها\",\n        \"عنوان زوج التعليمات التالي الذي سيتم جلبه\",\n        \"نتيجة آخر عملية حسابية\",\n        \"عنوان الذاكرة الذي يتم الوصول إليه\"\n      ],\n      correct: 1,\n      explanation: \"يحتوي عداد البرنامج (PC) على عنوان زوج التعليمات التالي الذي سيتم جلبه من الذاكرة.\"\n    },\n    {\n      question: \"في نظام متعدد النواة، ما هو 'النواة'؟\",\n      options: [\n        \"شريحة وحدة المعالجة المركزية بأكملها\",\n        \"وحدة معالجة فردية على شريحة المعالج\",\n        \"ناقل النظام الذي يربط المكونات\",\n        \"هيكل ذاكرة التخزين المؤقت\"\n      ],\n      correct: 1,\n      explanation: \"النواة هي وحدة معالجة فردية على شريحة المعالج، والتي قد تكون مكافئة في الوظائف لوحدة المعالجة المركزية في نظام أحادي وحدة المعالجة المركزية.\"\n    },\n    {\n      question: \"ما هي العلاقة بين تردد الساعة ووقت دورة الساعة؟\",\n      options: [\n        \"هما نفس الشيء\",\n        \"وقت دورة الساعة = تردد الساعة × 2\",\n        \"وقت دورة الساعة = 1 / تردد الساعة\",\n        \"لا توجد علاقة رياضية\"\n      ],\n      correct: 2,\n      explanation: \"وقت دورة الساعة هو مقلوب تردد الساعة. على سبيل المثال، ساعة 800 ميجاهرتز لديها وقت دورة يبلغ 1.25 نانو ثانية.\"\n    },\n    {\n      question: \"أي مكون يدير موارد الكمبيوتر وينسق الأداء؟\",\n      options: [\n        \"وحدة المنطق والحساب (ALU)\",\n        \"الذاكرة\",\n        \"وحدة التحكم\",\n        \"السجلات\"\n      ],\n      correct: 2,\n      explanation: \"تقوم وحدة التحكم بإدارة موارد الكمبيوتر وتنسيق أداء أجزائه الوظيفية استجابةً للتعليمات.\"\n    },\n    {\n      question: \"ما هو الغرض الأساسي من ذاكرة التخزين المؤقت (Cache Memory)؟\",\n      options: [\n        \"لتخزين نظام التشغيل\",\n        \"لعمل نسخة احتياطية من الذاكرة الرئيسية\",\n        \"لتسريع الوصول إلى الذاكرة عن طريق تخزين البيانات التي من المرجح أن تستخدم\",\n        \"للتحكم في عمليات الإدخال/الإخراج\"\n      ],\n      correct: 2,\n      explanation: \"ذاكرة التخزين المؤقت أصغر وأسرع من الذاكرة الرئيسية، وتستخدم لتسريع الوصول إلى الذاكرة عن طريق وضع البيانات من الذاكرة الرئيسية التي من المرجح أن تستخدم في المستقبل القريب.\"\n    },\n    {\n      question: \"أي سجل يحتوي على تعليمة الرمز التشغيلي (opcode) ذات 8 بت التي يتم تنفيذها؟\",\n      options: [\n        \"عداد البرنامج (PC)\",\n        \"سجل التعليمات (IR)\",\n        \"سجل عنوان الذاكرة (MAR)\",\n        \"المُجمِّع (AC)\"\n      ],\n      correct: 1,\n      explanation: \"يحتوي سجل التعليمات (IR) على تعليمة الرمز التشغيلي (opcode) ذات 8 بت التي يتم تنفيذها.\"\n    },\n    {\n      question: \"ما هي وظيفة سجل عنوان الذاكرة (MAR)؟\",\n      options: [\n        \"يحتوي على التعليمات التي يتم تنفيذها\",\n        \"يخزن البيانات المؤقتة لعمليات وحدة المنطق والحساب\",\n        \"يحدد العنوان في الذاكرة للكلمة المراد كتابتها أو قراءتها\",\n        \"يتحكم في تسلسل العمليات\"\n      ],\n      correct: 2,\n      explanation: \"يحدد سجل عنوان الذاكرة (MAR) العنوان في الذاكرة للكلمة المراد كتابتها من أو قراءتها إلى سجل مخزن الذاكرة (MBR).\"\n    },\n    {\n      question: \"في الأنظمة المضمنة، ما الذي يميز 'الأنظمة المضمنة بعمق'؟\",\n      options: [\n        \"إنها تشغل أنظمة تشغيل معقدة\",\n        \"إنها قابلة للبرمجة بعد النشر\",\n        \"إنها مخصصة لمهام محددة مع قيود شديدة على الموارد\",\n        \"إنها تحتوي دائمًا على واجهات مستخدم\"\n      ],\n      correct: 2,\n      explanation: \"الأنظمة المضمنة بعمق هي أجهزة مخصصة أحادية الغرض ذات قيود شديدة على الموارد من حيث الذاكرة، حجم المعالج، الوقت، واستهلاك الطاقة.\"\n    },\n    {\n      question: \"ما هي المكونات الهيكلية الأربعة الرئيسية للكمبيوتر؟\",\n      options: [\n        \"وحدة المعالجة المركزية، ذاكرة الوصول العشوائي، ذاكرة القراءة فقط، القرص الصلب\",\n        \"وحدة المعالجة المركزية، الذاكرة الرئيسية، الإدخال/الإخراج، التوصيل البيني للنظام\",\n        \"وحدة التحكم، وحدة المنطق والحساب، السجلات، ذاكرة التخزين المؤقت\",\n        \"المعالج، الذاكرة، التخزين، الشبكة\"\n      ],\n      correct: 1,\n      explanation: \"المكونات الهيكلية الأربعة الرئيسية هي: وحدة المعالجة المركزية (تتحكم في التشغيل ومعالجة البيانات)، الذاكرة الرئيسية (تخزن البيانات)، الإدخال/الإخراج (تنقل البيانات مع البيئة الخارجية)، والتوصيل البيني للنظام (آلية الاتصال).\"\n    },\n    {\n      question: \"ما هو الفرق بين وقت الاستجابة والإنتاجية؟\",\n      options: [\n        \"هما نفس المقياس\",\n        \"وقت الاستجابة هو السرعة، الإنتاجية هي الدقة\",\n        \"وقت الاستجابة هو الوقت لمهمة واحدة، الإنتاجية هي المهام لكل وحدة زمنية\",\n        \"وقت الاستجابة لوحدة المعالجة المركزية، الإنتاجية للذاكرة\"\n      ],\n      correct: 2,\n      explanation: \"وقت الاستجابة هو الوقت بين بدء وإكمال مهمة، بينما الإنتاجية هي إجمالي كمية المهام المنجزة في فترة زمنية معينة. لا توجد علاقة عامة بين هذه المقاييس.\"\n    },\n    {\n      question: \"ماذا يحتوي سجل مخزن الذاكرة (MBR)؟\",\n      options: [\n        \"عنوان التعليمات التالية\",\n        \"كلمة ستُخزن في الذاكرة أو تُستقبل من الذاكرة/الإدخال والإخراج\",\n        \"التعليمات الحالية التي يتم فك تشفيرها\",\n        \"إشارات التحكم لوحدة المنطق والحساب\"\n      ],\n      correct: 1,\n      explanation: \"يحتوي سجل مخزن الذاكرة (MBR) على كلمة ستُخزن في الذاكرة أو تُرسل إلى وحدة الإدخال/الإخراج، أو يُستخدم لاستقبال كلمة من الذاكرة أو من وحدة الإدخال/الإخراج.\"\n    },\n    {\n      question: \"أي جيل من نشر إنترنت الأشياء (IoT) يتميز بمليارات الأجهزة المضمنة؟\",\n      options: [\n        \"تكنولوجيا المعلومات (IT)\",\n        \"تكنولوجيا التشغيل (OT)\",\n        \"التكنولوجيا الشخصية\",\n        \"تكنولوجيا المستشعرات/المحركات\"\n      ],\n      correct: 3,\n      explanation: \"الجيل الرابع، تكنولوجيا المستشعرات/المحركات، يُعتبر عادةً إنترنت الأشياء ويتميز باستخدام مليارات الأجهزة المضمنة باستخدام الاتصال اللاسلكي.\"\n    },\n    {\n      question: \"ما هي الوظيفة الأساسية لسجل مخزن التعليمات (IBR)؟\",\n      options: [\n        \"لتخزين قيمة عداد البرنامج\",\n        \"للاحتفاظ مؤقتًا بالتعليمات اليمنى من الذاكرة\",\n        \"لاحتواء عنوان البيانات في الذاكرة\",\n        \"لتخزين نتيجة العمليات الحسابية\"\n      ],\n      correct: 1,\n      explanation: \"يُستخدم سجل مخزن التعليمات (IBR) للاحتفاظ مؤقتًا بالتعليمات اليمنى من كلمة في الذاكرة.\"\n    },\n    {\n      question: \"في سياق نقل البيانات، ما الذي يميز الإدخال/الإخراج عن اتصالات البيانات؟\",\n      options: [\n        \"سرعة نقل البيانات\",\n        \"نوع البيانات التي يتم نقلها\",\n        \"المسافة - الإدخال/الإخراج اتصال مباشر، اتصالات البيانات عبر مسافات أطول\",\n        \"متطلبات الأمان\"\n      ],\n      correct: 2,\n      explanation: \"يحدث الإدخال/الإخراج عندما يتم استقبال البيانات من أو تسليمها إلى جهاز متصل مباشرة بالكمبيوتر، بينما تتضمن اتصالات البيانات نقل البيانات عبر مسافات أطول إلى أو من أجهزة بعيدة.\"\n    },\n    {\n      question: \"ما هو الفرق الرئيسي بين معالجات التطبيقات والمعالجات المخصصة في الأنظمة المضمنة؟\",\n      options: [\n        \"مستويات استهلاك الطاقة\",\n        \"تكلفة التصنيع\",\n        \"معالجات التطبيقات تنفذ أنظمة تشغيل معقدة، المعالجات المخصصة تخدم مهام محددة\",\n        \"اختلافات الحجم المادي\"\n      ],\n      correct: 2,\n      explanation: \"تُعرف معالجات التطبيقات بقدرتها على تنفيذ أنظمة تشغيل معقدة وهي ذات غرض عام، بينما المعالجات المخصصة مخصصة لمهمة واحدة أو عدد قليل من المهام المحددة.\"\n    },\n    {\n      question: \"أي المكونات توفر الوظائف الأساسية الأربعة للدوائر المتكاملة؟\",\n      options: [\n        \"الترانزستورات، المقاومات، المكثفات، المحاثات\",\n        \"البوابات (المعالجة)، خلايا الذاكرة (التخزين)، المسارات (الحركة)، إشارات التحكم (التحكم)\",\n        \"وحدة المعالجة المركزية، الذاكرة، الإدخال/الإخراج، التوصيل البيني\",\n        \"الأجهزة، البرامج، البرامج الثابتة، البرمجيات الوسيطة\"\n      ],\n      correct: 1,\n      explanation: \"في الدوائر المتكاملة: توفر البوابات معالجة البيانات، توفر خلايا الذاكرة تخزين البيانات، توفر المسارات نقل البيانات، وتوفر إشارات التحكم وظائف التحكم.\"\n    },\n    {\n      question: \"ما هي الميزة التي تظهرها عائلات Intel x86 و IBM System/370؟\",\n      options: [\n        \"أداء أعلى من المنافسين\",\n        \"تكاليف تصنيع أقل\",\n        \"توافق الكود من خلال بنية أساسية مشتركة\",\n        \"كفاءة أفضل في استهلاك الطاقة\"\n      ],\n      correct: 2,\n      explanation: \"تتشارك جميع عائلات Intel x86 و IBM System/370 نفس البنية الأساسية، مما يوفر توافق الكود (على الأقل رجوعًا)، حتى لو اختلف التنظيم بين الإصدارات.\"\n    },\n    {\n      question: \"في الأنظمة المضمنة بعمق، ما نوع المعالج الذي يستخدم عادةً؟\",\n      options: [\n        \"المعالج الدقيق (Microprocessor)\",\n        \"المتحكم الدقيق (Microcontroller)\",\n        \"معالج الرسوميات\",\n        \"معالج الإشارة الرقمية\"\n      ],\n      correct: 1,\n      explanation: \"تستخدم الأنظمة المضمنة بعمق متحكمًا دقيقًا بدلاً من معالج دقيق، وهي غير قابلة للبرمجة بمجرد حرق منطق البرنامج في ذاكرة القراءة فقط، وليس لديها تفاعل مع المستخدم.\"\n    },\n    {\n      question: \"ما هي المكونات الهيكلية الرئيسية لوحدة المعالجة المركزية؟\",\n      options: [\n        \"ذاكرة التخزين المؤقت، السجلات، الناقل، الساعة\",\n        \"وحدة التحكم، وحدة المنطق والحساب، السجلات، التوصيل البيني لوحدة المعالجة المركزية\",\n        \"وحدة الجلب، وحدة فك التشفير، وحدة التنفيذ، وحدة الكتابة الخلفية\",\n        \"ذاكرة التخزين المؤقت L1، ذاكرة التخزين المؤقت L2، ذاكرة التخزين المؤقت L3، واجهة الذاكرة الرئيسية\"\n      ],\n      correct: 1,\n      explanation: \"المكونات الهيكلية الرئيسية لوحدة المعالجة المركزية هي: وحدة التحكم (تتحكم في تشغيل وحدة المعالجة المركزية)، وحدة المنطق والحساب (تنفذ معالجة البيانات)، السجلات (توفر تخزينًا داخليًا)، والتوصيل البيني لوحدة المعالجة المركزية (يوفر الاتصال بين المكونات).\"\n    },\n    {\n      question: \"ما الذي يميز تفاعل الأنظمة المضمنة مع بيئتها؟\",\n      options: [\n        \"إنها تعمل بشكل مستقل عن العوامل الخارجية\",\n        \"إنها مرتبطة ارتباطًا وثيقًا بقيود الوقت الفعلي\",\n        \"إنها تعالج فقط البيانات المخزنة\",\n        \"إنها تتواصل فقط عبر واجهات الشبكة\"\n      ],\n      correct: 1,\n      explanation: \"غالبًا ما ترتبط الأنظمة المضمنة ارتباطًا وثيقًا ببيئتها، مما يؤدي إلى قيود الوقت الفعلي التي تفرضها الحاجة إلى التفاعل مع البيئة، مثل السرعات المطلوبة والدقة والتوقيت.\"\n    }\n  ],\n  'الفصل 2: بيئة التخزين و RAID': [\n    {\n      question: \"ما هو الفرق الرئيسي بين وحدات الذاكرة وأجهزة التخزين؟\",\n      options: [\n        \"وحدات الذاكرة أرخص من أجهزة التخزين\",\n        \"تستخدم وحدات الذاكرة شرائح أشباه الموصلات بينما تستخدم أجهزة التخزين وسائط مغناطيسية أو بصرية\",\n        \"أجهزة التخزين أسرع من وحدات الذاكرة\",\n        \"وحدات الذاكرة غير متطايرة بينما أجهزة التخزين متطايرة\"\n      ],\n      correct: 1,\n      explanation: \"يتم تنفيذ وحدات الذاكرة باستخدام شرائح أشباه الموصلات، بينما تستخدم أجهزة التخزين وسائط مغناطيسية أو بصرية. كما أن وحدات الذاكرة تتيح الوصول إلى البيانات بسرعة أعلى من وسائط التخزين.\"\n    },\n    {\n      question: \"أي نوع من الذاكرة متطاير ويتطلب إمدادًا مستمرًا بالطاقة؟\",\n      options: [\n        \"ذاكرة القراءة فقط (ROM)\",\n        \"ذاكرة الوصول العشوائي (RAM)\",\n        \"تخزين القرص الصلب\",\n        \"تخزين القرص المضغوط (CD-ROM)\"\n      ],\n      correct: 1,\n      explanation: \"ذاكرة الوصول العشوائي (RAM) متطايرة وتتطلب إمدادًا مستمرًا بالطاقة للحفاظ على محتوى خلايا الذاكرة. يتم مسح البيانات عند إيقاف تشغيل طاقة النظام أو انقطاعها.\"\n    },\n    {\n      question: \"ماذا تعني DAS وكيف تتصل بالخوادم؟\",\n      options: [\n        \"Direct Access Storage - تتصل عبر بروتوكولات الشبكة\",\n        \"Distributed Array Storage - تتصل عبر كابلات الألياف البصرية\",\n        \"Direct Attached Storage - تتصل مباشرة عبر محول ناقل المضيف (HBA)\",\n        \"Dynamic Allocation Storage - تتصل عبر USB فقط\"\n      ],\n      correct: 2,\n      explanation: \"DAS تعني Direct Attached Storage. تتصل مباشرة بخادم عبر محول ناقل المضيف (HBA)، بدون وجود شبكة بين التخزين وخوادم الاستضافة.\"\n    },\n    {\n      question: \"ما هي الميزة الرئيسية لـ DAS على بيئات التخزين الأخرى؟\",\n      options: [\n        \"إمكانية الوصول من أجهزة متعددة\",\n        \"أداء سريع وإعداد بسيط\",\n        \"قدرات مشاركة الشبكة\",\n        \"أقل تكلفة بين جميع options\"\n      ],\n      correct: 1,\n      explanation: \"توفر DAS أداءً سريعًا وخيارات سعة عالية وإعدادًا بسيطًا كمزاياها الرئيسية.\"\n    },\n    {\n      question: \"ما هو العيب الأساسي لـ DAS؟\",\n      options: [\n        \"أداء بطيء\",\n        \"تكلفة عالية\",\n        \"غير قابل للوصول من أجهزة أخرى وعرضة لفقدان البيانات إذا تعطل الكمبيوتر المتصل\",\n        \"متطلبات إعداد معقدة\"\n      ],\n      correct: 2,\n      explanation: \"DAS غير قابل للوصول من أجهزة أخرى وعرضة لفقدان البيانات إذا تعطل الكمبيوتر المتصل.\"\n    },\n    {\n      question: \"ماذا تعني SAN وما هي خاصيتها الأساسية؟\",\n      options: [\n        \"Storage Access Network - حل تخزين لاسلكي\",\n        \"System Area Network - يربط الخوادم فقط\",\n        \"Storage Area Networks - شبكة تخزين بيانات مخصصة يمكن الوصول إليها بواسطة خوادم متعددة\",\n        \"Secure Access Network - يوفر تخزينًا مشفرًا\"\n      ],\n      correct: 2,\n      explanation: \"SAN تعني Storage Area Networks. إنها شبكة تخزين بيانات مخصصة يمكن الوصول إليها بواسطة خوادم متعددة.\"\n    },\n    {\n      question: \"أي بيئة تخزين توفر أسرع أداء؟\",\n      options: [\n        \"DAS\",\n        \"SAN\",\n        \"NAS\",\n        \"RAID\"\n      ],\n      correct: 1,\n      explanation: \"توفر SAN أسرع أداء بين options نظرًا لشبكتها المخصصة المصممة خصيصًا لاتصالات عالية الأداء.\"\n    },\n    {\n      question: \"ما هي البروتوكولات الرئيسية المستخدمة في SAN؟\",\n      options: [\n        \"TCP/IP و HTTP\",\n        \"SCSI و SATA\",\n        \"USB و FireWire\",\n        \"Ethernet و WiFi\"\n      ],\n      correct: 1,\n      explanation: \"البروتوكولات المستخدمة في SAN هي SCSI و SATA.\"\n    },\n    {\n      question: \"ما هي نقطة الضعف الرئيسية في SAN المذكورة في الوثيقة؟\",\n      options: [\n        \"السرعة وزمن الوصول\",\n        \"الأمان\",\n        \"التكلفة\",\n        \"التعقيد\"\n      ],\n      correct: 1,\n      explanation: \"وفقًا للوثيقة، ضعف SAN هو الأمان، بينما السرعة وزمن الوصول مدرجة كعيوب.\"\n    },\n    {\n      question: \"ماذا تعني NAS وعلى أي مستوى تعمل؟\",\n      options: [\n        \"Network Access Storage - تعمل على مستوى الكتل\",\n        \"Network Attached Storage - تعمل على مستوى الملفات\",\n        \"Network Array Storage - تعمل على مستوى البتات\",\n        \"Network Administration Storage - تعمل على مستوى النظام\"\n      ],\n      correct: 1,\n      explanation: \"NAS تعني Network Attached Storage. إنها تخزين بيانات كمبيوتر على مستوى الملفات يتصل بأجهزة أخرى على شبكة TCP/IP.\"\n    },\n    {\n      question: \"أي مكون ليس جزءًا من بنية NAS؟\",\n      options: [\n        \"وحدة الرأس (وحدة المعالجة المركزية، الذاكرة)\",\n        \"بطاقة واجهة الشبكة (NIC)\",\n        \"محول ناقل المضيف (HBA)\",\n        \"نظام تشغيل محسن\"\n      ],\n      correct: 2,\n      explanation: \"محول ناقل المضيف (HBA) هو مكون من DAS، وليس NAS. تتضمن مكونات NAS وحدة الرأس، بطاقة واجهة الشبكة، نظام تشغيل محسن، بروتوكولات، وبروتوكولات التخزين.\"\n    },\n    {\n      question: \"ماذا تعني RAID؟\",\n      options: [\n        \"مجموعة عشوائية من الأقراص المستقلة\",\n        \"مجموعة زائدة من الأقراص المستقلة\",\n        \"مجموعة موثوقة من الأقراص المتكاملة\",\n        \"وصول سريع للأقراص الداخلية\"\n      ],\n      correct: 1,\n      explanation: \"RAID تعني Redundant Array of Independent Disks (مجموعة زائدة من الأقراص المستقلة).\"\n    },\n    {\n      question: \"أي وظيفة RAID تكتب كتلًا منطقية متتالية على أقراص فعلية متتالية؟\",\n      options: [\n        \"النسخ المتطابق (Mirroring)\",\n        \"التقسيم (Striping)\",\n        \"حساب التكافؤ (Parity Calculation)\",\n        \"المزامنة (Synchronization)\"\n      ],\n      correct: 1,\n      explanation: \"التقسيم (Striping) يكتب بايتات/كتل منطقية متتالية على أقراص فعلية متتالية.\"\n    },\n    {\n      question: \"أي مستوى RAID يوفر التقسيم بدون تكافؤ أو تكرار؟\",\n      options: [\n        \"RAID 1\",\n        \"RAID 0\",\n        \"RAID 5\",\n        \"RAID 10\"\n      ],\n      correct: 1,\n      explanation: \"RAID 0 يوفر التقسيم بدون تكافؤ، مما يوفر أداءً ممتازًا ولكن بدون تكرار.\"\n    },\n    {\n      question: \"ما هو الحد الأدنى لعدد الأقراص المطلوبة لـ RAID 1؟\",\n      options: [\n        \"قرص واحد\",\n        \"قرصان\",\n        \"3 أقراص\",\n        \"4 أقراص\"\n      ],\n      correct: 1,\n      explanation: \"يتطلب RAID 1 قرصين على الأقل ويوفر تكرارًا ممتازًا حيث يتم نسخ الكتل.\"\n    },\n    {\n      question: \"أي مستوى RAID يوصف بأنه 'شريط من المرايا'؟\",\n      options: [\n        \"RAID 0+1\",\n        \"RAID 5\",\n        \"RAID 10\",\n        \"RAID 6\"\n      ],\n      correct: 2,\n      explanation: \"يُسمى RAID 10 أيضًا 'شريط من المرايا' ويتطلب قرصين على الأقل.\"\n    },\n    {\n      question: \"ما هو الحد الأدنى لعدد الأقراص المطلوبة لـ RAID 5؟\",\n      options: [\n        \"قرصان\",\n        \"3 أقراص\",\n        \"4 أقراص\",\n        \"5 أقراص\"\n      ],\n      correct: 1,\n      explanation: \"يتطلب RAID 5 ثلاثة أقراص على الأقل ويوفر أداءً جيدًا مع تكافؤ موزع.\"\n    },\n    {\n      question: \"أي مستوى RAID يستخدم تقسيمًا على مستوى البايت؟\",\n      options: [\n        \"RAID 3\",\n        \"RAID 4\",\n        \"RAID 5\",\n        \"RAID 6\"\n      ],\n      correct: 0,\n      explanation: \"RAID 3 يستخدم تقسيمًا على مستوى البايت، بينما RAID 4 يستخدم تقسيمًا على مستوى الكتل.\"\n    },\n    {\n      question: \"ما الذي يميز RAID 6 عن RAID 5؟\",\n      options: [\n        \"يستخدم التقسيم بدلاً من النسخ المتطابق\",\n        \"يحتوي على كتل تكافؤ مزدوجة ويتطلب 6 أقراص\",\n        \"يوفر أداءً أفضل\",\n        \"يستخدم عددًا أقل من الأقراص\"\n      ],\n      correct: 1,\n      explanation: \"RAID 6 مشابه لـ RAID 5 باستثناء أنه يحتوي على كتل تكافؤ مزدوجة ويتطلب 6 أقراص.\"\n    },\n    {\n      question: \"أي مستوى RAID موصى به لقواعد البيانات الموجهة للقراءة بكثافة؟\",\n      options: [\n        \"RAID 0\",\n        \"RAID 1\",\n        \"RAID 5\",\n        \"RAID 10\"\n      ],\n      correct: 2,\n      explanation: \"RAID 5 هو الخيار الأفضل من حيث التكلفة الذي يوفر الأداء والتكرار، ويوصى به لقواعد البيانات الموجهة للقراءة بكثافة، على الرغم من أن عمليات الكتابة ستكون بطيئة.\"\n    },\n    {\n      question: \"أي مستوى RAID يعتبر الخيار الأفضل للتطبيقات ذات الأهمية القصوى؟\",\n      options: [\n        \"RAID 0\",\n        \"RAID 5\",\n        \"RAID 6\",\n        \"RAID 10\"\n      ],\n      correct: 3,\n      explanation: \"يوفر RAID 10 تكرارًا ممتازًا وأداءً ممتازًا. إذا كنت تستطيع تحمل التكلفة، فهذا هو الخيار الأفضل لأي تطبيقات ذات أهمية قصوى، خاصة قواعد البيانات.\"\n    },\n    {\n      question: \"أي بيئة تخزين ستكون الأفضل لمستخدم واحد يخزن ملفات شخصية؟\",\n      options: [\n        \"DAS\",\n        \"SAN\",\n        \"NAS\",\n        \"RAID\"\n      ],\n      correct: 0,\n      explanation: \"DAS هو الأفضل لمحطات العمل الفردية وتخزين البيانات الشخصية نظرًا لأدائه السريع وإعداداته البسيطة.\"\n    },\n    {\n      question: \"أي بيئة تخزين هي الأنسب للشركات الصغيرة التي لديها عدة موظفين يشاركون الملفات؟\",\n      options: [\n        \"DAS\",\n        \"SAN\",\n        \"NAS\",\n        \"RAID\"\n      ],\n      correct: 2,\n      explanation: \"NAS هو الأفضل للشركات الصغيرة ومجموعات العمل لأنه يوفر تخزينًا مشتركًا يمكن الوصول إليه من أجهزة متعددة على الشبكة.\"\n    },\n    {\n      question: \"أي بيئة تخزين تتطلب أكبر قدر من الخبرة التقنية لإدارتها؟\",\n      options: [\n        \"DAS\",\n        \"SAN\",\n        \"NAS\",\n        \"RAID\"\n      ],\n      correct: 1,\n      explanation: \"تتطلب SAN خبرة تقنية كبيرة لإدارتها نظرًا لأجهزتها المتخصصة وتكوينها المعقد.\"\n    },\n    {\n      question: \"من حيث ترتيب التكلفة من الأقل إلى الأعلى، ما هو الترتيب correct؟\",\n      options: [\n        \"SAN, NAS, DAS\",\n        \"DAS, NAS, SAN\",\n        \"NAS, DAS, SAN\",\n        \"DAS, SAN, NAS\"\n      ],\n      correct: 1,\n      explanation: \"DAS هو الأرخص بشكل عام، يليه NAS، ثم SAN هو الأغلى نظرًا لأجهزته المتخصصة وتكوينه.\"\n    },\n    {\n      question: \"أي عبارة عن RAID صحيحة؟\",\n      options: [\n        \"RAID يضمن حماية كاملة للبيانات ضد أي فشل\",\n        \"جميع مستويات RAID توفر نفس مستوى الأداء والتكرار\",\n        \"يمكن تنفيذ RAID على كل من أنظمة DAS و NAS\",\n        \"استخدام RAID يلغي الحاجة إلى النسخ الاحتياطي\"\n      ],\n      correct: 2,\n      explanation: \"يمكن تنفيذ RAID على كل من أنظمة DAS و NAS للحصول على فوائد إضافية. لا يضمن RAID حماية كاملة، وتختلف المستويات في الأداء/التكرار، ولا يزال هناك حاجة للنسخ الاحتياطي.\"\n    },\n    {\n      question: \"ما نوع الوصول إلى البيانات الذي توفره SAN؟\",\n      options: [\n        \"وصول البيانات على مستوى الملفات\",\n        \"تخزين البيانات على مستوى الكتل\",\n        \"وصول البيانات على مستوى البايت\",\n        \"وصول البيانات على مستوى التطبيق\"\n      ],\n      correct: 1,\n      explanation: \"توفر SAN تخزين البيانات على مستوى الكتل، مما يسمح لعدة عملاء بالوصول إلى الملفات في نفس الوقت بأداء عالٍ جدًا.\"\n    },\n    {\n      question: \"أي فائدة ليست مرتبطة بـ NAS؟\",\n      options: [\n        \"غير مكلفة نسبيًا\",\n        \"توفر البيانات على مدار الساعة طوال أيام الأسبوع وعن بعد\",\n        \"أسرع أداء بين خيارات التخزين\",\n        \"النسخ الاحتياطي التلقائي إلى أجهزة أخرى والسحابة\"\n      ],\n      correct: 2,\n      explanation: \"أداء NAS أبطأ مقارنة بـ DAS بسبب الحمل الزائد للشبكة. أسرع أداء توفره SAN.\"\n    },\n    {\n      question: \"ماذا يحدث لبيانات RAM عند انقطاع الطاقة؟\",\n      options: [\n        \"يتم نسخ البيانات احتياطيًا تلقائيًا\",\n        \"تبقى البيانات سليمة\",\n        \"يتم مسح البيانات\",\n        \"يتم نقل البيانات إلى ROM\"\n      ],\n      correct: 2,\n      explanation: \"ذاكرة الوصول العشوائي (RAM) متطايرة وتتطلب إمدادًا مستمرًا بالطاقة. يتم مسح البيانات عند إيقاف تشغيل طاقة النظام أو انقطاعها.\"\n    },\n    {\n      question: \"أي مستوى RAID يجب ألا يستخدم للأنظمة الحيوية؟\",\n      options: [\n        \"RAID 0\",\n        \"RAID 1\",\n        \"RAID 5\",\n        \"RAID 10\"\n      ],\n      correct: 0,\n      explanation: \"RAID 0 لا يحتوي على تكرار (لا يوجد نسخة متطابقة، لا يوجد تكافؤ)، لذلك لا ينبغي استخدامه لأي نظام حيوي على الرغم من أدائه الممتاز.\"\n    }\n  ],\n  'الفصل 3: مقدمة وهياكل الكمبيوتر الأساسية': [\n    {\n      question: \"ما هو الغرض الأساسي من الحوسبة وفقًا لريتشارد هامينغ؟\",\n      options: [\n        \"توليد الأرقام والبيانات\",\n        \"توفير الرؤية، وليس مجرد أرقام\",\n        \"تنفيذ التعليمات بكفاءة\",\n        \"حل المعادلات الرياضية\"\n      ],\n      correct: 1,\n      explanation: \"وفقًا لريتشارد هامينغ، 'الغرض من الحوسبة هو الرؤية، وليس الأرقام.' القيمة الحقيقية للحوسبة تكمن في استخدام البيانات لاكتساب الفهم والمعرفة (الرؤية).\"\n    },\n    {\n      question: \"أي مستوى تحويل يقع مباشرة فوق المنطق في التسلسل الهرمي؟\",\n      options: [\n        \"الدوائر\",\n        \"البنية الدقيقة\",\n        \"ISA (البنية)\",\n        \"نظام وقت التشغيل\"\n      ],\n      correct: 1,\n      explanation: \"في مستويات التسلسل الهرمي للتحويل، تقع البنية الدقيقة مباشرة فوق المنطق، والذي يقع فوق الدوائر.\"\n    },\n    {\n      question: \"ما هو التجريد في سياق أنظمة الكمبيوتر؟\",\n      options: [\n        \"طريقة لإخفاء تفاصيل التنفيذ عن المستخدمين\",\n        \"مستوى أعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذها\",\n        \"طريقة لجعل البرامج تعمل بشكل أسرع\",\n        \"تقنية لتحسين تصميم الأجهزة\"\n      ],\n      correct: 1,\n      explanation: \"يعني التجريد أن المستوى الأعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذ المستوى الأدنى.\"\n    },\n    {\n      question: \"لماذا قد تحتاج إلى فهم ما يحدث في مستويات التجريد الأساسية؟\",\n      options: [\n        \"لأغراض أكاديمية فقط\",\n        \"عندما تعمل البرامج ببطء، تستهلك الكثير من الطاقة، أو لا تعمل بشكل صحيح\",\n        \"لإبهار الزملاء بالمعرفة التقنية\",\n        \"ليس ضروريًا أبدًا في الحوسبة الحديثة\"\n      ],\n      correct: 1,\n      explanation: \"تحتاج إلى فهم المستويات الأساسية عندما تعمل البرامج ببطء، تستهلك الكثير من الطاقة، لا تعمل بشكل صحيح، أو عند تصميم أنظمة أكثر كفاءة.\"\n    },\n    {\n      question: \"ما هما الهدفان الرئيسيان لدورة هندسة الكمبيوتر المذكورة؟\",\n      options: [\n        \"تعلم البرمجة وتصميم الأجهزة\",\n        \"فهم المكونات الداخلية للمعالج واتخاذ قرارات تحسين عبر الطبقات\",\n        \"إتقان لغة التجميع والمنطق الرقمي\",\n        \"دراسة الخوارزميات وهياكل البيانات\"\n      ],\n      correct: 1,\n      explanation: \"الهدفان الرئيسيان هما: فهم كيفية عمل المعالج تحت طبقة البرامج وكيف تؤثر قرارات الأجهزة على البرامج/المبرمجين، والتمكين من اتخاذ قرارات التصميم التي تتجاوز حدود الطبقات المختلفة.\"\n    },\n    {\n      question: \"في مثال تباطؤ النظام متعدد النواة، ما الذي يسبب التفاوت في الأداء بين التطبيقات؟\",\n      options: [\n        \"سياسات جدولة وحدة المعالجة المركزية\",\n        \"معدلات فشل ذاكرة التخزين المؤقت\",\n        \"عدم عدالة جدولة متحكم DRAM\",\n        \"زمن انتقال الشبكة\"\n      ],\n      correct: 2,\n      explanation: \"ينجم التفاوت عن سياسات جدولة متحكم DRAM التي تكون غير عادلة لبعض التطبيقات، ولا سيما سياسات 'أول صف إصابة' و 'أقدم أولاً'.\"\n    },\n    {\n      question: \"ماذا يترتب على الوصول إلى الذاكرة المتعارض مع الصف مقارنة بالوصول إلى الصف المصاب؟\",\n      options: [\n        \"وقت وصول أسرع\",\n        \"نفس وقت الوصول\",\n        \"وقت وصول أطول بكثير\",\n        \"وقت وصول أطول قليلاً\"\n      ],\n      correct: 2,\n      explanation: \"يستغرق الوصول إلى الذاكرة المتعارض مع الصف وقتًا أطول بكثير من الوصول إلى الصف المصاب.\"\n    },\n    {\n      question: \"ماذا تعني FR-FCFS في جدولة متحكم DRAM؟\",\n      options: [\n        \"Fast-Ready, First-Come-First-Service\",\n        \"First-Ready, First-Come-First-Service\",\n        \"First-Row, First-Column-First-Service\",\n        \"Fast-Row, First-Cache-First-Service\"\n      ],\n      correct: 1,\n      explanation: \"FR-FCFS تعني First-Ready, First-Come-First-Service، والتي تعطي الأولوية لعمليات الوصول إلى الصفوف المصابة أولاً، ثم لعمليات الوصول الأقدم أولاً.\"\n    },\n    {\n      question: \"أي نوع من التطبيقات تعطي سياسة 'أول صف إصابة' أولوية غير عادلة؟\",\n      options: [\n        \"التطبيقات كثيفة استخدام وحدة المعالجة المركزية\",\n        \"التطبيقات ذات التموضع العالي لمخزن الصفوف\",\n        \"التطبيقات ذات الوصول العشوائي للذاكرة\",\n        \"التطبيقات ذات الاستخدام المنخفض للذاكرة\"\n      ],\n      correct: 1,\n      explanation: \"تعطي سياسة 'أول صف إصابة' أولوية غير عادلة للتطبيقات ذات التموضع العالي لمخزن الصفوف - الخيوط التي تستمر في الوصول إلى نفس الصف.\"\n    },\n    {\n      question: \"ما الفرق بين أنماط الوصول إلى الذاكرة STREAM و RANDOM؟\",\n      options: [\n        \"STREAM أسرع، RANDOM أبطأ\",\n        \"STREAM لديه وصول تسلسلي بتموضع عالٍ لمخزن الصفوف، RANDOM لديه وصول عشوائي بتموضع منخفض لمخزن الصفوف\",\n        \"STREAM يستخدم ذاكرة أكبر، RANDOM يستخدم ذاكرة أقل\",\n        \"STREAM للقراءة، RANDOM للكتابة\"\n      ],\n      correct: 1,\n      explanation: \"لدى STREAM وصول تسلسلي إلى الذاكرة بتموضع عالٍ جدًا لمخزن الصفوف (معدل إصابة 96%)، بينما لدى RANDOM وصول عشوائي إلى الذاكرة بتموضع منخفض جدًا لمخزن الصفوف (معدل إصابة 3%).\"\n    },\n    {\n      question: \"ما الذي تتكون منه خلية DRAM؟\",\n      options: [\n        \"ترانزستوران ومقاوم\",\n        \"مكثف وترانزستور وصول\",\n        \"دائرة قلب (Flip-flop)\",\n        \"بوابات منطقية متعددة\"\n      ],\n      correct: 1,\n      explanation: \"تتكون خلية DRAM من مكثف وترانزستور وصول. تخزن البيانات من حيث الشحنة في المكثف.\"\n    },\n    {\n      question: \"لماذا تحتاج DRAM إلى التحديث بشكل دوري؟\",\n      options: [\n        \"لمنع تلف البيانات من التداخل الكهرومغناطيسي\",\n        \"لأن شحنة المكثف تتسرب بمرور الوقت\",\n        \"للحفاظ على التزامن مع ساعة وحدة المعالجة المركزية\",\n        \"لتحديث البيانات المخزنة\"\n      ],\n      correct: 1,\n      explanation: \"تتسرب شحنة مكثف DRAM بمرور الوقت، لذا يحتاج متحكم الذاكرة إلى تحديث كل صف بشكل دوري لاستعادة الشحنة.\"\n    },\n    {\n      question: \"ما هي الفترة الزمنية النموذجية لتحديث DRAM؟\",\n      options: [\n        \"64 ميكروثانية\",\n        \"64 مللي ثانية\",\n        \"64 ثانية\",\n        \"64 نانوثانية\"\n      ],\n      correct: 1,\n      explanation: \"الفترة الزمنية النموذجية للتحديث هي 64 مللي ثانية - كل صف يحتاج إلى التنشيط كل 64 مللي ثانية.\"\n    },\n    {\n      question: \"ما هي عيوب تحديث DRAM المذكورة في الوثيقة؟\",\n      options: [\n        \"استهلاك الطاقة فقط\",\n        \"استهلاك الطاقة، تدهور الأداء، تأثير جودة الخدمة، وقيود توسيع السعة\",\n        \"تدهور الأداء فقط\",\n        \"قيود السعة فقط\"\n      ],\n      correct: 1,\n      explanation: \"عيوب تحديث DRAM تشمل: استهلاك الطاقة، تدهور الأداء (DRAM غير متاحة أثناء التحديث)، تأثير جودة الخدمة/القدرة على التنبؤ (أوقات توقف)، ومعدل التحديث يحد من توسيع سعة DRAM.\"\n    },\n    {\n      question: \"وفقًا لبحث RAIDR، ما هي نسبة تقليل التحديث التي تم تحقيقها؟\",\n      options: [\n        \"46.8%\",\n        \"74.6%\",\n        \"15.2%\",\n        \"84.3%\"\n      ],\n      correct: 1,\n      explanation: \"حقق RAIDR تقليلًا للتحديث بنسبة 74.6% مع حمل تخزين إضافي يبلغ 1.25 كيلوبايت فقط لذاكرة 32 جيجابايت.\"\n    },\n    {\n      question: \"ما هي الملاحظة الرئيسية وراء نهج RAIDR؟\",\n      options: [\n        \"جميع صفوف DRAM تحتاج إلى تحديث متكرر\",\n        \"يمكن تحديث معظم صفوف DRAM بشكل أقل تكرارًا دون فقدان البيانات\",\n        \"تحديث DRAM غير ضروري\",\n        \"يجب زيادة تردد التحديث\"\n      ],\n      correct: 1,\n      explanation: \"الملاحظة الرئيسية لـ RAIDR هي أن معظم صفوف DRAM يمكن تحديثها بشكل أقل تكرارًا دون فقدان البيانات، مما يسمح بمعدلات تحديث مختلفة لصفوف مختلفة.\"\n    },\n    {\n      question: \"ما هي الخطوات الرئيسية الثلاث في نهج RAIDR؟\",\n      options: [\n        \"القراءة، الكتابة، التحديث\",\n        \"التنميط، التجميع، التحديث\",\n        \"القياس، الفرز، التحسين\",\n        \"الاختبار، التجميع، الجدولة\"\n      ],\n      correct: 1,\n      explanation: \"يستخدم RAIDR ثلاث خطوات: 1) تنميط وقت الاحتفاظ بجميع الصفوف، 2) تجميع الصفوف حسب وقت الاحتفاظ باستخدام فلاتر بلوم، 3) تحديث الصفوف في سلال مختلفة بمعدلات مختلفة.\"\n    },\n    {\n      question: \"ما هو الحمل التخزيني الإضافي الذي يتطلبه RAIDR لذاكرة 32 جيجابايت؟\",\n      options: [\n        \"1.25 ميجابايت\",\n        \"1.25 كيلوبايت\",\n        \"12.5 كيلوبايت\",\n        \"125 كيلوبايت\"\n      ],\n      correct: 1,\n      explanation: \"يتطلب RAIDR 1.25 كيلوبايت فقط من التخزين لذاكرة 32 جيجابايت باستخدام تخزين فعال مع فلاتر بلوم.\"\n    },\n    {\n      question: \"ما هو تحسين الأداء الذي حققه RAIDR؟\",\n      options: [\n        \"~5%\",\n        \"~9%\",\n        \"~16%\",\n        \"~20%\"\n      ],\n      correct: 1,\n      explanation: \"حقق RAIDR تحسينًا في الأداء بنسبة 9% تقريبًا إلى جانب تقليل طاقة DRAM الديناميكية/الخاملة بنسبة 16%/20%.\"\n    },\n    {\n      question: \"في مثال استهلاك الذاكرة، ماذا يحدث عندما تتنافس T0 (STREAM) و T1 (RANDOM) على الوصول إلى الذاكرة؟\",\n      options: [\n        \"يحصلان على وصول متساوٍ\",\n        \"يتم إعطاء الأولوية لـ T1 بسبب سياسة 'الأقدم أولاً'\",\n        \"يتم خدمة 128 طلبًا من T0 قبل T1 بسبب تموضع مخزن الصفوف\",\n        \"تحدث جدولة عشوائية\"\n      ],\n      correct: 2,\n      explanation: \"نظرًا لتموضع مخزن الصفوف، يتم خدمة 128 طلبًا من T0 (STREAM) قبل أن تحصل T1 (RANDOM) على الوصول، حيث تستمر T0 في إصابة نفس الصف بينما تسبب T1 تعارضات في الصفوف.\"\n    },\n    {\n      question: \"ما هي الفكرة الرئيسية حول طبقات التجريد من هذا الفصل؟\",\n      options: [\n        \"يجب عدم كسر طبقات التجريد أبدًا\",\n        \"كسر طبقات التجريد ومعرفة ما هو تحتها يمكّن من حل المشكلات وتصميم نظام أفضل\",\n        \"مصممو الأجهزة فقط هم من يحتاجون إلى فهم طبقات متعددة\",\n        \"طبقات التجريد مهمة فقط لتطوير البرامج\"\n      ],\n      correct: 1,\n      explanation: \"الفكرة الرئيسية هي أن كسر طبقات التجريد ومعرفة ما يحدث تحتها يمكّنك من حل المشكلات وتصميم أنظمة مستقبلية أفضل.\"\n    },\n    {\n      question: \"أي مكون في نظام متعدد النواة مشترك بين جميع النوى؟\",\n      options: [\n        \"ذاكرة التخزين المؤقت L2\",\n        \"ذاكرة التخزين المؤقت L3 ومتحكم ذاكرة DRAM\",\n        \"سجلات وحدة المعالجة المركزية\",\n        \"فك تشفير التعليمات\"\n      ],\n      correct: 1,\n      explanation: \"في مخطط النظام متعدد النوى، ذاكرة التخزين المؤقت L3 المشتركة ومتحكم ذاكرة DRAM مشتركة بين جميع النوى، بينما كل نواة لديها ذاكرة التخزين المؤقت L2 الخاصة بها.\"\n    },\n    {\n      question: \"ما الذي يجعل متحكم DRAM عرضة لهجمات حجب الخدمة (Denial of Service)؟\",\n      options: [\n        \"آليات التشفير الضعيفة\",\n        \"سياسات الجدولة غير العادلة التي يمكن استغلالها بواسطة برامج مكتوبة خصيصًا\",\n        \"عرض النطاق الترددي غير الكافي\",\n        \"عيوب في تصميم الأجهزة\"\n      ],\n      correct: 1,\n      explanation: \"سياسات جدولة DRAM غير عادلة لبعض التطبيقات، ويمكن كتابة البرامج لاستغلال هذا الظلم، مما يجعل المتحكم عرضة لهجمات حجب الخدمة.\"\n    },\n    {\n      question: \"ما هو حجم الصف المذكور في مثال استهلاك الذاكرة؟\",\n      options: [\n        \"4 كيلوبايت\",\n        \"8 كيلوبايت\",\n        \"16 كيلوبايت\",\n        \"32 كيلوبايت\"\n      ],\n      correct: 1,\n      explanation: \"في مثال استهلاك الذاكرة، حجم الصف هو 8 كيلوبايت وحجم كتلة ذاكرة التخزين المؤقت هو 64 بايت، مما يؤدي إلى 128 (8 كيلوبايت/64 بايت) طلبًا.\"\n    },\n    {\n      question: \"وفقًا لرسوم بيانية حمل التحديث الزائد، ما هي نسبة حمل الأداء الزائد التي يمكن أن يسببها التحديث؟\",\n      options: [\n        \"حتى 8%\",\n        \"حتى 46%\",\n        \"حتى 15%\",\n        \"حتى 47%\"\n      ],\n      correct: 1,\n      explanation: \"وفقًا لرسوم بيانية أداء حمل التحديث الزائد، يمكن أن يسبب تحديث DRAM حمل أداء زائد يصل إلى 46%.\"\n    },\n    {\n      question: \"أي نهج تعاوني يقترحه الفصل لحل مشاكل الأنظمة المعقدة؟\",\n      options: [\n        \"حلول الأجهزة فقط\",\n        \"حلول البرامج فقط\",\n        \"التعاون بين مكونات وطبقات متعددة\",\n        \"حلول على مستوى نظام التشغيل فقط\"\n      ],\n      correct: 2,\n      explanation: \"يؤكد الفصل أن التعاون بين مكونات وطبقات متعددة يمكن أن يتيح حلولًا وأنظمة أكثر فعالية.\"\n    },\n    {\n      question: \"في مستويات التحويل، ما الذي يقع في أسفل التسلسل الهرمي؟\",\n      options: [\n        \"المنطق\",\n        \"الدوائر\",\n        \"الإلكترونات\",\n        \"البنية الدقيقة\"\n      ],\n      correct: 2,\n      explanation: \"في مستويات التسلسل الهرمي للتحويل، تقع الإلكترونات في الأسفل، مما يمثل المستوى المادي الأساسي.\"\n    },\n    {\n      question: \"ما الذي تهدف الدورة إلى تمكين الطلاب من فعله فيما يتعلق بقرارات التصميم؟\",\n      options: [\n        \"اتخاذ القرارات ضمن طبقات فردية فقط\",\n        \"التركيز فقط على تحسين البرامج\",\n        \"اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات المختلفة\",\n        \"التخصص في طبقة واحدة محددة\"\n      ],\n      correct: 2,\n      explanation: \"تهدف الدورة إلى تمكين الطلاب من الشعور بالراحة في اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات والمكونات المختلفة للنظام.\"\n    },\n    {\n      question: \"ما هي المعلومات التي يكشفها RAIDR لحل مشكلة التحديث؟\",\n      options: [\n        \"أنماط استخدام وحدة المعالجة المركزية\",\n        \"معلومات ملف وقت الاحتفاظ بصفوف DRAM\",\n        \"معدلات فشل ذاكرة التخزين المؤقت\",\n        \"أنماط حركة مرور الشبكة\"\n      ],\n      correct: 1,\n      explanation: \"يكشف RAIDR معلومات ملف وقت الاحتفاظ بصفوف DRAM إلى متحكم الذاكرة، مما يتيح معدلات تحديث مختلفة لصفوف مختلفة بناءً على خصائص الاحتفاظ بها.\"\n    },\n    {\n      question: \"ما هي العلاقة بين رؤية المبرمج ورؤية مصمم الأجهزة في أنظمة الكمبيوتر؟\",\n      options: [\n        \"هما مستقلان تمامًا\",\n        \"رؤية المبرمج فقط هي المهمة\",\n        \"اختيارات المهندس المعماري/المعماري الدقيق تؤثر بشكل حاسم على كلتا الرؤيتين\",\n        \"رؤية مصمم الأجهزة فقط هي المهمة\"\n      ],\n      correct: 2,\n      explanation: \"تتضمن رؤية المهندس المعماري/المعماري الدقيق تصميم أجهزة كمبيوتر تلبي أهداف تصميم النظام، وتؤثر هذه الاختيارات بشكل حاسم على كل من مبرمج البرامج ومصمم الأجهزة.\"\n    }\n  ],\n  'الفصل 4: مقدمة وأساسيات': [\n    {\n      question: \"وفقًا لريتشارد هامينغ، ما هو الغرض من الحوسبة؟\",\n      options: [\n        \"لتوليد الأرقام والبيانات\",\n        \"لحل المعادلات الرياضية\",\n        \"لاكتساب البصيرة، وليس الأرقام\",\n        \"لمعالجة المعلومات بسرعة\"\n      ],\n      correct: 2,\n      explanation: \"صرح ريتشارد هامينغ بأن 'الغرض من الحوسبة هو البصيرة، وليس الأرقام'. القيمة الحقيقية للحوسبة لا تكمن فقط في توليد الأرقام (البيانات)، بل في استخدام تلك البيانات لاكتساب الفهم والمعرفة (البصيرة).\"\n    },\n    {\n      question: \"ما هي مستويات التحويل في أنظمة الكمبيوتر من الأعلى إلى الأسفل؟\",\n      options: [\n        \"المشكلة ← الخوارزمية ← البرنامج ← ISA ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات\",\n        \"الخوارزمية ← المشكلة ← البرنامج ← ISA ← المنطق ← البنية الدقيقة ← الدوائر ← الإلكترونات\",\n        \"المشكلة ← البرنامج ← الخوارزمية ← ISA ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات\",\n        \"المشكلة ← الخوارزمية ← ISA ← البرنامج ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات\"\n      ],\n      correct: 0,\n      explanation: \"التسلسل الهرمي correct هو: المشكلة ← الخوارزمية ← البرنامج/اللغة ← نظام وقت التشغيل ← ISA (البنية) ← البنية الدقيقة ← المنطق ← الدوائر ← الإلكترونات، ويمثل التحويل من المشكلات عالية المستوى إلى التنفيذ المادي.\"\n    },\n    {\n      question: \"ما هو التجريد في سياق أنظمة الكمبيوتر؟\",\n      options: [\n        \"طريقة لجعل الأنظمة أكثر تعقيدًا\",\n        \"مستوى أعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذها\",\n        \"طريقة لدمج مستويات متعددة في مستوى واحد\",\n        \"تقنية للتخلص من المكونات غير الضرورية\"\n      ],\n      correct: 1,\n      explanation: \"يعني التجريد أن المستوى الأعلى يحتاج فقط إلى معرفة الواجهة للمستوى الأدنى، وليس كيفية تنفيذ المستوى الأدنى. على سبيل المثال، لا يحتاج مبرمج لغة عالية المستوى إلى معرفة ما هو ISA أو كيفية تنفيذ الكمبيوتر للتعليمات.\"\n    },\n    {\n      question: \"لماذا قد تحتاج إلى فهم ما يحدث في طبقات التجريد الأساسية؟\",\n      options: [\n        \"لأغراض أكاديمية فقط\",\n        \"عندما تعمل البرامج ببطء، بشكل غير صحيح، أو تستهلك الكثير من الطاقة\",\n        \"لجعل البرمجة أكثر صعوبة\",\n        \"ليس من الضروري أبدًا فهم الطبقات الأساسية\"\n      ],\n      correct: 1,\n      explanation: \"يصبح فهم الطبقات الأساسية أمرًا حاسمًا عندما: يعمل البرنامج ببطء، لا يعمل بشكل صحيح، يستهلك الكثير من الطاقة، أو عند تصميم أنظمة أكثر كفاءة وأداءً أعلى.\"\n    },\n    {\n      question: \"في مثال هجوم أداء الذاكرة في النظام متعدد النواة، ما الذي يسبب التفاوت في التباطؤ بين التطبيقات؟\",\n      options: [\n        \"سرعات وحدة المعالجة المركزية المختلفة\",\n        \"اختلافات حجم ذاكرة التخزين المؤقت\",\n        \"عدم عدالة سياسة جدولة DRAM بسبب تموضع مخزن الصفوف\",\n        \"جدولة نظام التشغيل\"\n      ],\n      correct: 2,\n      explanation: \"ينجم التفاوت عن سياسات جدولة DRAM التي تكون غير عادلة لبعض التطبيقات. سياسة 'أول صف إصابة' تعطي أولوية غير عادلة للتطبيقات ذات التموضع العالي لمخزن الصفوف، بينما سياسة 'الأقدم أولاً' تعطي أولوية غير عادلة للتطبيقات كثيفة الذاكرة.\"\n    },\n    {\n      question: \"ما هي سياسة جدولة FR-FCFS في متحكمات DRAM؟\",\n      options: [\n        \"First-Request, First-Come-First-Service\",\n        \"First-Ready, First-Come-First-Service\",\n        \"First-Row, First-Column-First-Service\",\n        \"Fast-Response, First-Come-First-Service\"\n      ],\n      correct: 1,\n      explanation: \"FR-FCFS تعني First-Ready, First-Come-First-Service. لديها قاعدتان: (1) 'أول صف إصابة': خدمة عمليات الوصول إلى الذاكرة التي تصيب الصف أولاً، (2) 'الأقدم أولاً': ثم خدمة عمليات الوصول الأقدم أولاً.\"\n    },\n    {\n      question: \"ما الذي يجعل الوصول إلى صف متعارض في DRAM أبطأ بكثير من الوصول إلى صف مصاب؟\",\n      options: [\n        \"تأخيرات معالجة وحدة المعالجة المركزية\",\n        \"عقوبات عدم إصابة ذاكرة التخزين المؤقت\",\n        \"الحاجة إلى إغلاق الصف الحالي وفتح صف جديد في DRAM\",\n        \"زمن انتقال الشبكة\"\n      ],\n      correct: 2,\n      explanation: \"يتطلب الوصول إلى صف متعارض إغلاق الصف المفتوح حاليًا وفتح صف جديد في DRAM، الأمر الذي يستغرق وقتًا أطول بكثير من الوصول إلى البيانات من صف مفتوح بالفعل (إصابة الصف).\"\n    },\n    {\n      question: \"في مثال استهلاك أداء الذاكرة، ما الذي يميز نمط الوصول STREAM؟\",\n      options: [\n        \"وصول عشوائي للذاكرة بتموضع منخفض لمخزن الصفوف\",\n        \"وصول تسلسلي للذاكرة بتموضع عالٍ جدًا لمخزن الصفوف (معدل إصابة 96%)\",\n        \"وصول ذاكرة مبعثر بتموضع متوسط\",\n        \"نمط وصول ذاكرة دائري\"\n      ],\n      correct: 1,\n      explanation: \"يتميز STREAM بالوصول التسلسلي إلى الذاكرة بتموضع عالٍ جدًا لمخزن الصفوف (معدل إصابة 96%) وهو كثيف الذاكرة، مما يجعله مستهلكًا لأداء الذاكرة.\"\n    },\n    {\n      question: \"ما الذي يميز نمط الوصول RANDOM في مثال أداء الذاكرة؟\",\n      options: [\n        \"وصول تسلسلي بتموضع عالٍ\",\n        \"وصول عشوائي للذاكرة بتموضع منخفض جدًا لمخزن الصفوف (معدل إصابة 3%)\",\n        \"وصول منظم بتموضع متوسط\",\n        \"نمط وصول يمكن التنبؤ به\"\n      ],\n      correct: 1,\n      explanation: \"يتميز RANDOM بالوصول العشوائي إلى الذاكرة بتموضع منخفض جدًا لمخزن الصفوف (معدل إصابة 3%) وهو كثيف الذاكرة بالمثل مقارنة بـ STREAM.\"\n    },\n    {\n      question: \"ما الذي تتكون منه خلية DRAM؟\",\n      options: [\n        \"ترانزستوران ومقاوم\",\n        \"مكثف وترانزستور وصول\",\n        \"ثلاثة مكثفات متسلسلة\",\n        \"دائرة قلب (Flip-flop)\"\n      ],\n      correct: 1,\n      explanation: \"تتكون خلية DRAM من مكثف وترانزستور وصول. تخزن البيانات من حيث الشحنة في المكثف.\"\n    },\n    {\n      question: \"لماذا تحتاج DRAM إلى التحديث؟\",\n      options: [\n        \"لتحسين الأداء\",\n        \"لأن شحنة المكثف تتسرب بمرور الوقت\",\n        \"لتقليل استهلاك الطاقة\",\n        \"لزيادة سعة التخزين\"\n      ],\n      correct: 1,\n      explanation: \"تتسرب شحنة مكثف DRAM بمرور الوقت، لذا يحتاج متحكم الذاكرة إلى تحديث كل صف بشكل دوري لاستعادة الشحنة. عادة ما يجب تحديث كل صف كل 64 مللي ثانية.\"\n    },\n    {\n      question: \"ما هي العيوب الرئيسية لتحديث DRAM؟\",\n      options: [\n        \"زيادة التكلفة فقط\",\n        \"تدهور الأداء فقط\",\n        \"استهلاك الطاقة، تدهور الأداء، تأثير جودة الخدمة، وقيود توسيع السعة\",\n        \"استهلاك الطاقة فقط\"\n      ],\n      correct: 2,\n      explanation: \"يحتوي تحديث DRAM على العديد من العيوب: استهلاك الطاقة (كل تحديث يستهلك طاقة)، تدهور الأداء (DRAM غير متاحة أثناء التحديث)، تأثير جودة الخدمة/القدرة على التنبؤ (أوقات توقف طويلة)، ومعدل التحديث يحد من توسيع سعة DRAM.\"\n    },\n    {\n      question: \"ما هي الفترة الزمنية النموذجية لتحديث صفوف DRAM؟\",\n      options: [\n        \"64 ميكروثانية\",\n        \"64 مللي ثانية\",\n        \"64 ثانية\",\n        \"64 نانوثانية\"\n      ],\n      correct: 1,\n      explanation: \"الفترة الزمنية النموذجية للتحديث هي 64 مللي ثانية (64 ms). يجب تنشيط (تحديث) كل صف كل 64 مللي ثانية لاستعادة الشحنة في المكثفات.\"\n    },\n    {\n      question: \"ما هي الملاحظة الرئيسية التي يقدمها RAIDR حول تحديث DRAM؟\",\n      options: [\n        \"جميع الصفوف تحتاج إلى تحديث متكرر\",\n        \"يمكن تحديث معظم صفوف DRAM بشكل أقل تكرارًا دون فقدان البيانات\",\n        \"التحديث غير ضروري\",\n        \"فقط بعض الصفوف تحتاج إلى أي تحديث\"\n      ],\n      correct: 1,\n      explanation: \"يلاحظ RAIDR أن معظم صفوف DRAM يمكن تحديثها بشكل أقل تكرارًا دون فقدان البيانات، مما يؤدي إلى فكرة تحديث الصفوف التي تحتوي على خلايا ضعيفة بشكل متكرر والصفوف الأخرى بشكل أقل.\"\n    },\n    {\n      question: \"كيف يحقق RAIDR تقليل التحديث؟\",\n      options: [\n        \"عن طريق إلغاء التحديث تمامًا\",\n        \"عن طريق تنميط أوقات الاحتفاظ، وتجميع الصفوف، وتحديث المجموعات المختلفة بمعدلات مختلفة\",\n        \"عن طريق استخدام تقنية DRAM مختلفة\",\n        \"عن طريق زيادة تردد التحديث لجميع الصفوف\"\n      ],\n      correct: 1,\n      explanation: \"يعمل RAIDR في ثلاث خطوات: (1) تنميط وقت الاحتفاظ بجميع الصفوف، (2) تجميع الصفوف حسب وقت الاحتفاظ في متحكم الذاكرة باستخدام فلاتر بلوم، (3) تحديث الصفوف في سلال مختلفة بمعدلات مختلفة.\"\n    },\n    {\n      question: \"ما هي الفوائد التي حققها RAIDR؟\",\n      options: [\n        \"تحسين الأداء فقط\",\n        \"74.6% تقليل التحديث، ~16%/20% تقليل طاقة DRAM، ~9% تحسين الأداء\",\n        \"تقليل الطاقة فقط\",\n        \"تقليل التحديث فقط\"\n      ],\n      correct: 1,\n      explanation: \"يحقق RAIDR فوائد متعددة: 74.6% تقليل التحديث مع حمل تخزين إضافي يبلغ 1.25 كيلوبايت فقط، ~16%/20% تقليل طاقة DRAM الديناميكية/الخاملة، و ~9% تحسين الأداء، مع زيادة الفوائد بزيادة سعة DRAM.\"\n    },\n    {\n      question: \"ما هو أحد الهدفين الرئيسيين لدورة هندسة الكمبيوتر المذكورة في المحاضرة؟\",\n      options: [\n        \"تعلم لغات البرمجة\",\n        \"فهم كيفية عمل المعالج تحت طبقة البرامج\",\n        \"تصميم أنظمة التشغيل\",\n        \"بناء مكونات الأجهزة\"\n      ],\n      correct: 1,\n      explanation: \"أحد الأهداف الرئيسية هو فهم كيفية عمل المعالج تحت طبقة البرامج وكيف تؤثر القرارات المتخذة في الأجهزة على البرامج/المبرمج.\"\n    },\n    {\n      question: \"ما هو الهدف الرئيسي الثاني لدورة هندسة الكمبيوتر؟\",\n      options: [\n        \"حفظ مجموعات التعليمات\",\n        \"التمكين من اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات المختلفة\",\n        \"التركيز فقط على تصميم الأجهزة\",\n        \"التخصص في طبقة تجريد واحدة\"\n      ],\n      correct: 1,\n      explanation: \"الهدف الرئيسي الثاني هو تمكين الطلاب من الشعور بالراحة في اتخاذ قرارات التصميم والتحسين التي تتجاوز حدود الطبقات والمكونات المختلفة للنظام.\"\n    },\n    {\n      question: \"في سيناريو استهلاك أداء الذاكرة، كم عدد الطلبات تقريبًا لتطبيق STREAM (T0) يتم خدمتها قبل خدمة تطبيق RANDOM (T1)؟\",\n      options: [\n        \"64 طلبًا\",\n        \"96 طلبًا\",\n        \"128 طلبًا\",\n        \"256 طلبًا\"\n      ],\n      correct: 2,\n      explanation: \"مع حجم صف يبلغ 8 كيلوبايت وحجم كتلة ذاكرة تخزين مؤقت يبلغ 64 بايت، هناك 128 (8 كيلوبايت/64 بايت) طلبًا من T0 (STREAM) يتم خدمتها قبل أن يحصل T1 (RANDOM) على فرصة، مما يوضح عدم عدالة سياسة 'أول صف إصابة'.\"\n    },\n    {\n      question: \"ما هي الفكرة الرئيسية حول طبقات التجريد من هذه المحاضرة؟\",\n      options: [\n        \"يجب عدم عبور طبقات التجريد أبدًا\",\n        \"كسر طبقات التجريد ومعرفة ما هو تحتها يمكّن من حل المشكلات\",\n        \"مصممو الأجهزة فقط هم من يحتاجون إلى فهم طبقات متعددة\",\n        \"طبقات التجريد هي مفاهيم نظرية فقط\"\n      ],\n      correct: 1,\n      explanation: \"الفكرة الرئيسية هي أن كسر طبقات التجريد (بين المكونات ومستويات التسلسل الهرمي للتحويل) ومعرفة ما هو تحتها يمكّنك من حل المشكلات وتصميم أنظمة مستقبلية أفضل. يمكن أن يتيح التعاون بين مكونات وطبقات متعددة حلولًا أكثر فعالية.\"\n    }\n  ],\n  \"الفصل الخامس: ما هو الكمبيوتر ونموذج فون نيومان\": [\n    {\n      question: \"ما هي المكونات الرئيسية الثلاثة التي تحدد الكمبيوتر؟\",\n      options: [\n        \"الأجهزة، البرامج، والمستخدمون\",\n        \"الحساب، الاتصال، والتخزين (الذاكرة)\",\n        \"الإدخال، المعالجة، والإخراج\",\n        \"وحدة المعالجة المركزية، ذاكرة الوصول العشوائي، والقرص الصلب\"\n      ],\n      correct: 1,\n      explanation: \"يتم تعريف الكمبيوتر من خلال ثلاثة مكونات رئيسية: الحساب (المعالجة)، الاتصال (الإدخال/الإخراج)، والتخزين (الذاكرة). تعمل هذه المكونات معًا لتشكيل نظام حوسبة كامل.\"\n    },\n    {\n      question: \"ما هما الخاصيتان الرئيسيتان لنموذج فون نيومان؟\",\n      options: [\n        \"معالجة سريعة وذاكرة كبيرة\",\n        \"برنامج مخزن ومعالجة تعليمات متسلسلة\",\n        \"نوى متعددة ومعالجة متوازية\",\n        \"إمكانيات الإدخال/الإخراج وواجهة المستخدم\"\n      ],\n      correct: 1,\n      explanation: \"يحتوي نموذج فون نيومان على خاصيتين رئيسيتين: (1) برنامج مخزن - تعليمات مخزنة في مصفوفة ذاكرة خطية مع ذاكرة موحدة للتعليمات والبيانات، (2) معالجة تعليمات متسلسلة - تعليمة واحدة تتم معالجتها في كل مرة مع عداد البرنامج يحدد التعليمات الحالية.\"\n    },\n    {\n      question: \"في نموذج فون نيومان، ما الذي يحدد ما إذا كانت القيمة المخزنة تفسر كتعليمات؟\",\n      options: [\n        \"القيمة نفسها\",\n        \"موقع الذاكرة\",\n        \"إشارات التحكم\",\n        \"نوع البيانات\"\n      ],\n      correct: 2,\n      explanation: \"في نموذج فون نيومان، يعتمد تفسير القيمة المخزنة على إشارات التحكم. يمكن تفسير نفس نمط البت كبيانات أو كتعليمات اعتمادًا على كيفية معالجة وحدة التحكم لها.\"\n    },\n    {\n      question: \"ما هو الاسم الآخر لبنية فون نيومان؟\",\n      options: [\n        \"كمبيوتر معالجة متوازية\",\n        \"كمبيوتر برنامج مخزن\",\n        \"كمبيوتر تدفق البيانات\",\n        \"كمبيوتر متعدد النواة\"\n      ],\n      correct: 1,\n      explanation: \"تُسمى بنية فون نيومان أيضًا 'كمبيوتر برنامج مخزن' لأن التعليمات تخزن في الذاكرة جنبًا إلى جنب مع البيانات، بدلاً من أن تكون موصلة بشكل ثابت في الجهاز.\"\n    },\n    {\n      question: \"في نموذج فون نيومان، كيف يتم تقدم عداد البرنامج (مؤشر التعليمات)؟\",\n      options: [\n        \"عشوائيًا بناءً على التعليمات المتاحة\",\n        \"بناءً على توفر البيانات\",\n        \"بشكل تسلسلي باستثناء تعليمات نقل التحكم\",\n        \"بشكل متوازٍ لتعليمات متعددة\"\n      ],\n      correct: 2,\n      explanation: \"يتم تقدم عداد البرنامج بشكل تسلسلي باستثناء تعليمات نقل التحكم (مثل القفزات، التفرعات، الاستدعاءات). هذا التقدم التسلسلي هو سمة أساسية لتنفيذ فون نيومان.\"\n    },\n    {\n      question: \"في نموذج تدفق البيانات، متى يتم تنفيذ تعليمات؟\",\n      options: [\n        \"عندما يشير مؤشر التعليمات إليها\",\n        \"عندما تكون جميع معاملاتها جاهزة\",\n        \"بترتيب تسلسلي\",\n        \"عندما تكون وحدة المعالجة المركزية خاملة\"\n      ],\n      correct: 1,\n      explanation: \"في نموذج تدفق البيانات، يتم تنفيذ التعليمات عندما تكون جميع معاملاتها جاهزة (أي، عندما تحتوي جميع المدخلات على رموز). لا يوجد مؤشر تعليمات - يتم تشغيل التنفيذ بتوفر البيانات.\"\n    },\n    {\n      question: \"ما هو الفرق الرئيسي بين نماذج تنفيذ فون نيومان وتدفق البيانات؟\",\n      options: [\n        \"فون نيومان يستخدم ذاكرة أكبر\",\n        \"فون نيومان موجه بالتحكم/تسلسلي، تدفق البيانات موجه بالبيانات/متوازٍ\",\n        \"تدفق البيانات أبطأ من فون نيومان\",\n        \"فون نيومان يتطلب أجهزة خاصة\"\n      ],\n      correct: 1,\n      explanation: \"نموذج فون نيومان موجه بالتحكم مع تنفيذ تسلسلي (مؤشر التعليمات يتحكم في الترتيب)، بينما نموذج تدفق البيانات موجه بالبيانات مع تنفيذ متوازٍ محتمل (توفر البيانات يتحكم في الترتيب).\"\n    },\n    {\n      question: \"أي نموذج تنفيذ هو أكثر توازيًا بطبيعته؟\",\n      options: [\n        \"نموذج فون نيومان\",\n        \"نموذج تدفق البيانات\",\n        \"كلاهما متوازٍ بالتساوي\",\n        \"لا يدعم أي منهما التوازي\"\n      ],\n      correct: 1,\n      explanation: \"نموذج تدفق البيانات أكثر توازيًا بطبيعته لأن تعليمات متعددة يمكن أن 'تطلق' (تنفذ) في وقت واحد عندما تكون معاملاتها جاهزة، على عكس التنفيذ التسلسلي لفون نيومان.\"\n    },\n    {\n      question: \"في آلة تدفق البيانات، ما الذي يتسبب في 'إطلاق' عقدة تدفق البيانات؟\",\n      options: [\n        \"إشارة ساعة\",\n        \"مؤشر التعليمات\",\n        \"عندما تكون جميع مدخلاتها تحتوي على رموز (جاهزة)\",\n        \"محفز عشوائي\"\n      ],\n      correct: 2,\n      explanation: \"تطلق عقدة تدفق البيانات (يتم جلبها وتنفيذها) عندما تكون جميع مدخلاتها جاهزة، أي عندما تحتوي جميع المدخلات على رموز. هذا هو مبدأ التنفيذ الأساسي للحوسبة بتدفق البيانات.\"\n    },\n    {\n      question: \"ما هي بنيات مجموعات التعليمات الرئيسية التي تستخدم نموذج فون نيومان اليوم؟\",\n      options: [\n        \"x86 فقط\",\n        \"x86، ARM، MIPS، SPARC، Alpha، POWER\",\n        \"ARM و x86 فقط\",\n        \"البنيات القديمة فقط\"\n      ],\n      correct: 1,\n      explanation: \"جميع بنيات مجموعات التعليمات الرئيسية اليوم تستخدم نموذج فون نيومان، بما في ذلك بنيات x86، ARM، MIPS، SPARC، Alpha، و POWER.\"\n    },\n    {\n      question: \"على مستوى البنية الدقيقة، كيف تنفذ المعالجات الحديثة التعليمات فعليًا؟\",\n      options: [\n        \"تمامًا كما هو محدد بواسطة نموذج فون نيومان\",\n        \"بشكل مختلف تمامًا عن نموذج فون نيومان (مقسمة، خارج الترتيب، إلخ)\",\n        \"بترتيب تسلسلي فقط\",\n        \"بدون أي تحسين\"\n      ],\n      correct: 1,\n      explanation: \"تنفذ البنيات الدقيقة الحديثة بشكل مختلف تمامًا عن نموذج فون نيومان - باستخدام التنفيذ المقسم، تعليمات متعددة في نفس الوقت، التنفيذ خارج الترتيب، وذاكرات تخزين مؤقت منفصلة للتعليمات/البيانات، ولكن هذا لا يُكشف للبرامج.\"\n    },\n    {\n      question: \"ما هو الفرق الرئيسي بين ISA والبنية الدقيقة؟\",\n      options: [\n        \"ISA هي الأجهزة، البنية الدقيقة هي البرامج\",\n        \"ISA هي الواجهة المتفق عليها بين البرامج/الأجهزة، البنية الدقيقة هي التنفيذ المحدد\",\n        \"هما نفس الشيء\",\n        \"ISA قديمة، البنية الدقيقة جديدة\"\n      ],\n      correct: 1,\n      explanation: \"ISA هي الواجهة المتفق عليها بين البرامج والأجهزة (ما يحتاج كاتب البرامج إلى معرفته)، بينما البنية الدقيقة هي التنفيذ المحدد لـ ISA (غير مرئي للبرامج).\"\n    },\n    {\n      question: \"باستخدام تشبيه السيارة، ما الذي يمثل ISA مقابل البنية الدقيقة؟\",\n      options: [\n        \"المحرك مقابل العجلات\",\n        \"دواسة الوقود (الواجهة) مقابل المكونات الداخلية للمحرك (التنفيذ)\",\n        \"عجلة القيادة مقابل الفرامل\",\n        \"الخارج مقابل الداخل\"\n      ],\n      correct: 1,\n      explanation: \"تمثل دواسة الوقود ISA (واجهة 'التسارع' التي يستخدمها السائق)، بينما تمثل المكونات الداخلية للمحرك البنية الدقيقة (كيف يتم 'التسارع' فعليًا).\"\n    },\n    {\n      question: \"ما الذي يتغير بشكل أسرع: ISA أم البنية الدقيقة؟\",\n      options: [\n        \"ISA تتغير بشكل أسرع\",\n        \"البنية الدقيقة تتغير بشكل أسرع\",\n        \"يتغيران بنفس المعدل\",\n        \"لا يتغير أي منهما\"\n      ],\n      correct: 1,\n      explanation: \"تتغير البنية الدقيقة عادةً بشكل أسرع من ISA. هناك عدد قليل من ISAs (x86، ARM، SPARC، MIPS، Alpha) ولكن العديد من البنيات الدقيقة. على سبيل المثال، لدى x86 ISA العديد من التطبيقات: 286، 386، 486، بنتيوم، بنتيوم برو، بنتيوم 4، كور، إلخ.\"\n    },\n    {\n      question: \"ماذا تشير المعالجة الفائقة إلى؟\",\n      options: [\n        \"استخدام نوى وحدة المعالجة المركزية متعددة\",\n        \"تقنية لتنفيذ تعليمات متعددة بالتوازي داخل نفس نواة المعالج\",\n        \"زيادة تردد الساعة\",\n        \"إضافة المزيد من الذاكرة\"\n      ],\n      correct: 1,\n      explanation: \"المعالجة الفائقة هي تقنية تستخدم في تصميم المعالجات الدقيقة الحديثة لزيادة إنتاجية التعليمات عن طريق تنفيذ تعليمات متعددة بالتوازي داخل نفس نواة المعالج، مما يسمح بأكثر من تعليمات واحدة لكل دورة ساعة.\"\n    },\n    {\n      question: \"أي مما يلي جزء من ISA؟\",\n      options: [\n        \"عدد المنافذ لملف السجل\",\n        \"رمز تشغيل تعليمة ADD\",\n        \"ما إذا كان الجهاز يستخدم التنفيذ المقسم\",\n        \"عدد الدورات لتنفيذ تعليمة MUL\"\n      ],\n      correct: 1,\n      explanation: \"رمز تشغيل تعليمة ADD جزء من ISA لأنه يحدد واجهة التعليمات. عدد منافذ ملف السجل، التنفيذ المقسم، ودورات التنفيذ هي تفاصيل تنفيذ البنية الدقيقة غير مرئية للبرامج.\"\n    },\n    {\n      question: \"أي مما يلي جزء من البنية الدقيقة؟\",\n      options: [\n        \"عدد السجلات ذات الأغراض العامة\",\n        \"رموز تشغيل التعليمات\",\n        \"عدد المنافذ لملف السجل\",\n        \"أوضاع عنونة الذاكرة\"\n      ],\n      correct: 2,\n      explanation: \"عدد المنافذ لملف السجل هو تفصيل في البنية الدقيقة (خيار تنفيذ للأداء). عدد السجلات، رموز التشغيل، وأوضاع العنونة هي مواصفات ISA مرئية للمبرمجين.\"\n    },\n    {\n      question: \"ما الذي تحدده ISA فيما يتعلق بالتعليمات؟\",\n      options: [\n        \"تنسيق التعليمات فقط\",\n        \"رموز التشغيل، أوضاع العنونة، أنواع البيانات، أنواع وتنسيقات التعليمات، السجلات، رموز الشرط\",\n        \"وقت التنفيذ فقط\",\n        \"متطلبات الذاكرة فقط\"\n      ],\n      correct: 1,\n      explanation: \"تحدد ISA عناصر شاملة متعلقة بالتعليمات: رموز التشغيل، أوضاع العنونة، أنواع البيانات، أنواع وتنسيقات التعليمات، السجلات، ورموز الشرط - كل ما يحتاج المبرمج إلى معرفته لكتابة البرامج.\"\n    },\n    {\n      question: \"أي مما يلي خيارات تنفيذ البنية الدقيقة؟\",\n      options: [\n        \"إدارة الذاكرة الافتراضية\",\n        \"التنفيذ المقسم، التنفيذ خارج الترتيب، سياسات التخزين المؤقت، المعالجة الفائقة\",\n        \"تعريف مجموعة التعليمات\",\n        \"أوضاع عنونة الذاكرة\"\n      ],\n      correct: 1,\n      explanation: \"تتضمن البنية الدقيقة خيارات تنفيذ مثل التنفيذ المقسم، التنفيذ بالترتيب أم خارج الترتيب، جدولة الوصول إلى الذاكرة، المعالجة الفائقة، سياسات التخزين المؤقت، الجلب المسبق، إلخ - كل ذلك يتم بدون كشف للبرامج.\"\n    },\n    {\n      question: \"في مثال التنفيذ خارج الترتيب بالتعليمات (1) mov eax,0 (2) mov edx,1 (3) mov edx,3 (4) inc edx (5) mov ecx,3، ما الذي يحدد ترتيب التنفيذ؟\",\n      options: [\n        \"يجب الحفاظ على ترتيب البرنامج الأصلي\",\n        \"تحدد الترانزستورات/الأجهزة بناءً على التبعيات والموارد المتاحة\",\n        \"اختيار عشوائي\",\n        \"دائمًا يتم التنفيذ بترتيب عكسي\"\n      ],\n      correct: 1,\n      explanation: \"في التنفيذ خارج الترتيب، تحدد الترانزستورات (الأجهزة) التعليمات التي يجب تنفيذها بناءً على تبعيات البيانات والموارد التنفيذية المتاحة، مع الحفاظ على دلالات البرنامج correctة.\"\n    }\n  ],\n  'الفصل 6: مقدمة في المقايضات في ISA': [\n    {\n      question: \"ما هي نقطة التصميم في هندسة الكمبيوتر؟\",\n      options: [\n        \"موقع محدد على شريحة المعالج\",\n        \"مجموعة من اعتبارات التصميم وأهميتها التي تؤدي إلى مقايضات\",\n        \"المرحلة النهائية لتصميم المعالج\",\n        \"منهجية اختبار للمعالجات\"\n      ],\n      correct: 1,\n      explanation: \"نقطة التصميم هي مجموعة من اعتبارات التصميم وأهميتها التي تؤدي إلى مقايضات في كل من ISA والبنية الدقيقة. يتم تحديدها بواسطة مساحة التطبيق والسوق/المستخدمين المستهدفين.\"\n    },\n    {\n      question: \"أي مما يلي هي اعتبارات تصميم رئيسية مذكورة في المحاضرة؟\",\n      options: [\n        \"التكلفة والأداء فقط\",\n        \"التكلفة، الأداء، استهلاك الطاقة، استهلاك الطاقة (عمر البطارية)، التوفر، الموثوقية، الوقت اللازم للتسويق\",\n        \"الأداء والموثوقية فقط\",\n        \"تعقيد الأجهزة وتوافق البرامج\"\n      ],\n      correct: 1,\n      explanation: \"تشمل اعتبارات التصميم الرئيسية: التكلفة، الأداء، أقصى استهلاك للطاقة، استهلاك الطاقة (عمر البطارية)، التوفر، الموثوقية والصحة، والوقت اللازم للتسويق.\"\n    },\n    {\n      question: \"ما الذي يحدد نقطة تصميم نظام الكمبيوتر؟\",\n      options: [\n        \"التقنية المتاحة\",\n        \"تكلفة التصنيع\",\n        \"مساحة 'المشكلة' (مساحة التطبيق) والسوق/المستخدمون المستهدفون\",\n        \"اللوائح الحكومية\"\n      ],\n      correct: 2,\n      explanation: \"يتم تحديد نقطة التصميم بواسطة مساحة 'المشكلة' (مساحة التطبيق) والسوق/المستخدمين المستهدفين، مما يؤثر على الأهمية النسبية لاعتبارات التصميم المختلفة.\"\n    },\n    {\n      question: \"ما هما المكونان الرئيسيان للتعليمات؟\",\n      options: [\n        \"العنوان والبيانات\",\n        \"رمز التشغيل والمعاملات\",\n        \"المصدر والوجهة\",\n        \"الإدخال والإخراج\"\n      ],\n      correct: 1,\n      explanation: \"تتكون التعليمات من: (1) رمز التشغيل - ما تفعله التعليمات، و (2) المعاملات - لمن تقوم بها. هذا هو العنصر الأساسي لواجهة الأجهزة/البرامج.\"\n    },\n    {\n      question: \"ما هو مفهوم 'توجيه البتات' في ترميز التعليمات؟\",\n      options: [\n        \"استخدام البتات للتحكم في اتجاه تدفق البيانات\",\n        \"بت في التعليمات يحدد تفسير البتات الأخرى\",\n        \"توجيه البتات نحو وحدة المنطق والحساب\",\n        \"إدارة العمليات على مستوى البتات\"\n      ],\n      correct: 1,\n      explanation: \"توجيه البتات هو مفهوم حيث يحدد بت في التعليمات تفسير البتات الأخرى، مما يسمح باستخدام أكثر كفاءة لمساحة ترميز التعليمات.\"\n    },\n    {\n      question: \"في آلة ذات 0 عنوان (مكدس)، كيف يتم تنفيذ العمليات؟\",\n      options: [\n        \"باستخدام السجلات فقط\",\n        \"تعمل العمليات على العناصر العلوية للمكدس (دفع/سحب)\",\n        \"عنونة الذاكرة المباشرة\",\n        \"باستخدام سجل التجميع\"\n      ],\n      correct: 1,\n      explanation: \"في آلة مكدس ذات 0 عنوان، تعمل العمليات على العناصر العلوية للمكدس. يتم دفع المعاملات إلى المكدس، وتنفذ العمليات على العناصر العلوية للمكدس، ويتم سحب النتائج.\"\n    },\n    {\n      question: \"ما الذي يميز آلة ذات 1 عنوان (تجميع)؟\",\n      options: [\n        \"تستخدم جميع العمليات المكدس\",\n        \"العمليات تستخدم سجل التجميع (op ACC, ld A, st A)\",\n        \"معاملان لكل تعليمة\",\n        \"ثلاثة معاملات منفصلة\"\n      ],\n      correct: 1,\n      explanation: \"في آلة تجميع ذات 1 عنوان، تتضمن العمليات عادة سجل التجميع (ACC). التعليمات مثل 'op ACC'، 'ld A' (تحميل إلى ACC)، 'st A' (تخزين من ACC) هي مميزة.\"\n    },\n    {\n      question: \"في آلة ذات 2 عنوان، ماذا يحدث لأحد المعاملات؟\",\n      options: [\n        \"يبقى دون تغيير\",\n        \"معامل واحد هو المصدر والوجهة (يتم تدميره)\",\n        \"يتم نسخه إلى الذاكرة\",\n        \"يتم دفعه إلى المكدس\"\n      ],\n      correct: 1,\n      explanation: \"في آلة ذات 2 عنوان (op S,D)، يعمل أحد المعاملات كمصدر ووجهة، مما يعني أن القيمة الأصلية يتم الكتابة فوقها (تدميرها) بنتيجة العملية.\"\n    },\n    {\n      question: \"ما هي الميزة الرئيسية لآلة ذات 3 عناوين؟\",\n      options: [\n        \"حجم تعليمات أصغر\",\n        \"المصدر والوجهة منفصلان (op S1,S2,D)\",\n        \"تنفيذ أسرع\",\n        \"استهلاك طاقة أقل\"\n      ],\n      correct: 1,\n      explanation: \"في آلة ذات 3 عناوين (op S1,S2,D)، يكون معاملا المصدر والوجهة منفصلين، مما يعني أن قيم المصدر محفوظة ولا يتم تدميرها أثناء العمليات.\"\n    },\n    {\n      question: \"ما هي المزايا الرئيسية لآلات المكدس؟\",\n      options: [\n        \"حجم تعليمات كبير ومنطق معقد\",\n        \"حجم تعليمات صغير، منطق أبسط، كود مدمج، استدعاءات إجراءات فعالة\",\n        \"مرونة عالية وعمليات متوازية\",\n        \"دعم أنواع بيانات معقدة\"\n      ],\n      correct: 1,\n      explanation: \"تتميز آلات المكدس بـ: حجم تعليمات صغير (لا توجد حاجة لمعاملات لتعليمات التشغيل)، منطق أبسط، كود مدمج، واستدعاءات إجراءات فعالة (جميع المعلمات على المكدس بدون دورات إضافية لتمرير المعلمات).\"\n    },\n    {\n      question: \"ما هي العيوب الرئيسية لآلات المكدس؟\",\n      options: [\n        \"حجم كود كبير وتنفيذ بطيء\",\n        \"العمليات الحسابية التي لا يمكن التعبير عنها بسهولة في تدوين لاحق (postfix) صعبة؛ مرونة محدودة\",\n        \"استهلاك طاقة عالٍ\",\n        \"فك تشفير تعليمات معقد\"\n      ],\n      correct: 1,\n      explanation: \"تتميز آلات المكدس بعيوب: العمليات الحسابية التي لا يمكن التعبير عنها بسهولة في تدوين لاحق صعبة التخطيط، لا يمكنها إجراء عمليات على العديد من القيم في وقت واحد (فقط أعلى N قيم)، وتفتقر إلى المرونة.\"\n    },\n    {\n      question: \"PDP-11 هو مثال على أي نوع من الآلات؟\",\n      options: [\n        \"آلة ذات 0 عنوان (مكدس)\",\n        \"آلة ذات 1 عنوان (تجميع)\",\n        \"آلة ذات 2 عنوان\",\n        \"آلة ذات 3 عناوين\"\n      ],\n      correct: 2,\n      explanation: \"PDP-11 هي آلة ذات 2 عنوان. تحتوي تعليمة ADD الخاصة بها على رمز تشغيل 4 بت و2 مُحددات معامل 6 بت، مع بتات محدودة لتحديد تعليمة.\"\n    },\n    {\n      question: \"ما هي العيب الرئيسي لتصميم PDP-11 ذو 2 عنوان؟\",\n      options: [\n        \"الكثير من المعاملات\",\n        \"يتم دائمًا تدمير أحد معاملي المصدر بالنتيجة\",\n        \"التعليمات طويلة جدًا\",\n        \"لا يمكن الوصول إلى الذاكرة\"\n      ],\n      correct: 1,\n      explanation: \"في تصميم PDP-11 ذو 2 عنوان، يتم دائمًا تدمير أحد معاملي المصدر (الكتابة فوقه) بنتيجة التعليمات، مما يتطلب خطوات إضافية للحفاظ على القيم الأصلية عند الحاجة.\"\n    },\n    {\n      question: \"ما هو نوع آلة بنية ألفا؟\",\n      options: [\n        \"آلة ذاكرة/ذاكرة ذات 2 عنوان\",\n        \"آلة مكدس\",\n        \"آلة تحميل/تخزين ذات 3 عناوين\",\n        \"آلة تجميع ذات 1 عنوان\"\n      ],\n      correct: 2,\n      explanation: \"ألفا هي آلة تحميل/تخزين ذات 3 عناوين، مما يعني أنها تحتوي على معاملات مصدر ووجهة منفصلة، ويتم الوصول إلى الذاكرة فقط من خلال تعليمات تحميل وتخزين صريحة.\"\n    },\n    {\n      question: \"ما هو نوع آلة x86؟\",\n      options: [\n        \"آلة تحميل/تخزين ذات 3 عناوين\",\n        \"آلة ذاكرة/ذاكرة ذات 2 عنوان\",\n        \"آلة مكدس فقط\",\n        \"آلة تجميع ذات 1 عنوان\"\n      ],\n      correct: 1,\n      explanation: \"x86 هي آلة ذاكرة/ذاكرة ذات 2 عنوان، مما يعني أنها يمكن أن تنفذ عمليات مباشرة بين مواقع الذاكرة والسجلات، مع معامل واحد يعمل كمصدر ووجهة.\"\n    },\n    {\n      question: \"كيف يتم تعريف نوع البيانات في سياق ISA؟\",\n      options: [\n        \"أي تمثيل ثنائي\",\n        \"تمثيل للمعلومات توجد له تعليمات تعمل على هذا التمثيل\",\n        \"الأنواع الأولية فقط مثل الأعداد correctة\",\n        \"تنسيق تخزين الذاكرة فقط\"\n      ],\n      correct: 1,\n      explanation: \"يتم تعريف نوع البيانات على أنه تمثيل للمعلومات توجد له تعليمات تعمل على هذا التمثيل. لا يتعلق الأمر بتنسيق التخزين فقط، بل بدعم التعليمات.\"\n    },\n    {\n      question: \"أي مما يلي أمثلة على أنواع البيانات المذكورة؟\",\n      options: [\n        \"الأعداد correctة والنقطة العائمة فقط\",\n        \"الأعداد correctة، النقطة العائمة، الحرف، الثنائي، العشري، BCD، القائمة المترابطة المزدوجة، قائمة الانتظار، السلسلة، المتجه البت، المكدس\",\n        \"أنواع البيانات الأولية فقط\",\n        \"الأنواع الرقمية فقط\"\n      ],\n      correct: 1,\n      explanation: \"تذكر المحاضرة أنواع بيانات مختلفة: الأعداد correctة، النقطة العائمة، الحرف، الثنائي، العشري، BCD، القائمة المترابطة المزدوجة، قائمة الانتظار، السلسلة، المتجه البت، والمكدس - تتراوح من الأنواع الأولية إلى الأنواع المهيكلة المعقدة.\"\n    },\n    {\n      question: \"ما هو مثال لتعليمة نوع بيانات عالية المستوى من VAX؟\",\n      options: [\n        \"ADD و SUB فقط\",\n        \"INSQUEUE (إدراج في قائمة الانتظار) و REMQUEUE (إزالة من قائمة الانتظار) على قوائم مترابطة مزدوجة\",\n        \"التحميل والتخزين فقط\",\n        \"العمليات الحسابية الأساسية\"\n      ],\n      correct: 1,\n      explanation: \"قدمت VAX تعليمات عالية المستوى مثل INSQUEUE (إدراج في قائمة الانتظار) و REMQUEUE (إزالة من قائمة الانتظار) التي تعمل على قوائم مترابطة مزدوجة أو قوائم انتظار، و FINDFIRST لعمليات هيكل البيانات المعقدة.\"\n    },\n    {\n      question: \"ما الذي يشير إليه 'الفجوة الدلالية' في هندسة الكمبيوتر؟\",\n      options: [\n        \"المسافة المادية بين المكونات\",\n        \"التفاوت بين مفاهيم البرامج عالية المستوى وعمليات الأجهزة منخفضة المستوى\",\n        \"التأخير الزمني في تنفيذ التعليمات\",\n        \"زمن انتقال الوصول إلى الذاكرة\"\n      ],\n      correct: 1,\n      explanation: \"تشير الفجوة الدلالية إلى التفاوت بين المفاهيم والتجريدات عالية المستوى المستخدمة في برمجة البرامج والعمليات والآليات منخفضة المستوى المطبقة في الأجهزة.\"\n    },\n    {\n      question: \"كيف تختلف بنيات RISC المبكرة و Intel 432 من حيث الفجوة الدلالية؟\",\n      options: [\n        \"كلاهما له نفس النهج\",\n        \"RISC المبكر: نوع بيانات عدد صحيح فقط (فجوة كبيرة)؛ Intel 432: نوع بيانات كائن، قائم على القدرات (فجوة صغيرة)\",\n        \"كلاهما يركز على أنواع البيانات المعقدة\",\n        \"كلاهما يستخدم الأنواع الأولية فقط\"\n      ],\n      correct: 1,\n      explanation: \"كانت بنيات RISC المبكرة تحتوي على أنواع بيانات عدد صحيح فقط (مما أدى إلى فجوة دلالية كبيرة)، بينما دعمت Intel 432 أنواع بيانات الكائنات وكانت قائمة على القدرات (محاولة لسد الفجوة الدلالية بميزات عالية المستوى).\"\n    }\n  ],\n  'الفصل 7: المقايضات في ISA': [\n    {\n      question: \"أي ISA قدم تعليمات مخصصة لعمليات القائمة المترابطة المزدوجة مثل INSQUEUE؟\",\n      options: [\"x86\", \"VAX\", \"MIPS\", \"ARM\"],\n      correct: 1,\n      explanation: \"كان لدى VAX تعليمات متخصصة لعمليات قوائم الانتظار/القوائم، مما يعكس فلسفة تصميم CISC.\"\n    },\n    {\n      question: \"ما هو نوع البيانات الأساسي المدعوم في بنيات RISC المبكرة؟\",\n      options: [\"نقطة عائمة\", \"عدد صحيح فقط\", \"مراجع الكائنات\", \"عشري مشفر ثنائيًا\"],\n      correct: 1,\n      explanation: \"دعمت تصميمات RISC المبكرة مثل MIPS الأعداد correctة فقط للحفاظ على البساطة.\"\n    },\n    {\n      question: \"توضح أنواع بيانات الكائنات في Intel 432 أي نوع من نهج الفجوة الدلالية؟\",\n      options: [\"فجوة قصوى\", \"فجوة مصغرة\", \"لا فجوة\", \"فجوة متغيرة\"],\n      correct: 1,\n      explanation: \"هدفت Intel 432 إلى تقليل الفجوة من خلال دعم البنى عالية المستوى مباشرة في الأجهزة.\"\n    },\n    {\n      question: \"في نظام قابل للعنونة 32 بت مثل Alpha الأول، كيف يمكنك إضافة رقمين 32 بت؟\",\n      options: [\n        \"باستخدام تعليمات تحميل/تخزين 32 بت\",\n        \"باستخدام تعليمة ADD واحدة 64 بت\",\n        \"من خلال عمليات الذاكرة إلى الذاكرة\",\n        \"باستخدام عمليات قابلة للعنونة بالبت\"\n      ],\n      correct: 0,\n      explanation: \"يتطلب عمليات متعددة بسبب قيود العنونة 32 بت.\"\n    },\n    {\n      question: \"أي بنية حاسوب عملاق استخدمت عنونة 64 بت؟\",\n      options: [\"Burroughs 1700\", \"Cray-1\", \"Intel 432\", \"VAX-11\"],\n      correct: 1,\n      explanation: \"أجهزة الكمبيوتر العملاقة Cray كانت رائدة في عنونة 64 بت للحوسبة العلمية.\"\n    },\n    {\n      question: \"أي بنية تستخدم ترتيب البايت الكبير (big-endian)؟\",\n      options: [\"x86\", \"PowerPC\", \"ARM (وضع little-endian)\", \"ناقل PCI الأصلي\"],\n      correct: 1,\n      explanation: \"تعد PowerPC و SPARC من البنيات الكبيرة البارزة.\"\n    },\n    {\n      question: \"في أنظمة little-endian، كيف تخزن القيمة 0x12345678 في العنوان A؟\",\n      options: [\n        \"A:12 A+1:34 A+2:56 A+3:78\",\n        \"A:78 A+1:56 A+2:34 A+3:12\",\n        \"A:56 A+1:78 A+2:12 A+3:34\",\n        \"مقسمة عبر خطوط ذاكرة التخزين المؤقت\"\n      ],\n      correct: 1,\n      explanation: \"يخزن little-endian البايت الأقل أهمية في أدنى عنوان.\"\n    },\n    {\n      question: \"ما هي خاصية البرامج التي تبرر وجود السجلات في ISA؟\",\n      options: [\n        \"التوطين المكاني\",\n        \"توطين البيانات (زماني ومكاني)\",\n        \"تأثير جدار الذاكرة\",\n        \"عنق الزجاجة في فون نيومان\"\n      ],\n      correct: 1,\n      explanation: \"تستغل السجلات التوطين الزماني (البيانات المعاد استخدامها) والتوطين المكاني (البيانات القريبة).\"\n    },\n    {\n      question: \"كم عدد السجلات ذات الأغراض العامة التي قدمتها IA-64 (Itanium)؟\",\n      options: [\"8\", \"16\", \"32\", \"128\"],\n      correct: 3,\n      explanation: \"توسعت IA-64 إلى 128 سجلًا للتوازي الصريح.\"\n    },\n    {\n      question: \"لماذا لا يستطيع المبرمجون الوصول مباشرة إلى سجلات خط الأنابيب؟\",\n      options: [\n        \"محمية بواسطة نظام التشغيل\",\n        \"تمثل حالة البنية الدقيقة\",\n        \"غير قابلة للوصول ماديًا\",\n        \"تخالف حماية الذاكرة\"\n      ],\n      correct: 1,\n      explanation: \"تعد سجلات خط الأنابيب جزءًا من البنية الدقيقة الخاصة بالتنفيذ.\"\n    },\n    {\n      question: \"أي فئة تعليمات تغير تسلسل التنفيذ؟\",\n      options: [\n        \"تعليمات التشغيل\",\n        \"تعليمات نقل البيانات\",\n        \"تعليمات تدفق التحكم\",\n        \"تعليمات النقطة العائمة\"\n      ],\n      correct: 2,\n      explanation: \"تعليمات تدفق التحكم (التفرعات/القفزات) تغير عداد البرنامج.\"\n    },\n    {\n      question: \"أي وضع عنونة يجمع بين سجل أساسي وسجل فهرس؟\",\n      options: [\n        \"الإزاحة\",\n        \"التسجيل غير المباشر\",\n        \"العنونة المفهرسة\",\n        \"الذاكرة غير المباشرة\"\n      ],\n      correct: 2,\n      explanation: \"تستخدم العنونة المفهرسة حساب الأساس + الفهرس.\"\n    },\n    {\n      question: \"ماذا يعني 'ISA المتعامد'؟\",\n      options: [\n        \"التعليمات تستخدم الزوايا القائمة فقط\",\n        \"جميع التعليمات يمكنها استخدام جميع أوضاع العنونة\",\n        \"محاذاة تعليمات ثابتة 90 درجة\",\n        \"خطوط أنابيب منفصلة للأعداد correctة/النقطة العائمة\"\n      ],\n      correct: 1,\n      explanation: \"التعامد يعني التجميع الموحد للعمليات وأوضاع العنونة.\"\n    },\n    {\n      question: \"ما هي الميزة الرئيسية للتعليمات ذات الطول المتغير؟\",\n      options: [\n        \"فك تشفير أجهزة أبسط\",\n        \"كثافة كود أفضل\",\n        \"سرعات ساعة أسرع\",\n        \"سجلات أكثر\"\n      ],\n      correct: 1,\n      explanation: \"يتيح الطول المتغير ترميزًا مدمجًا (مثل x86).\"\n    },\n    {\n      question: \"أي حقل في تعليمات MIPS I-type يحمل القيمة الفورية؟\",\n      options: [\"rs\", \"rt\", \"opcode\", \"حقل فوري 16 بت\"],\n      correct: 3,\n      explanation: \"يستخدم I-type قيمة فورية 16 بت للثوابت/الزوايا.\"\n    },\n    {\n      question: \"ما هو العيب الرئيسي لتعليمات CISC المعقدة؟\",\n      options: [\n        \"فرص تحسين محدودة للمترجم\",\n        \"الكثير من السجلات\",\n        \"ترميز ثابت الطول\",\n        \"نقص دعم الذاكرة الافتراضية\"\n      ],\n      correct: 0,\n      explanation: \"خلقت التعليمات المعقدة عمليات ذات مستوى تفصيلي كبير قيدت التحسينات.\"\n    },\n    {\n      question: \"أي تعليمات VAX وفرت الوصول إلى المصفوفات مع التحقق من الحدود؟\",\n      \"خيارات\": [\"MOV\", \"INDEX\", \"BOUNDS\", \"ARRAY\"],\n      correct: 1,\n      explanation: \"تعليمات VAX INDEX كانت مثالاً على دعم لغة عالية المستوى.\"\n    },\n    {\n      question: \"أي خاصية ليست نموذجية لتصميمات RISC؟\",\n      options: [\n        \"أوضاع عنونة متعددة\",\n        \"فك تشفير موحد\",\n        \"تعليمات ثابتة الطول\",\n        \"بنية تحميل/تخزين\"\n      ],\n      correct: 0,\n      explanation: \"تقلل RISC من أوضاع العنونة من أجل البساطة.\"\n    },\n    {\n      question: \"ما الذي حفز بادئات تعليمات x86؟\",\n      options: [\n        \"التوافق مع الإصدارات السابقة\",\n        \"فك تشفير أسرع\",\n        \"سجلات أقل\",\n        \"دعم big-endian\"\n      ],\n      correct: 0,\n      explanation: \"سمحت البادئات بتوسيع ISA مع الحفاظ على التوافق.\"\n    },\n    {\n      question: \"ما الذي دفع تطور ISA وفقًا للفصل؟\",\n      options: [\n        \"قيود المترجم\",\n        \"قيود الذاكرة\",\n        \"احتياجات التخصص\",\n        \"كل ما سبق\"\n      ],\n      correct: 3,\n      explanation: \"كل هذه العوامل أثرت تاريخيًا على تصميم ISA.\"\n    },\n    {\n      question: \"كم عدد البايتات التي يمكن أن تشغلها بادئات تعليمات x86؟\",\n      options: [\"0\", \"1\", \"حتى 4\", \"2 بالضبط\"],\n      correct: 2,\n      explanation: \"يسمح x86 بما يصل إلى أربع بادئات بايت واحد.\"\n    },\n    {\n      question: \"أي تنسيق تعليمات MIPS يحتوي على قيمة فورية 26 بت؟\",\n      options: [\"R-type\", \"I-type\", \"J-type\", \"U-type\"],\n      correct: 2,\n      explanation: \"يستخدم J-type (القفز) قيمًا فورية 26 بت لأهداف العنوان.\"\n    }\n  ],\n  'الفصل 8: البنية الدقيقة ذات الدورة الواحدة': [\n    {\n      question: \"ما هو الغرض الأساسي من ذاكرة التخزين المؤقت؟\",\n      options: [\n        \"لتخزين جميع تعليمات البرنامج بشكل دائم\",\n        \"لتخزين التعليمات النشطة/المستخدمة بشكل متكرر وتسريع المعالجة\",\n        \"لاستبدال الذاكرة الرئيسية بالكامل\",\n        \"لتخزين نتائج العمليات الحسابية فقط\"\n      ],\n      correct: 1,\n      explanation: \"تقوم ذاكرة التخزين المؤقت بتخزين التعليمات النشطة أو المستخدمة بشكل متكرر مؤقتًا لتسريع المعالجة وتقليل الاختناقات بين ذاكرة الوصول العشوائي ووحدة المعالجة المركزية.\"\n    },\n    {\n      question: \"أثناء جزء الجلب من دورة التعليمات، ما هو دور ناقل العنوان؟\",\n      options: [\n        \"ينقل رمز تشغيل التعليمات إلى وحدة المنطق والحساب\",\n        \"ينقل عنوان التعليمات إلى الذاكرة الرئيسية\",\n        \"يخزن نتيجة التعليمات المنفذة\",\n        \"يفك تشفير التعليمات لوحدة التحكم\"\n      ],\n      correct: 1,\n      explanation: \"ينقل ناقل العنوان عنوان الذاكرة للتعليمات المراد جلبها من الذاكرة الرئيسية إلى وحدة المعالجة المركزية.\"\n    },\n    {\n      question: \"أي مما يلي هو عيب لسرعات الساعة الأعلى في وحدات المعالجة المركزية؟\",\n      options: [\n        \"يمكن تنفيذ عدد أقل من التعليمات في الثانية\",\n        \"قد ترتفع درجة حرارة وحدة المعالجة المركزية وتتطلب المزيد من التبريد\",\n        \"تعمل البرامج بشكل أبطأ بسبب زيادة التعقيد\",\n        \"يتم تقليل عرض ناقل البيانات\"\n      ],\n      correct: 1,\n      explanation: \"تزيد سرعات الساعة الأعلى من استهلاك الطاقة وتوليد الحرارة، مما قد يتسبب في ارتفاع درجة الحرارة ويتطلب حلول تبريد إضافية.\"\n    },\n    {\n      question: \"في بنية دقيقة ذات دورة واحدة، كم عدد دورات الساعة التي تستغرقها كل تعليمة للتنفيذ؟\",\n      options: [\n        \"دورة واحدة\",\n        \"دورتين\",\n        \"دورات متغيرة حسب التعليمات\",\n        \"ست دورات (واحدة لكل مرحلة)\"\n      ],\n      correct: 0,\n      explanation: \"في بنية دقيقة ذات دورة واحدة، يتم إكمال جميع مراحل التعليمات (الجلب، فك التشفير، التنفيذ، إلخ) ضمن دورة ساعة واحدة.\"\n    },\n    {\n      question: \"ما الذي يحدد وقت دورة الساعة في بنية دقيقة ذات دورة واحدة؟\",\n      options: [\n        \"أسرع تعليمة\",\n        \"متوسط زمن انتقال التعليمات\",\n        \"أبطأ تعليمة\",\n        \"عدد الوحدات الوظيفية\"\n      ],\n      correct: 2,\n      explanation: \"تحدد أبطأ تعليمة وقت دورة الساعة لأن جميع التعليمات يجب أن تكتمل ضمن دورة واحدة.\"\n    }\n  ],\n  'الفصل 9: البنية الدقيقة متعددة الدورات والخطية': [\n    {\n      question: \"كيف تختلف البنية الدقيقة متعددة الدورات عن تصميم الدورة الواحدة؟\",\n      options: [\n        \"تستغرق التعليمات دائمًا دورات أقل لإكمالها\",\n        \"قد تمتد كل مرحلة من دورة التعليمات على عدة دورات ساعة\",\n        \"تلغي الحاجة إلى وحدة تحكم\",\n        \"تستخدم ناقل بيانات أصغر\"\n      ],\n      correct: 1,\n      explanation: \"في بنية دقيقة متعددة الدورات، يمكن أن تستغرق كل مرحلة (الجلب، فك التشفير، إلخ) عدة دورات ساعة، مما يسمح بأوقات دورة أقصر.\"\n    },\n    {\n      question: \"ما هي الميزة الرئيسية للآلات متعددة الدورات على الآلات ذات الدورة الواحدة؟\",\n      options: [\n        \"تحدد أبطأ تعليمة وقت الدورة\",\n        \"وقت دورة الساعة أقصر لأنه يعتمد على أبطأ مرحلة، وليس التعليمات\",\n        \"لا تتطلب إشارات تحكم\",\n        \"جميع التعليمات تنفذ بالتوازي\"\n      ],\n      correct: 1,\n      explanation: \"تقوم الآلات متعددة الدورات بتقسيم التعليمات إلى مراحل، مما يسمح بتحديد وقت دورة الساعة بواسطة أبطأ مرحلة بدلاً من أبطأ تعليمة.\"\n    },\n    {\n      question: \"أي مكون يولد إشارات التحكم لتنسيق مسار البيانات في معالجة التعليمات؟\",\n      \"خيارات\": [\n        \"ALU\",\n        \"ذاكرة التخزين المؤقت\",\n        \"منطق التحكم\",\n        \"ناقل العنوان\"\n      ],\n      correct: 2,\n      explanation: \"يفك تشفير منطق التحكم التعليمات ويولد إشارات لتوجيه مسار البيانات (مثل ALU، السجلات) حول كيفية معالجة البيانات.\"\n    },\n    {\n      question: \"ماذا يحدث لعداد البرنامج (PC) أثناء مرحلة الجلب؟\",\n      options: [\n        \"يتم إعادة تعيينه إلى الصفر\",\n        \"يتم زيادته ليشير إلى التعليمات التالية\",\n        \"يخزن نتيجة عملية ALU\",\n        \"يحتفظ برمز التشغيل لفك التشفير\"\n      ],\n      correct: 1,\n      explanation: \"بعد جلب التعليمات، يتم زيادة عداد البرنامج ليشير إلى التعليمات التالية في الذاكرة.\"\n    },\n    {\n      question: \"أي مما يلي صحيح حول مرحلة التنفيذ؟\",\n      options: [\n        \"تسترد التعليمات من الذاكرة الرئيسية\",\n        \"تفك تشفير رمز التشغيل إلى إشارات تحكم\",\n        \"تنفذ العملية الفعلية (مثل حساب ALU)\",\n        \"تخزن النتيجة في سجل التعليمات\"\n      ],\n      correct: 2,\n      explanation: \"تنفذ مرحلة التنفيذ العملية المحددة بواسطة التعليمات، مثل العمليات الحسابية في ALU أو نقل البيانات.\"\n    }\n  ],\n  'الفصل 10: مقدمة في البنية الدقيقة': [\n    {\n      question: \"ما هي السمة الرئيسية للبنية الدقيقة ذات الدورة الواحدة؟\",\n      options: [\n        \"تكمل جميع التعليمات التنفيذ في دورة ساعة واحدة\",\n        \"يتم تقسيم التعليمات على عدة دورات\",\n        \"فقط تعليمات الحساب تستخدم دورة واحدة\",\n        \"يستغرق الوصول إلى الذاكرة دورات متغيرة حسب زمن الوصول\"\n      ],\n      correct: 0,\n      explanation: \"في البنية الدقيقة ذات الدورة الواحدة، تكمل كل تعليمة (مثل ALU، تحميل/تخزين) جميع المراحل (الجلب، فك التشفير، التنفيذ، إلخ) ضمن دورة ساعة واحدة.\"\n    },\n    {\n      question: \"أي مكون مسؤول عن الاحتفاظ بعنوان التعليمات الحالية في مسار البيانات ذي الدورة الواحدة؟\",\n      options: [\n        \"ملف السجل\",\n        \"عداد البرنامج (PC)\",\n        \"ALU\",\n        \"ذاكرة البيانات\"\n      ],\n      correct: 1,\n      explanation: \"يخزن عداد البرنامج (PC) عنوان التعليمات الحالية التي يتم تنفيذها ويزداد بمقدار 4 (لـ MIPS) بعد كل جلب.\"\n    },\n    {\n      question: \"ما هو دور وحدة 'تمديد الإشارة' في مسار البيانات؟\",\n      options: [\n        \"لتحويل القيم الفورية ذات 16 بت إلى قيم موقعة 32 بت\",\n        \"لإجراء عمليات حسابية\",\n        \"للاختيار بين سجل أو معاملات فورية\",\n        \"لإدارة عناوين الذاكرة\"\n      ],\n      correct: 0,\n      explanation: \"تقوم وحدة تمديد الإشارة بتوسيع القيم الفورية ذات 16 بت (على سبيل المثال، في تعليمات I-type) إلى 32 بت مع الحفاظ على الإشارة لعمليات حسابية صحيحة.\"\n    },\n    {\n      question: \"أي إشارة تحكم تحدد ما إذا كانت ALU تستخدم قيمة سجل أو قيمة فورية كمعاملها الثاني؟\",\n      options: [\n        \"RegWrite\",\n        \"ALUSrc\",\n        \"MemtoReg\",\n        \"Branch\"\n      ],\n      correct: 1,\n      explanation: \"تختار ALUSrc بين معامل السجل الثاني (على سبيل المثال، لـ R-type) أو قيمة فورية ممتدة الإشارة (على سبيل المثال، لـ ADDI/LW/SW).\"\n    },\n    {\n      question: \"ماذا يحدث أثناء مرحلة 'MEM' لتعليمات LW؟\",\n      options: [\n        \"تحسب ALU عنوان الذاكرة الفعلي\",\n        \"يتم قراءة البيانات من الذاكرة وكتابتها في سجل\",\n        \"يتم جلب التعليمات من الذاكرة\",\n        \"يتم تحديث PC\"\n      ],\n      correct: 1,\n      explanation: \"في مرحلة MEM، يتم الوصول إلى ذاكرة البيانات باستخدام العنوان المحسوب في EX، ويتم كتابة النتيجة لاحقًا إلى سجل في WB.\"\n    },\n    {\n      question: \"أي نوع تعليمات يتطلب إشارة التحكم 'RegDst' لتحديد سجل الوجهة من البتات [15:11]؟\",\n      options: [\n        \"I-type (على سبيل المثال، ADDI)\",\n        \"R-type (على سبيل المثال، ADD)\",\n        \"Load (على سبيل المثال، LW)\",\n        \"Store (على سبيل المثال، SW)\"\n      ],\n      correct: 1,\n      explanation: \"تستخدم تعليمات R-type البتات [15:11] لسجل الوجهة (rd)، بينما تستخدم I-type (على سبيل المثال، ADDI/LW) البتات [20:16] (rt).\"\n    },\n    {\n      question: \"لماذا تصميم الدورة الواحدة غير فعال للتطبيقات الواقعية؟\",\n      options: [\n        \"لا يمكنه التعامل مع تعليمات التفرع\",\n        \"يجب أن تستوعب دورة الساعة أبطأ تعليمة (على سبيل المثال، LW)\",\n        \"يفتقر إلى ملف سجل\",\n        \"وصول الذاكرة غير متزامن\"\n      ],\n      correct: 1,\n      explanation: \"يتم تحديد طول دورة الساعة بواسطة أبطأ تعليمة (مثل LW، التي تستخدم الوصول إلى الذاكرة)، مما يجعل التعليمات الأسرع (مثل ADD) بطيئة بشكل غير ضروري.\"\n    },\n    {\n      question: \"ما هو الغرض من مضاعف 'MemtoReg' في مسار البيانات؟\",\n      options: [\n        \"للاختيار بين نتيجة ALU أو بيانات الذاكرة للكتابة الخلفية إلى السجل\",\n        \"للاختيار بين معاملات السجل\",\n        \"لتمديد القيم الفورية\",\n        \"لحساب أهداف التفرع\"\n      ],\n      correct: 0,\n      explanation: \"تختار MemtoReg ما إذا كانت بيانات الكتابة الخلفية تأتي من نتيجة ALU (على سبيل المثال، لـ ADD) أو الذاكرة (على سبيل المثال، لـ LW).\"\n    }\n  ],\n};\n\n\n\n\n\n// Create a mapping between English and Arabic chapter names\nconst chapterMapping = {\n  // Add your English to Arabic mappings here.\n  // IMPORTANT: The LEFT side (English) MUST EXACTLY match the keys in your `quizData`.\n  // The RIGHT side (Arabic) MUST EXACTLY match the keys in your `quizDataArabic`.\n  'Chapter 1: Introduction': 'الفصل 1: مقدمة',\n  'Chapter 2: Storage Environment and RAID': 'الفصل 2: بيئة التخزين و RAID',\n  'Chapter 3: Computer Architecture Introduction and Basics': 'الفصل 3: مقدمة وهياكل الكمبيوتر الأساسية',\n  'Chapter 4: Introduction and Basics': 'الفصل 4: مقدمة وأساسيات',\n  'Chapter 5: What is A Computer and Von Neumann Model': 'الفصل 5: ما هو الكمبيوتر ونموذج فون نيومان',\n  'Chapter 6: Introduction to ISA Tradeoffs': 'الفصل 6: مقدمة في المقايضات في ISA',\n  'Chapter 7: ISA Tradeoffs': 'الفصل 7: المقايضات في ISA',\n  'Chapter 8: Single-Cycle Microarchitecture': 'الفصل 8: البنية الدقيقة ذات الدورة الواحدة',\n  'Chapter 9: Multi-Cycle and Pipelined Microarchitecture': 'الفصل 9: البنية الدقيقة متعددة الدورات والخطية',\n  'Chapter 10: Introduction to Microarchitecture': 'الفصل 10: مقدمة في البنية الدقيقة'\n};\n\n// Reverse mapping (Arabic to English)\nconst reverseChapterMapping = {};\nObject.keys(chapterMapping).forEach(englishName => {\n  reverseChapterMapping[chapterMapping[englishName]] = englishName;\n});\n\nexport { quizData, quizDataArabic, chapterMapping, reverseChapterMapping };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}